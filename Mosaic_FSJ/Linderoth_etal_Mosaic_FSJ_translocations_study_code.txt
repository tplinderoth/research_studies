#############################################################################################
# This document contains code for analyzing data in the Linderoth et al. study              #
# titled "translocations spur population growth but exacerbate inbreeding in an imperiled   #
# species".                                                                                 #
#                                                                                           #
# Author contact: lindero1@msu.edu                                                          #
#############################################################################################

Bash code ran interactively (for launching jobs, etc.) are prefixed with '$'.

## ---------- UNIVERSAL R FUNCTIONS ---------- ##

pointcodes <- function(df = NULL) {
  site_code <- replace(as.character(df$site),which(df$site == "Wellfield"), "119") # W
  site_code <- replace(site_code, which(site_code == "SITE_1"), "0") # open square
  site_code <- replace(site_code,which(site_code == "SITE_13"), "1") # open circle
  site_code <- replace(site_code,which(site_code == "SITE_12"), "2") # open upwards triangle
  site_code <- replace(site_code,which(site_code == "SITE_18"), "5") # open diamond
  site_code <- replace(site_code,which(site_code == "TEXACO"), "6") # open downward triangle
  site_code <- replace(site_code,which(site_code == "Golden_Aster_Scrub"), "3") # plus
  site_code <- replace(site_code,which(site_code == "Brigman"), "4") # cross
  site_code <- replace(site_code,which(site_code == "Duette_headwaters"), "8") # asterisk
  site_code <- replace(site_code,which(site_code == "Sun_City"), "35") # pound
  site_code <- replace(site_code,which(site_code == "W.Balm"), "38") # ampersand
  site_code <- replace(site_code,which(site_code == "missing"), "36") # dollar
  return(as.numeric(site_code))
}

pointletters <- function(df = NULL) {
  site_code <- replace(as.character(df$site),which(df$site == "Wellfield"), "W")
  site_code <- replace(site_code, which(site_code == "SITE_1"), "1")
  site_code <- replace(site_code,which(site_code == "SITE_13"), "3")
  site_code <- replace(site_code,which(site_code == "SITE_12"), "2")
  site_code <- replace(site_code,which(site_code == "SITE_18"), "8")
  site_code <- replace(site_code,which(site_code == "TEXACO"), "X")
  site_code <- replace(site_code,which(site_code == "Golden_Aster_Scrub"), "G")
  site_code <- replace(site_code,which(site_code == "Brigman"), "B")
  site_code <- replace(site_code,which(site_code == "Duette_headwaters"), "D")
  site_code <- replace(site_code,which(site_code == "Sun_City"), "S")
  site_code <- replace(site_code,which(site_code == "W.Balm"), "A")
  #site_code <- replace(site_code,which(site_code == "missing"), "M")
  site_code <- replace(site_code,which(site_code == "missing"), "U") # unbanded birds have missing locations
  return(site_code)
}

popletters <- function(df = NULL) {
  pop_code <- replace(as.character(df$pop),which(df$pop == "Resident"), "R")
  pop_code <- replace(pop_code,which(pop_code == "Contemporary"), "C")
  pop_code <- replace(pop_code, which(pop_code == "SITE_1"), "1")
  pop_code <- replace(pop_code,which(pop_code == "SITE_13"), "3")
  pop_code <- replace(pop_code,which(pop_code == "SITE_12"), "2")
  pop_code <- replace(pop_code,which(pop_code == "SITE_18"), "8")
  pop_code <- replace(pop_code,which(pop_code == "TEXACO"), "X")
  pop_code <- replace(pop_code,which(pop_code == "Golden_Aster_Scrub"), "G")
  pop_code <- replace(pop_code,which(pop_code == "Brigman"), "B")
  pop_code <- replace(pop_code,which(pop_code == "Duette_headwaters"), "D")
  pop_code <- replace(pop_code,which(pop_code == "Sun_City"), "S")
  pop_code <- replace(pop_code,which(pop_code == "W.Balm"), "A")
  return(pop_code)
}

popnames <- function(df = NULL) {
  pop_names <- replace(as.character(df$pop),which(df$pop == "Resident"), "Resident")
  pop_names <- replace(pop_names,which(pop_names == "Contemporary"), "Contemporary")
  pop_names <- replace(pop_names, which(pop_names == "SITE_1"), "Site 1")
  pop_names <- replace(pop_names,which(pop_names == "SITE_13"), "Site 13")
  pop_names <- replace(pop_names,which(pop_names == "SITE_12"), "Site 12")
  pop_names <- replace(pop_names,which(pop_names == "SITE_18"), "Site 18")
  pop_names <- replace(pop_names,which(pop_names == "TEXACO"), "Texaco")
  pop_names <- replace(pop_names,which(pop_names == "Golden_Aster_Scrub"), "Golden Aster Scrub")
  pop_names <- replace(pop_names,which(pop_names == "Brigman"), "Brigman")
  pop_names <- replace(pop_names,which(pop_names == "Duette_headwaters"), "Duette headwaters")
  pop_names <- replace(pop_names,which(pop_names == "Sun_City"), "Sun City")
  pop_names <- replace(pop_names,which(pop_names == "W.Balm"), "W. Balm")
  return(pop_names)
}


pntcol <- function(x = NULL) {
  if (length(grep("scales",(.packages()))) == 0) library(scales)
  color = NULL
  if (class(x) == "data.frame") {
    color = as.character(x$type)
  } else if (class(x) == "character") {
    color = x
  } else {
    stop("Invalid input type")
  }
  #color <- replace(color,which(color == "C"),"red")
  color <- replace(color,which(color == "C"),"violet")
  #color <- replace(color,which(color == "E"),"lightseagreen")
  color <- replace(color,which(color == "E"),"slateblue4")
  #color <- replace(color,which(color == "I"),"gold4")
  color <- replace(color,which(color == "I"),"tomato")
  #color <- replace(color,which(color == "M4"),"purple")
  color <- replace(color,which(color == "M4"),"royalblue1")	
  #color <- replace(color,which(color == "T"),"navy")
  color <- replace(color,which(color == "T"),"seagreen")
  return(color)
}

sitecol <- function(x = NULL) {
  #if (length(grep("scales",(.packages()))) == 0) library(scales)
  type.loc = paste0(x$type,"_",x$site)
  color = type.loc
  color <- replace(color, which(color == "C_Wellfield"), "violet")
  color <- replace(color, which(color == "E_Wellfield"), "slateblue4")
  color <- replace(color, which(color == "T_SITE_1"), "limegreen")
  #color <- replace(color, which(color == "T_SITE_13"), "yellow2")
  color <- replace(color, which(color == "T_SITE_13"), "gold2")
  #color <- replace(color, which(color == "T_SITE_12"), "magenta3")
  color <- replace(color, which(color == "T_SITE_12"), "maroon4")
  color <- replace(color, which(color == "T_SITE_18"), "dodgerblue1")
  color <- replace(color, which(color == "T_TEXACO"), "darkslategrey")
  color <- replace(color, which(color == "I_missing" | color == "U_missing"), "tomato")
  color <- replace(color, which(color == "M4_Duette_headwaters"), "black")
  color <- replace(color, which(color == "M4_Brigman"), "sienna")
  color <- replace(color, which(color == "M4_Golden_Aster_Scrub"), "olivedrab")
  color <- replace(color, which(color == "M4_W.Balm"), "red3")
  color <- replace(color, which(color == "M4_Sun_City"), "purple1")
}

popcolor <- function(x = NULL) {
  #if (length(grep("scales",(.packages()))) == 0) library(scales)
  color = x$pop
  color <- replace(color, which(color == "Contemporary"), "violet")
  color <- replace(color, which(color == "Resident"), "slateblue4")
  color <- replace(color, which(color == "SITE_1"), "limegreen")
  color <- replace(color, which(color == "SITE_13"), "gold2")
  color <- replace(color, which(color == "SITE_12"), "maroon4")
  color <- replace(color, which(color == "SITE_18"), "dodgerblue1")
  color <- replace(color, which(color == "TEXACO"), "darkslategrey")
  color <- replace(color, which(color == "Duette_headwaters"), "tomato")
  color <- replace(color, which(color == "Brigman"), "sienna")
  color <- replace(color, which(color == "Golden_Aster_Scrub"), "olivedrab")
  color <- replace(color, which(color == "W.Balm"), "red3")
  color <- replace(color, which(color == "Sun_City"), "purple1")
}

biopoint <- function(x = NULL) {
	ptcode = replace(x,which(x == "Contemporary" | x == "Resident"),"21")
	ptcode = replace(ptcode,which(ptcode == "SITE_1" | ptcode == "SITE_12" | ptcode == "SITE_13" | ptcode == "SITE_18" | ptcode == "TEXACO"), "24")
	ptcode = replace(ptcode,which(ptcode == "Golden_Aster_Scrub" | ptcode == "Brigman" | ptcode == "W.Balm" | ptcode == "Duette_headwaters" | ptcode == "Sun_City"), "22")
	return(as.numeric(ptcode))
}

h_boxplot2 <- function(x=NULL, n=NULL, lev=grplevels, ylabel="Heterozygosity", pntlab=NULL, seed=10287, color=NULL, ylimits=NULL, idlabels=NULL) {
	if (length(grep("TeachingDemos",(.packages()))) == 0) library(TeachingDemos) # for shadowtext()
	nlevel = length(lev)

	par(mar=c(5,5,2,2))
	boxplot(x[,n] ~ group, data=x, outline=FALSE, names=c(rep("",nlevel)), xlab="", ylab=ylabel, main="", col="gray80", cex.axis=1.5, cex.lab=1.5, lwd=2, ylim=ylimits)
	mtext(c(lev[1:3],paste("Other","M4",sep="\n")), 1,at=1:nlevel, padj=1, cex=1.5)

	# add points
	for (i in lev) {
		idx = which(as.character(x$group) == i)
		set.seed(seed)
		xjitter = jitter(rep(which(lev == i),length(idx)), amount=0.2)
		ptcol = NULL
		for (j in 1:length(idx)) {
			if (is.null(color)) ptcol = alpha("maroon",0.5) else ptcol = alpha(color[idx[j]],0.5)
			if (is.null(pntlab) || is.na(pntlab[idx[j]])) {
				if (!is.null(idlabels)) {
				  text(y=x[idx[j],n], x=xjitter[j],idlabels[idx[j]],cex=0.5,col="red")
				} else {
				  points(y=x[idx[j],n], x=xjitter[j], pch=1, cex=1.2)
				  points(y=x[idx[j],n], x=xjitter[j], pch=16, cex=1.2, col=ptcol)
				}
			} else if (class(pntlab) == "numeric") {
				points(y=x[idx[j],n], x=xjitter[j], pch=pntlab[idx[j]], col="black", bg=alpha(color[idx[j]],0.65),lwd=1.3,cex=1.5)
			}  else if (class(pntlab) == "character") {
				shadowtext(y=x[idx[j],n], x=xjitter[j], labels=pntlab[idx[j]], col=color[idx[j]], bg=alpha("black",0.5), r=0.07, cex=1.2)	
			} else stop("Unknown argument to pntlab")
		}
	}

}


## ---------- RAW FASTQ QUALITY CONTROL ---------- ##

## Assess quality of raw fastq files

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/fastq/raw_data/qc/fastqc_array.sh
implements:

--- start bash code ---

EXEC='fastqc'
ADAPTERFILE='/mnt/research/Fitz_Lab/projects/mosaic/raw_data/qc/novogene_adapter_file.txt'
FQLIST='/mnt/research/Fitz_Lab/projects/mosaic/raw_data/raw_fastq_list.txt'
FQFILE=$(sed -n "${SLURM_ARRAY_TASK_ID}p" "$FQLIST")
OUTDIR='/mnt/research/Fitz_Lab/projects/mosaic/raw_data/qc'

CMD="$EXEC -o $OUTDIR -f fastq -a $ADAPTERFILE $FQFILE"

printf "\n%s\n\n" "$CMD"

eval $CMD

--- end bash code ---

## Perfrom quality control of raw reads

# Collate each samples reads that were produced across multiple lanes

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/fastq/process_reads/cat_runs/cat_fastq_array.sh
implements:

--- start bash code ---

EXEC='/mnt/research/Fitz_Lab/projects/mosaic/processed_reads/cat_runs/catFastq.sh'
DIRLIST='/mnt/research/Fitz_Lab/projects/mosaic/processed_reads/cat_runs/fastq_dirs.txt'
FQDIR=$(sed -n "${SLURM_ARRAY_TASK_ID}p" "$DIRLIST")

CMD="$EXEC $FQDIR /mnt/gs18/scratch/users/lindero1/mosaic/cat_reads"

printf "\n%s\n\n" "$CMD"

eval $CMD

--- end bash code ---


# Remove duplicate reads

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/fastq/process_reads/deduplicate/deduplicate_reads_array.sh
implements:

--- start bash code ---

EXEC='hts_SuperDeduper'
FQLIST='/mnt/research/Fitz_Lab/projects/mosaic/processed_reads/deduplicate/fastq_prefixes.txt'
FQPREFIX=$(sed -n "${SLURM_ARRAY_TASK_ID}p" "$FQLIST")
FQFWD="${FQPREFIX}_1.fq.gz"
FQREV="${FQPREFIX}_2.fq.gz"
LIBPREFIX=$(echo $FQPREFIX | perl -e '$line = <>; print $1 if $line =~ /([^\/]+)$/')
OUTPREFIX="/mnt/gs18/scratch/users/lindero1/mosaic/deduplicated_reads/${LIBPREFIX}"
LOGFILE="/mnt/research/Fitz_Lab/projects/mosaic/processed_reads/deduplicate/logs/${LIBPREFIX}_stats.log"

CMD="$EXEC -L $LOGFILE -1 $FQFWD -2 $FQREV -f $OUTPREFIX -s 12 -l 10 -q 30 -a 5"

printf "\n%s\n\n" "$CMD"

eval $CMD

--- end bash code ---


# Trim adapters and remove excessively short reads after trimming

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/fastq/process_reads/adapter_trim/rmv_adapters_array.sh
implements:

--- start bash code ---

EXEC='cutadapt'
FQLIST='/mnt/research/Fitz_Lab/projects/mosaic/mosiac_samples.txt'
FQDIR='/mnt/gs18/scratch/users/lindero1/mosaic/deduplicated_reads'
FQPREFIX=$(sed -n "${SLURM_ARRAY_TASK_ID}p" "$FQLIST")
FQFWD="${FQDIR}/${FQPREFIX}_R1.fastq.gz"
FQREV="${FQDIR}/${FQPREFIX}_R2.fastq.gz"
OUTDIR="/mnt/gs18/scratch/users/lindero1/mosaic/adapter_trim"
OUTFWD="${OUTDIR}/${FQPREFIX}_R1.fastq.gz"
OUTREV="${OUTDIR}/${FQPREFIX}_R2.fastq.gz"

CMD="$EXEC -a AGATCGGAAGAGCACACGTCTGAACTCCAGTCA -A AGATCGGAAGAGCGTCGTGTAGGGAAAGAGTGT --overlap 3 --trim-n --minimum-length 70 -o $OUTFWD -p $OUTREV $FQFWD $FQREV"

printf "\n%s\n\n" "$CMD"

eval $CMD

--- end bash code ---


# Merge overlapping read pairs

$ /mnt/research/Fitz_Lab/projects/mosaic/fastq/process_reads/merge/merge_reads_array.sh
implements:

--- start bash code ---

EXEC='pear'
FQLIST='/mnt/research/Fitz_Lab/projects/mosaic/mosiac_samples.txt'
FQDIR='/mnt/gs18/scratch/users/lindero1/mosaic/adapter_trim'
FQPREFIX=$(sed -n "${SLURM_ARRAY_TASK_ID}p" "$FQLIST")
FQFWD="${FQDIR}/${FQPREFIX}_R1.fastq.gz"
FQREV="${FQDIR}/${FQPREFIX}_R2.fastq.gz"
OUTPREFIX="/mnt/gs18/scratch/users/lindero1/mosaic/merged_reads/${FQPREFIX}"

CMD="$EXEC -f $FQFWD -r $FQREV -o $OUTPREFIX -p 0.001 -v 10 -m 299 -n 70 -g 1 -s 2 -k"

printf "\n%s\n\n" "$CMD"

eval $CMD

--- end bash code ---

## Evaulate the effectiveness of quality control by comparing quality metrics of raw fastqs (after merging reads from multiple lanes for a sample)
## to those of cleaned fastqs

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/fastq/process_reads/clean_eval/eval_array.sh
implements:

--- start bash code ---

EXEC='/mnt/research/Fitz_Lab/projects/mosaic/fastq/process_reads/clean_eval/evalLibs.pl'
FQLIST='/mnt/research/Fitz_Lab/projects/mosaic/mosiac_samples.txt'
CLEAN_FQDIR='/mnt/research/Fitz_Lab/projects/mosaic/fastq/clean_reads'
RAW_FQDIR='/mnt/gs18/scratch/users/lindero1/mosaic/cat_reads'
FQPREFIX=$(sed -n "${SLURM_ARRAY_TASK_ID}p" "$FQLIST")
RAW_FQFWD="${RAW_FQDIR}/${FQPREFIX}_1.fq.gz"
RAW_FQREV="${RAW_FQDIR}/${FQPREFIX}_2.fq.gz"
CLEAN_FQFWD="${CLEAN_FQDIR}/${FQPREFIX}_R1.fastq.gz"
CLEAN_FQREV="${CLEAN_FQDIR}/${FQPREFIX}_R2.fastq.gz"
OUTFILE="/mnt/research/Fitz_Lab/projects/mosaic/fastq/process_reads/clean_eval/clean/${FQPREFIX}_eval.txt"

CMD="$EXEC --raw $RAW_FQFWD $RAW_FQREV --clean $CLEAN_FQFWD $CLEAN_FQREV --library $FQPREFIX > $OUTFILE"

printf "\n%s\n\n" "$CMD"

eval $CMD

--- end bash code ---

## Split reads for individuals back into respective lanes so that lane information for read groups can be tracked when mapping

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/fastq/process_reads/split_reads_array.sh
implements:

--- start bash code ---

EXEC='/mnt/research/Fitz_Lab/projects/mosaic/fastq/process_reads/splitFastqLanes.pl'
FQLIST='/mnt/research/Fitz_Lab/projects/mosaic/mosiac_samples.txt'
FQDIR='/mnt/research/Fitz_Lab/projects/mosaic/fastq/clean_reads'
OUTDIR='/mnt/gs18/scratch/users/lindero1/mosaic/split_reads'
FQPREFIX=$(sed -n "${SLURM_ARRAY_TASK_ID}p" "$FQLIST")

CMD="$EXEC $FQPREFIX $FQDIR $OUTDIR"
printf "\n%s\n" "$CMD"
eval $CMD

--- end bash code ---

## ---------- MAP READS TO REFERENCE GENOME ---------- ##

## Map clean reads to the FSJ V3 reference genome

This step also marks residual duplicate reads.

$ /mnt/research/Fitz_Lab/projects/mosaic/map/map_reads_array.sh
implements:

--- start bash code ---

EXEC='/mnt/research/Fitz_Lab/projects/mosaic/map/map_reads.sh'
REF='/mnt/research/Fitz_Lab/ref/bird/FSJ_V3/FSJ.V3.fa'
FQLIST='/mnt/research/Fitz_Lab/projects/mosaic/mosiac_ids.txt'
FQDIR='/mnt/gs18/scratch/users/lindero1/mosaic/split_reads'
OUTDIR='/mnt/gs18/scratch/users/lindero1/mosaic/map'
SAMPID=$(sed -n "${SLURM_ARRAY_TASK_ID}p" "$FQLIST")
NTHREAD=9

CMD="$EXEC $REF $SAMPID $FQDIR $OUTDIR $NTHREAD"
printf "\n%s\n" "$CMD"
eval $CMD

--- end bash code ---

# Trim residual overlapping portions of read pairs using mapping information (retain data from highest quality read)

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/map/clip_overlaps_array.sh
implements:

--- start bash code ---

EXEC='bam clipOverlap'
FQLIST='/mnt/research/Fitz_Lab/projects/mosaic/mosiac_ids.txt'
SAMPID=$(sed -n "${SLURM_ARRAY_TASK_ID}p" "$FQLIST")
INBAM="/mnt/gs18/scratch/users/lindero1/mosaic/map/${SAMPID}_untrimmed.bam"
OUTBAM="/mnt/research/Fitz_Lab/projects/mosaic/map/bam/${SAMPID}.bam"

CMD="$EXEC --in $INBAM --out $OUTBAM --stats --excludeFlags 0x20C --params --poolSize 1000000000 --noPhoneHome"
printf "\n%s\n" "$CMD"
eval $CMD

CMD2="samtools index $OUTBAM"
printf "\n%s\n" "$CMD2"
eval $CMD2

--- end bash code ---

## ---------- EVALUATE COVERAGE ---------- ##

# Calculate coverage statistics for each individual for the entire genome

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/map/coverage/coverage_array.sh

--- start bash code ---

EXEC='samtools coverage'
FQLIST='/mnt/research/Fitz_Lab/projects/mosaic/mosiac_ids.txt'
SAMPID=$(sed -n "${SLURM_ARRAY_TASK_ID}p" "$FQLIST")
BAM="/mnt/research/Fitz_Lab/projects/mosaic/map/bam/${SAMPID}.bam"
OUTFILE="/mnt/research/Fitz_Lab/projects/mosaic/map/coverage/${SAMPID}_coverage.txt"

CMD="$EXEC --ff UNMAP,SECONDARY,QCFAIL,DUP -d 0 $BAM > $OUTFILE"
printf "\n%s\n" "$CMD"
eval $CMD

--- end bash code ---

# Calculate the average autosomal depth for each indivdiual

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/map/main_chr_depth/depth_array.sh
implements:

--- start bash code ---

FQLIST='/mnt/research/Fitz_Lab/projects/mosaic/mosiac_ids.txt'
SAMPID=$(sed -n "${SLURM_ARRAY_TASK_ID}p" "$FQLIST")
BAM="/mnt/research/Fitz_Lab/projects/mosaic/map/bam/${SAMPID}.bam"
OUTFILE="/mnt/research/Fitz_Lab/projects/mosaic/map/main_chr_depth/${SAMPID}_depth.txt"
BED='/mnt/research/Fitz_Lab/ref/bird/FSJ_V3/FSJ_V3_main_chr.bed'

CMD="samtools depth -b $BED $BAM | cut -f3 | perl -ne '(\$sum, \$n) = (0,1); \$sum+=\$_; while(<>){\$sum+=\$_; \$n++};\$avg = sprintf(\"%.3f\", \$sum/\$n); print \"NSITES\tAVG_DEPTH\n\$n\t\$avg\n\"' > $OUTFILE"
printf "\n%s\n" "$CMD"
eval $CMD

--- end bash code ---

# Calculate Z chromosome to autosome depth ratio for each individual with zchr_depth_ratio.R in order 
# to assign sex to unsexed individuals.

zchr_depth_ratio.R implements

--- start R code ---

homolog_file = '/mnt/research/Fitz_Lab/ref/bird/FSJ_V3/FSJV3_convert.short.txt'
homolog = read.table(homolog_file,head=TRUE)
autosome = homolog$FSJV3_SCAFFOLD[which(homolog$ZEBRA_FINCH_CHR != "Z")]
zchr = homolog$FSJV3_SCAFFOLD[which(homolog$ZEBRA_FINCH_CHR == "Z")]

samples = read.table('/mnt/research/Fitz_Lab/projects/mosaic/mosiac_ids.txt',head=FALSE)

df = NULL
for (i in 1:nrow(samples)) {
        id = samples$V1[i]
        coverage = read.table(paste0('/mnt/research/Fitz_Lab/projects/mosaic/map/coverage/',id,'_coverage.txt'),head=FALSE)
        autoset = coverage[which(coverage$V1 %in% autosome),]
        zset = coverage[which(coverage$V1 %in% zchr),]
        len_total = sum(autoset$V3)
        autocov = sum(autoset$V7 * autoset$V3/len_total) # chromosome length weighted average
        zcov = zcov = zset$V7
        dratio = zcov/autocov # ratio of Z chr coverage to autosome coverage
        df = rbind(df, data.frame(SAMPLE = id, AUTOSOME_DEPTH = autocov, Z_DEPTH = zcov, DEPTH_RATIO = dratio))
}

# assign sex based on coverage ratio

df$NGS_SEX = NA
df$NGS_SEX[which(df$DEPTH_RATIO < 0.6)] = "Female"
df$NGS_SEX[which(is.na(df$NGS_SEX) == TRUE)] = "Male"

# write output
# write.table(df,file='/mnt/research/Fitz_Lab/projects/mosaic/map/coverage/ngs_sex_assignment.txt',col.names=TRUE,row.names=FALSE,sep="\t",quote=FALSE)

--- end R code ---

## ---------- GENETIC VARIANT CALLING ---------- ##

## Identify genetic variants and produce an all-sites VCF (accounts for sex of individual)

$ /mnt/research/Fitz_Lab/projects/mosaic/variants/call/call_variants_array.sh
implements:

--- start bash code ---

REF='/mnt/research/Fitz_Lab/ref/bird/FSJ_V3/FSJ.V3.fa'
BAMS='/mnt/research/Fitz_Lab/projects/mosaic/map/mosaic_bam_list.txt'
SCAFFLIST="/mnt/research/Fitz_Lab/projects/mosaic/variants/call/scaffold_sets/regions_${SLURM_ARRAY_TASK_ID}.rf"
PLOIDY_FILE='/mnt/research/Fitz_Lab/projects/mosaic/variants/call/mosaic_ploidy.txt'
SAMP_FILE='/mnt/research/Fitz_Lab/projects/mosaic/variants/call/mosaic_sample_sex.txt'
OUTBCF="/mnt/gs18/scratch/users/lindero1/mosaic/vcf/call/fsj_mosaic_${SLURM_ARRAY_TASK_ID}.bcf.gz"

CMD="bcftools mpileup \
-f $REF \
-b $BAMS \
-R $SCAFFLIST \
-C 0 \
-d 10000 \
-L 10000 \
-q 20 \
-Q 13 \
--ns UNMAP,SECONDARY,QCFAIL,DUP \
-a FORMAT/AD,FORMAT/DP,FORMAT/QS,FORMAT/SP,FORMAT/SCR,INFO/AD,INFO/SCR \
-p \
-O u \
| bcftools call \
--ploidy-file $PLOIDY_FILE \
-S $SAMP_FILE \
-a PV4,GQ,GP \
-m \
-P 0.003 \
-O u \
| bcftools +fill-tags \
-O b \
-o $OUTBCF \
-- -t 'AF,ExcHet,NS'"

printf "\n%s\n\n" "$CMD"

eval $CMD

wait

tabix -p bcf $OUTBCF

--- end bash code ---

# normalize variants

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/variants/norm/norm_variants_array.sh
implements:

--- start bash code ---

REF='/mnt/research/Fitz_Lab/ref/bird/FSJ_V3/FSJ.V3.fa'
INBCF="/mnt/gs18/scratch/users/lindero1/mosaic/vcf/call/fsj_mosaic_${SLURM_ARRAY_TASK_ID}.bcf.gz"
OUTBCF="/mnt/gs18/scratch/users/lindero1/mosaic/vcf/norm/fsj_mosaic_norm_${SLURM_ARRAY_TASK_ID}.bcf.gz"

CMD="bcftools norm -f $REF -O b -o $OUTBCF $INBCF"

printf "\n%s\n\n" "$CMD"

eval $CMD

wait

tabix -p bcf $OUTBCF

--- end bash code ---

## Annotate VCF including populating the FILTER and INFO fields with quality-related annotations

# Generate accessability masks

Merge BAMs in order to calculate mapping and sequencing quality information across all individuals

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/variants/masks/merge_bams.sh
implements:

--- start bash code ---

REF='/mnt/research/Fitz_Lab/ref/bird/FSJ_V3/FSJ.V3.fa'
BAMS='/mnt/research/Fitz_Lab/projects/mosaic/map/mosaic_bam_list.txt'
OUTFILE='/mnt/gs18/scratch/users/lindero1/mosaic/mask/mosaic_fsj_all.bam'

CMD="samtools merge -O BAM --reference $REF -b $BAMS -o $OUTFILE -@ 20"

printf "\n%s\n\n" "$CMD"

eval $CMD

wait

samtools index -@ 20 "$OUTFILE"

--- end bash code ---

Calculate mapping and sequencing quality information

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/variants/masks/bamstats_array.sh
implements:

--- start bash code ---

EXEC='/mnt/research/Fitz_Lab/projects/mosaic/variants/masks/bamstats'
SCAFLIST='/mnt/research/Fitz_Lab/ref/bird/FSJ_V3/FSJ_V3_scaffolds.txt'
SCAF=$(sed -n "${SLURM_ARRAY_TASK_ID}p" "$SCAFLIST")
REF='/mnt/research/Fitz_Lab/ref/bird/FSJ_V3/FSJ.V3.fa'
BAM='/mnt/gs18/scratch/users/lindero1/mosaic/mask/mosaic_fsj_all.bam'
OUTFILE="/mnt/research/Fitz_Lab/projects/mosaic/variants/masks/bam_stats/fsj_mosaic_allind_${SCAF}.bamstats"

CMD="$EXEC -A -d 8700000 -f $REF -q 0 -Q 0 -r $SCAF --ff UNMAP,SECONDARY,QCFAIL,DUP -s -aa $BAM > $OUTFILE"

printf "\n%s\n\n" "$CMD"

eval $CMD

--- end bash code ---

Summarize BAM statistics

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/variants/masks/bamstats_main_summary_array.sh
implements:

--- start bash code ---

EXEC='/mnt/research/Fitz_Lab/projects/mosaic/variants/masks/qualSummaryStats.R'
STATLIST="/mnt/gs18/scratch/users/lindero1/mosaic/mask/fsj_v3_autosome_bamstat_${SLURM_ARRAY_TASK_ID}.list"
if [ $SLURM_ARRAY_TASK_ID -eq 4 ]; then STATLIST='/mnt/gs18/scratch/users/lindero1/mosaic/mask/fsj_v3_z_bamstat.list'; fi
OUTFILE="/mnt/gs18/scratch/users/lindero1/mosaic/mask/bam_stats/fsj_mosaic_allind_bamstat_summary_${SLURM_ARRAY_TASK_ID}.txt"

CMD="$EXEC $STATLIST $OUTFILE 3 4 5 6 7 8 9"

printf "\n%s\n\n" "$CMD"

eval $CMD

--- end bash code ---


Make accessability mask bed files based on BAM statistics

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/variants/masks/bed_mask_array.sh
implements:

--- start bash code ---

EXEC='/mnt/research/Fitz_Lab/projects/mosaic/variants/masks/bedmask.pl'
SCAFLIST='/mnt/research/Fitz_Lab/ref/bird/FSJ_V3/FSJ_V3_scaffolds.txt'
SCAF=$(sed -n "${SLURM_ARRAY_TASK_ID}p" "$SCAFLIST")
BAMSTATS="/mnt/research/Fitz_Lab/projects/mosaic/variants/masks/bam_stats/fsj_mosaic_allind_${SCAF}.bamstats"
OUTPREFIX="/mnt/research/Fitz_Lab/projects/mosaic/variants/masks/bed/fsj_mosaic_mask_${SCAF}"

CMD="$EXEC --mindepth 523 --maxdepth 741 --minmq 35 --maxmq0 0.1 --minbq 20 --maxbq0 0.003 $BAMSTATS $OUTPREFIX"

if [ "$SCAF" = 'Chromosome24' ]
then
        CMD="$EXEC --mindepth 386 --maxdepth 681 --minmq 35 --maxmq0 0.1 --minbq 20 --maxbq0 0.003 $BAMSTATS $OUTPREFIX"
fi

printf "\n%s\n\n" "$CMD"

eval $CMD

--- end bash code ---


Calculate quality information based on VCF. This will be quality based on reads that were actually used for genotype calling, i.e. 
that passed minimum base and mapping quality cutoffs when calling variants with bcftools.

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/variants/masks/vcfstats_array.sh
implements:

--- start bash code ---

BCF="/mnt/gs18/scratch/users/lindero1/mosaic/vcf/norm/fsj_mosaic_norm_${SLURM_ARRAY_TASK_ID}.bcf.gz"
OUTFILE="/mnt/gs18/scratch/users/lindero1/mosaic/mask/vcf_stats/fsj_mosaic_${SLURM_ARRAY_TASK_ID}.vcfstats"

CMD="(printf '%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\n' 'CHR' 'POS' 'DP' 'NS' 'QUAL' 'MQ' 'RPBZ' 'MQBZ' 'BQBZ' 'FS' 'ExcHet' 'PV4_STRAND' 'PV4_BASEQ' 'PV4_MAPQ' 'PV4_POS' && bcftools query -f '%CHROM\t%POS\t%INFO/DP\t%INFO/NS\t%QUAL\t%MQ\t%INFO/RPBZ\t%INFO/MQBZ\t%INFO/BQBZ\t%INFO/FS\t%INFO/ExcHet\t%INFO/PV4{0}\t%INFO/PV4{1}\t%INFO/PV4{2}\t%INFO/PV4{3}\n' $BCF) > $OUTFILE"

printf "\n%s\n\n" "$CMD"

eval $CMD

--- end bash code ---


Summarize VCF quality information

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/variants/masks/vcfstats_main_summary_array.sh
implements:

--- start bash code ---

EXEC='/mnt/research/Fitz_Lab/projects/mosaic/variants/masks/qualSummaryStats.R'
CHRLIST='/mnt/research/Fitz_Lab/ref/bird/FSJ_V3/FSJ_V3_main_autosomes.txt'
CHR=$(sed -n "${SLURM_ARRAY_TASK_ID}p" "$CHRLIST")
STATLIST="/mnt/research/Fitz_Lab/projects/mosaic/variants/masks/tmp/fsj_mosaic_vcfstats_${SLURM_ARRAY_TASK_ID}.list"
echo "/mnt/research/Fitz_Lab/projects/mosaic/variants/masks/vcf_stats/fsj_mosaic_${CHR}.vcfstats" > "$STATLIST"
OUTFILE="/mnt/research/Fitz_Lab/projects/mosaic/variants/masks/vcf_stats/fsj_mosaic_allind_vcfstats_summary_${CHR}.txt"

CMD="$EXEC $STATLIST $OUTFILE 3 4 5 6 7 8 9 10 11 12 13 14 15"

printf "\n%s\n\n" "$CMD"

eval $CMD

--- end bash code ---

Annotate all-sites VCF using BAM stats accessability mask and VCF quality cutoffs

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/variants/masks/annotate_array.sh
implements:

--- start bash code ---

EXEC='/mnt/research/Fitz_Lab/projects/mosaic/variants/masks/insertAnnotations.pl'
BCF="/mnt/gs18/scratch/users/lindero1/mosaic/vcf/norm/fsj_mosaic_norm_${SLURM_ARRAY_TASK_ID}.bcf.gz"
BEDFILE='/mnt/research/Fitz_Lab/projects/mosaic/variants/masks/bed/fsj_mosaic_mask_genome_fail.bed'
GRPFILE='/mnt/research/Fitz_Lab/projects/mosaic/variants/masks/fsj_mosaic_group_file.txt'
OUTFILE="/mnt/gs18/scratch/users/lindero1/mosaic/vcf/annotate/fsj_mosaic_annotated_${SLURM_ARRAY_TASK_ID}.vcf.gz"

CMD="bcftools view --no-version $BCF | $EXEC --dpbounds 474,790 --hetbound 0.06 --bed $BEDFILE --overwrite --genorep $GRPFILE | bgzip > $OUTFILE"

if [ "$SLURM_ARRAY_TASK_ID" = 7 ]
then
        CMD="bcftools view --no-version $BCF | $EXEC --dpbounds 336,560 --hetbound 0.06 --bed $BEDFILE --overwrite --genorep $GRPFILE | bgzip > $OUTFILE"
fi

printf "\n%s\n\n" "$CMD"
eval $CMD
wait
tabix -p vcf $OUTFILE

--- end bash code ---


Concatenate annotated VCFs to produce a single, final, release-ready, all-sites VCF

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/variants/masks/merge_vcfs.sh
implements:

--- start bash code ---

VCFLIST='/mnt/gs18/scratch/users/lindero1/mosaic/vcf/annotate/fsj_mosaic_vcf.list'
OUTFILE='/mnt/research/Fitz_Lab/projects/mosaic/variants/vcf/all_sites/fsj_mosaic_allsites_genome.vcf.gz'

CMD="bcftools concat -f $VCFLIST -O z -o $OUTFILE --threads 20"

printf "\n%s\n\n" "$CMD"

eval $CMD
wait
tabix -p vcf "$OUTFILE"

--- end bash code ---

Produce accompanying position file for the entire genome of sites that pass missing data and quality cutoffs

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/variants/scripts/extract_allsites_qc_pos.sh
implements:

--- start bash code ---

VCF='/mnt/research/Fitz_Lab/projects/mosaic/variants/vcf/all_sites/fsj_mosaic_allsites_genome.vcf.gz'
OUTPOS='/mnt/research/Fitz_Lab/projects/mosaic/variants/vcf/all_sites/fsj_mosaic_allsites_genome_qc.pos'

bcftools view -H -f "PASS" -i 'N_PASS(GT[0-27]!="mis" & FMT/DP > 2) > 24 && N_PASS(GT[28-38]!="mis" & FMT/DP > 2) > 9 && N_PASS(GT[39-44]!="mis" & FMT/DP > 2) > 4 && N_PASS(GT[45-57]!="mis" & FMT/DP > 2) > 11 && N_PASS(GT[58-86]!="mis" & FMT/DP > 2) > 25' "$VCF" | perl -ne  '@tok = split(/\s+/,$_); if ($tok[7] =~ /REPGQ=(\d+),(\d+),(\d+),(\d+),(\d+)/) {print "$tok[0]\t$tok[1]\n" if ($1 > 24 && $2 > 9 && $3 > 4 && $4 > 11 && $5 > 25);} else {print "$tok[0]\t$tok[1]\n";}' | uniq > "$OUTPOS"

--- end bash code ---

Produce accompanying position file for scaffolds that are homologous to zebra finch autosomes (refered to as "main autosomes") and 
which pass missing data and quality cutoffs

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/variants/scripts/extract_allsites_main_autosome_qc_pos.sh
implements:

--- start bash code ---

VCF='/mnt/research/Fitz_Lab/projects/mosaic/variants/vcf/all_sites/fsj_mosaic_allsites_genome.vcf.gz'
OUTPOS='/mnt/research/Fitz_Lab/projects/mosaic/variants/vcf/all_sites/fsj_mosaic_allsites_main_autosomes_qc.pos'
REGFILE='/mnt/research/Fitz_Lab/ref/bird/FSJ_V3/fsj_v3_main_autosomes.rf'

bcftools view -H -R "$REGFILE" -f "PASS" -i 'N_PASS(GT[0-27]!="mis" & FMT/DP > 2) > 24 && N_PASS(GT[28-38]!="mis" & FMT/DP > 2) > 9 && N_PASS(GT[39-44]!="mis" & FMT/DP > 2) > 4 && N_PASS(GT[45-57]!="mis" & FMT/DP > 2) > 11 && N_PASS(GT[58-86]!="mis" & FMT/DP > 2) > 25' "$VCF" | perl -ne  '@tok = split(/\s+/,$_); if ($tok[7] =~ /REPGQ=(\d+),(\d+),(\d+),(\d+),(\d+)/) {print "$tok[0]\t$tok[1]\n" if ($1 > 24 && $2 > 9 && $3 > 4 && $4 > 11 && $5 > 25);} else {print "$tok[0]\t$tok[1]\n";}' | uniq > "$OUTPOS"

--- end bash code ---

## Produce a sites-only allsites VCF (no individual genotype information)

$ bcftools view -G -O z /mnt/research/Fitz_Lab/projects/mosaic/variants/vcf/all_sites/fsj_mosaic_allsites_genome.vcf.gz > /mnt/research/Fitz_Lab/projects/mosaic/variants/vcf/all_sites/fsj_mosaic_allsites_genome_sitesonly.vcf.gz

## Extract all-variants VCF subset

Extract variable sites from all-sites VCF

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/variants/scripts/extract_variants.sh
implements:

--- start bash code ---

EXEC='/mnt/research/Fitz_Lab/projects/mosaic/variants/scripts/extractVariants.pl'
VCF='/mnt/research/Fitz_Lab/projects/mosaic/variants/vcf/all_sites/fsj_mosaic_allsites_genome.vcf.gz'
OUTVCF='/mnt/research/Fitz_Lab/projects/mosaic/variants/vcf/all_variants/fsj_mosaic_variants_genome.vcf.gz'

$EXEC $VCF | bgzip > $OUTVCF

tabix -p vcf $OUTVCF

--- end bash code ---

## Extract biallelic SNP VCF subset

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/variants/scripts/extract_snps.sh
implements:

--- start bash code ---

EXEC='/mnt/research/Fitz_Lab/projects/mosaic/variants/vcf/scripts/extractBiallelicSnps.pl'
VCF='/mnt/research/Fitz_Lab/projects/mosaic/variants/vcf/all_sites/fsj_mosaic_allsites_genome.vcf.gz'
OUTVCF='/mnt/research/Fitz_Lab/projects/mosaic/variants/vcf/biallelic_snps/fsj_mosaic_biallelic_snps_genome.vcf.gz'

$EXEC --minmaf 0 $VCF | bgzip > $OUTVCF

tabix -p vcf $OUTVCF

--- end bash code ---

Produce accompanying position file of genome-wide biallelic SNPs that pass missing data and quality cutoffs

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/variants/scripts/extract_snps_qc_pos.sh
implements:

--- start bash code ---

VCF='/mnt/research/Fitz_Lab/projects/mosaic/variants/vcf/biallelic_snps/fsj_mosaic_biallelic_snps_genome.vcf.gz'
OUTPOS='/mnt/research/Fitz_Lab/projects/mosaic/variants/vcf/biallelic_snps/fsj_mosaic_biallelic_snps_genome_qc.pos'

bcftools view -H -f "PASS" -i 'N_PASS(GT[0-27]!="mis" & FMT/DP > 2) > 24 && N_PASS(GT[28-38]!="mis" & FMT/DP > 2) > 9 && N_PASS(GT[39-44]!="mis" & FMT/DP > 2) > 4 && N_PASS(GT[45-57]!="mis" & FMT/DP > 2) > 11 && N_PASS(GT[58-86]!="mis" & FMT/DP > 2) > 25' "$VCF" | perl -ne  '@tok = split(/\s+/,$_); if ($tok[7] =~ /REPGQ=(\d+),(\d+),(\d+),(\d+),(\d+)/) {print "$tok[0]\t$tok[1]\n" if ($1 > 24 && $2 > 9 && $3 > 4 && $4 > 11 && $5 > 25);} else {print "$tok[0]\t$tok[1]\n";}' | uniq > "$OUTPOS"

--- end bash code ---

Producing accompanying position file of biallelic SNPs on main autosomes that pass missing data and quality cutoffs

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/variants/scripts/extract_snps_main_autosome_qc_pos.sh
implements:

--- start bash code ---

VCF='/mnt/research/Fitz_Lab/projects/mosaic/variants/vcf/biallelic_snps/fsj_mosaic_biallelic_snps_genome.vcf.gz'
OUTPOS='/mnt/research/Fitz_Lab/projects/mosaic/variants/vcf/biallelic_snps/fsj_mosaic_biallelic_snps_main_autosomes_qc.pos'
REGFILE='/mnt/research/Fitz_Lab/ref/bird/FSJ_V3/fsj_v3_main_autosomes.rf'

bcftools view -H -R "$REGFILE" -f "PASS" -i 'N_PASS(GT[0-27]!="mis" & FMT/DP > 2) > 24 && N_PASS(GT[28-38]!="mis" & FMT/DP > 2) > 9 && N_PASS(GT[39-44]!="mis" & FMT/DP > 2) > 4 && N_PASS(GT[45-57]!="mis" & FMT/DP > 2) > 11 && N_PASS(GT[58-86]!="mis" & FMT/DP > 2) > 25' "$VCF" | perl -ne  '@tok = split(/\s+/,$_); if ($tok[7] =~ /REPGQ=(\d+),(\d+),(\d+),(\d+),(\d+)/) {print "$tok[0]\t$tok[1]\n" if ($1 > 24 && $2 > 9 && $3 > 4 && $4 > 11 && $5 > 25);} else {print "$tok[0]\t$tok[1]\n";}' | uniq > "$OUTPOS"

--- end bash code ---

Extract VCF subset of quality-controlled biallelic SNPs on main autosomes

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/variants/scripts/extract_qc_snps.sh
implements

--- start bash code ---

VCF='/mnt/research/Fitz_Lab/projects/mosaic/variants/vcf/biallelic_snps/fsj_mosaic_biallelic_snps_genome.vcf.gz'
POSFILE='/mnt/research/Fitz_Lab/projects/mosaic/variants/vcf/biallelic_snps/fsj_mosaic_biallelic_snps_main_autosomes_qc.pos'
OUTVCF='/mnt/research/Fitz_Lab/projects/mosaic/variants/vcf/biallelic_snps/fsj_mosaic_biallelic_snps_main_autosomes_qc.vcf.gz'

CMD="bcftools view -T $POSFILE -O z -o $OUTVCF $VCF"

printf "\n%s\n\n" "$CMD"

eval $CMD

tabix -p vcf $OUTVCF

--- end bash code ---


## ---------- RELATEDNESS ESTIMATED FROM GENOMIC DATA ---------- ##

Estimate relatedness among all sequenced individuals.

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/popgen/relatedness/relatedness_qc_snps.sh
implements:

--- start bash code ---

VCF='/mnt/research/Fitz_Lab/projects/mosaic/variants/vcf/biallelic_snps/fsj_mosaic_biallelic_snps_main_autosomes_qc.vcf.gz'
OUTFILE='fsj_mosaic_biallelic_snps_main_autosomes_qc_relatedness.txt'

CMD="ngsRelate -h $VCF -O $OUTFILE -p 20 -l 0.02 -T PL -A AF"

printf "\n%s\n\n" "$CMD"

eval $CMD

--- end bash code ---

Format ngsRelate output into a two dimensional r matrix.

--- start R code ---

df <- read.table('/home/tyler/Dropbox/research/jay/mosaic/popgen/relatedness/fsj_mosaic_biallelic_snps_main_autosomes_qc_relatedness.txt',head=TRUE)
meta <- read.table('/home/tyler/Dropbox/research/jay/mosaic/metadata/M4_sequenced_FSJsamples_metadata.txt',head=TRUE,sep="\t")
meta$pop.names <- popnames(meta)

# convert pairwise comparisons into a matrix
n = 87
rmat <- matrix(ncol=n, nrow=n)

for (i in 1:n) {
	iidx = i-1
	for (j in 1:n) {
		jidx = j-1
		if (i == j) {
			rmat[i,j] = NA
		} else if (!is.na(rmat[j,i])) {
			rmat[i,j] = rmat[j,i]
			#if (j < i) rmat[i,j] = NA # this makes half matrix
		} else {
			rmat[i,j] = df$rab[which(df$a == iidx & df$b == jidx)]
		}
	}
}

# output matrix
#write.table(rmat,file='/home/tyler/Dropbox/research/jay/mosaic/popgen/relatedness/#fsj_mosaic_biallelic_snps_main_autosomes_qc_relatedness_matrix.nonames.txt',col.names=FALSE,row.names=FALSE,quote=FALSE,sep="\t

colnames(rmat) <- paste0(meta$LAB_ID,":",gsub(" ", "_", meta$pop.names))
rownames(rmat) <- paste0(meta$LAB_ID,":",gsub(" ", "_", meta$pop.names))
#write.table(rmat,file='/home/tyler/Dropbox/research/jay/mosaic/popgen/relatedness/fsj_mosaic_biallelic_snps_main_autosomes_qc_relatedness_matrix.txt',col.names=TRUE,row.names=TRUE,quote=FALSE,sep="\t")

--- end R code ----

## Relatedness distribution summaries

--- start R code ----

dat <- read.table('/home/tyler/Dropbox/research/jay/mosaic/popgen/relatedness/fsj_mosaic_biallelic_snps_main_autosomes_qc_relatedness_ranked_usfws_pretty2.txt',head=FALSE)
# Each column in fsj_mosaic_biallelic_snps_main_autosomes_qc_relatedness_ranked_usfws_pretty2.txt is a focal individual, row 1 is focal individual information in the format
# <Fitz LAB ID>,<USFWS ID>,<population ID>, while rows 2..87 are other individuals in format <Fitz LAB ID>,<USFWS ID>,<population ID>,<relatedness to focal individual>.

# average pairwise relatedness between translocated individuals and Residents
r.rt = NULL # stores the pairwise relatedness between Residents and translocated individuals
transpop <- c("SITE_1", "SITE_12", "SITE_13", "SITE_18", "TEXACO")
for (i in 1:ncol(dat)) {
	tok = strsplit(dat[1,i],",")[[1]]
	if (tok[3] != "Resident") next
	for (j in 2:nrow(dat)) {
		tok = strsplit(dat[j,i],",")[[1]]
		if (tok[3] %in% transpop || tok[1] == "I_049") r.rt <- c(r.rt, as.numeric(tok[4]))
	}
}

quantile(r.rt, 0.95)
#      95% 
#0.0243058 # 95th quantile for pairwise relatedness between resident and donor site individuals

--- end R code ---

Extract relatedness submatrices for different groups or populations.

--- start R code ---

rmat <- as.matrix(read.table('/mnt/research/Fitz_Lab/projects/mosaic/popgen/relatedness/fsj_mosaic_biallelic_snps_main_autosomes_qc_relatedness_matrix.txt',head=TRUE,row.names=1))
colnames(rmat) <- gsub('\\..+$', '', colnames(rmat), perl=TRUE) # remove location info
meta <- read.table('/mnt/research/Fitz_Lab/projects/mosaic/M4_sequenced_FSJsamples_metadata.txt',head=TRUE,sep="\t")

# collect IDs of individuals in each group
c.id <- meta$LAB_ID[which(meta$pop == "Contemporary")]
r.id <- meta$LAB_ID[which(meta$pop == "Resident")]
s13.id <- meta$LAB_ID[which(meta$pop == "SITE_13")]
histmeta.id <- meta$LAB_ID[which(meta$year_sampled < 2021)]

# note: exclude RSW-K from CR founders in case I use them as a reference pop for the Contemporary CR individuals at some point
crfounders.id <- meta$LAB_ID[which((meta$pop == "Resident" | meta$pop == "SITE_1" | meta$pop == "SITE_12" | meta$pop == "SITE_13" | meta$pop == "SITE_18" | meta$pop == "TEXACO") & meta$LAB_ID != "T_072")]

# note: include RSW-K from the donor site group because they are relevant for estimating the allele frequencies in this metapopulation subset
donor.id <- meta$LAB_ID[which(meta$pop == "SITE_1" | meta$pop == "SITE_12" | meta$pop == "SITE_13" | meta$pop == "SITE_18" | meta$pop == "TEXACO")]

# commenting out translocated subset below because all donor site individuals are a better way to estimate allele frequencies for the translocated group 
#trans.id <': trans.id <- meta$LAB_ID[which((meta$pop == "SITE_1" | meta$pop == "SITE_12" | meta$pop == "SITE_13" | meta$pop == "SITE_18" | meta$pop == "TEXACO") & meta$LAB_ID != "T_072")]

# extract relatedness matrix subsets
c.rmat <- rmat[which(colnames(rmat) %in% c.id == TRUE), which(colnames(rmat) %in% c.id == TRUE)]
r.rmat <- rmat[which(colnames(rmat) %in% r.id == TRUE), which(colnames(rmat) %in% r.id == TRUE)]
s13.rmat <- rmat[which(colnames(rmat) %in% s13.id == TRUE), which(colnames(rmat) %in% s13.id == TRUE)]
histmeta.rmat <- rmat[which(colnames(rmat) %in% histmeta.id == TRUE), which(colnames(rmat) %in% histmeta.id == TRUE)]
crfounders.rmat <- rmat[which(colnames(rmat) %in% crfounders.id == TRUE), which(colnames(rmat) %in% crfounders.id == TRUE)]
donor.rmat <- rmat[which(colnames(rmat) %in% donor.id == TRUE), which(colnames(rmat) %in% donor.id == TRUE)]

# output relatedness matrices subsets
#write.table(c.rmat, file='/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/contemporary_cr_relatedness_matrix.txt', col.names=TRUE, row.names=FALSE, quote=FALSE, sep="\t")
#write.table(r.rmat, file='/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/resident_cr_relatedness_matrix.txt', col.names=TRUE, row.names=FALSE, quote=FALSE, sep="\t")
#write.table(s13.rmat, file='/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/site13_relatedness_matrix.txt', col.names=TRUE, row.names=FALSE, quote=FALSE, sep="\t")
#write.table(histmeta.rmat, file='/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/historic_metapop_relatedness_matrix.txt', col.names=TRUE, row.names=FALSE, quote=FALSE, sep="\t")
#write.table(crfounders.rmat, file='/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/cr_founders_relatedness_matrix.txt', col.names=TRUE, row.names=FALSE, quote=FALSE, sep="\t")
#write.table(donor.rmat, file='/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/donor_pops_relatedness_matrix.txt', col.names=TRUE, row.names=FALSE, quote=FALSE, sep="\t")

# output the original relatedness matrix of all samples, entirely unchanged except for removing the row names and simplifying the IDs (remove population labels)
#write.table(rmat, file='/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/fsj_mosaic_biallelic_snps_main_autosomes_qc_relatedness_matrix_fmt.txt', col.names=TRUE, row.names=FALSE, quote=FALSE, sep="\t")

--- end R code ---

Take random subsets of individuals such that the max pairwise r within each group is <= 0.4

--- start bash code ---

$ /mnt/research/Fitz_Lab/projects/mosaic/popgen/relatedness/scripts/subsetUnrelated.R contemporary_cr_relatedness_matrix.txt 0.4 836241 > contemporary_cr_relatedness_maxr0.4_ids.txt
$ /mnt/research/Fitz_Lab/projects/mosaic/popgen/relatedness/scripts/subsetUnrelated.R resident_cr_relatedness_matrix.txt 0.4 836241 > resident_cr_relatedness_maxr0.4_ids.txt
$ /mnt/research/Fitz_Lab/projects/mosaic/popgen/relatedness/scripts/subsetUnrelated.R site13_relatedness_matrix.txt 0.4 836241 > site13_relatedness_maxr0.4_ids.txt
$ /mnt/research/Fitz_Lab/projects/mosaic/popgen/relatedness/scripts/subsetUnrelated.R historic_metapop_relatedness_matrix.txt 0.4 836241 > historic_metapop_relatedness_maxr0.4_ids.txt
$ /mnt/research/Fitz_Lab/projects/mosaic/popgen/relatedness/scripts/subsetUnrelated.R cr_founders_relatedness_matrix.txt 0.4 836241 > cr_founders_relatedness_maxr0.4_ids.txt
$ /mnt/research/Fitz_Lab/projects/mosaic/popgen/relatedness/scripts/subsetUnrelated.R donor_pops_relatedness_matrix.txt 0.4 836241 > donor_pops_relatedness_maxr0.4_ids.txt
$ /mnt/research/Fitz_Lab/projects/mosaic/popgen/relatedness/scripts/subsetUnrelated.R fsj_mosaic_biallelic_snps_main_autosomes_qc_relatedness_matrix_fmt.txt 0.4 836241 > fsj_mosaic_biallelic_snps_main_autosomes_qc_relatedness_maxr0.4_ids.txt

--- end bash code ---

## Take random subsets of individuals so that all within-group pairwise relatedness is <= 0.01
## Consider these subsets of unrelated individuals.

--- begin R code ---

sample_unrelated <- function(pop, relate.matrix, maxr=0.01, niter=100) {

        grp.idx <- grep(pop,colnames(relate.matrix))
        urelate = NULL

        for (i in 1:niter) {
                submat = relate.matrix[grp.idx,grp.idx]
                while (max(submat,na.rm=TRUE) > maxr) {
                        id = colnames(submat)
                        ind.pairs <- combn(id, m=2)
                        idx.perm <- sample(1:ncol(ind.pairs),size=ncol(ind.pairs))
                        reset = 0
                        for (i in idx.perm) {
                                ind.vec = ind.pairs[,i]
                                a.idx = which(id == ind.vec[1])
                                b.idx = which(id == ind.vec[2])
                                r = relate.matrix[a.idx, b.idx]
                                if (r > maxr) {
                                        a.relatives = length(which(submat[a.idx,] > maxr))
                                        b.relatives = length(which(submat[b.idx,] > maxr))
                                        discard.idx = ifelse(a.relatives > b.relatives, a.idx, b.idx)
                                        submat <- submat[-discard.idx, -discard.idx]
                                        reset = 1
                                        break
                                }
                                if (reset == 1) break
                        }
                }
                if (is.null(urelate) == TRUE || ncol(submat) > ncol(urelate)) urelate = submat
        }

        return(colnames(urelate))
}

rmat <- as.matrix(read.table('/home/tyler/Dropbox/research/jay/mosaic/popgen/relatedness/fsj_mosaic_biallelic_snps_main_autosomes_qc_relatedness_matrix.txt',head=TRUE,row.names=1))
rmat <- rmat[-which(colnames(rmat) == "T_072.Site_1"),-which(colnames(rmat) == "T_072.Site_1")] # exclude RSW-K because this individual was not translocated

set.seed(324986)
contemp.unrelated <- sample_unrelated(pop="Contemporary", relate.matrix=rmat, maxr=0.01, niter=1000) # unrelated contemporary CR subset
res.unrelated <- sample_unrelated(pop="Resident", relate.matrix=rmat, maxr=0.01, niter=1000) # unrelated resident CR subset
trans.unrelated <- sample_unrelated(pop="Site|Texaco", relate.matrix=rmat, maxr=0.01, niter=1000) # unrelated translocated subset

contemp.unrelated.df  <- data.frame(ID=gsub("\\.Contemporary","",contemp.unrelated))
res.unrelated.df  <- data.frame(ID=gsub("\\.Resident","",res.unrelated))
trans.unrelated.df <- data.frame(ID=gsub("\\.Site.+|\\.Texaco","",trans.unrelated))

# write subset lists of individuals for which all r <= 0.01
#write.table(contemp.unrelated.df, file='/home/tyler/Dropbox/research/jay/mosaic/popgen/unrelated_subsample/contemporary_unrelated_samples.txt',col.names=FALSE,row.names=FALSE,quote=FALSE)
#write.table(res.unrelated.df, file='/home/tyler/Dropbox/research/jay/mosaic/popgen/unrelated_subsample/resident_unrelated_samples.txt',col.names=FALSE,row.names=FALSE,quote=FALSE)
#write.table(trans.unrelated.df, file='/home/tyler/Dropbox/research/jay/mosaic/popgen/unrelated_subsample/translocated_unrelated_samples.txt',col.names=FALSE,row.names=FALSE,quote=FALSE)

--- end R code ---

Unrelated (r <= 0.01) sample sizes:
contemporary CR, n = 6
resident CR, n = 6
translocated, n = 8

## ---------- SITE FREQUENCY SPECTRUM ---------- ##

# Folded SFS calculated from all sites (best SFS estimate, used for estimating genetic diversity)

Estimate per site allele frequency likelihoods for all quality controlled sites

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/popgen/sfs/main_autosome_grp_sfs_array2.sh
implements:

--- start bash code ---

GRP_ARR=('resident' 'C' 'T' 'M4')
FSJGRP="${GRP_ARR[$SLURM_ARRAY_TASK_ID]}"
BAMLIST="/mnt/research/Fitz_Lab/projects/mosaic/map/mosaic_${FSJGRP}_bam_list.txt"
OUTPREFIX="/mnt/research/Fitz_Lab/projects/mosaic/popgen/sfs/fsj_mosaic_allsites_main_autosomes_qc_${FSJGRP}"
REGFILE='/mnt/research/Fitz_Lab/ref/bird/FSJ_V3/FSJ_V3_main_autosomes.txt'
SITESFILE='/mnt/research/Fitz_Lab/projects/mosaic/variants/vcf/all_sites/fsj_mosaic_allsites_main_autosomes_qc.pos'
REF='/mnt/research/Fitz_Lab/ref/bird/FSJ_V3/FSJ.V3.fa'

CMD="angsd -bam $BAMLIST -out $OUTPREFIX -GL 1 -doSaf 1 -anc $REF -minQ 20 -minMapQ 20 -rf $REGFILE -sites $SITESFILE -P 4"

printf "\n%s\n\n" "$CMD"

eval $CMD

--- end bash code ---

Estimate folded SFS

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/popgen/sfs/main_autosome_grp_realsfs_fold_array2.sh
implements:

--- start bash code ---

GRP_ARR=('resident' 'C' 'T' 'M4')
FSJGRP="${GRP_ARR[$SLURM_ARRAY_TASK_ID]}"
SAFIDX="/mnt/research/Fitz_Lab/projects/mosaic/popgen/sfs/fsj_mosaic_allsites_main_autosomes_qc_${FSJGRP}.saf.idx"
OUTSFS="/mnt/research/Fitz_Lab/projects/mosaic/popgen/sfs/fsj_mosaic_allsites_main_autosomes_qc_${FSJGRP}.fold.sfs"

CMD="realSFS $SAFIDX -fold 1 -P 20 > $OUTSFS"

printf "\n%s\n\n" "$CMD"

eval $CMD

--- end bash code ---

# Folded SFS calculated using all sites for subsets of individuals for which all pairwise relatedness is <= 0.01

Estimate allele frequency likelihoods for subset of unrelated individuals at all quality-controlled sites

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/popgen/sfs/main_autosome_unrelated_grp_array.sh
implements:

--- start bash code ---

GRP_ARR=('contemporary' 'resident' 'translocated')
FSJGRP="${GRP_ARR[$SLURM_ARRAY_TASK_ID]}"
BAMLIST="/mnt/research/Fitz_Lab/projects/mosaic/map/unrelated/${FSJGRP}_unrelated_bam_list.txt"
OUTPREFIX="/mnt/research/Fitz_Lab/projects/mosaic/popgen/sfs/fsj_mosaic_allsites_main_autosomes_qc_${FSJGRP}_unrelated"
FFILE="/mnt/research/Fitz_Lab/projects/mosaic/popgen/fstats/unrelated/${FSJGRP}_unrelated_samples_F.txt"
REGFILE='/mnt/research/Fitz_Lab/ref/bird/FSJ_V3/FSJ_V3_main_autosomes.txt'
SITESFILE='/mnt/research/Fitz_Lab/projects/mosaic/variants/vcf/all_sites/fsj_mosaic_allsites_main_autosomes_qc.pos'
REF='/mnt/research/Fitz_Lab/ref/bird/FSJ_V3/FSJ.V3.fa'

CMD="angsd -bam $BAMLIST -out $OUTPREFIX -GL 1 -doSaf 2 -indF $FFILE -anc $REF -doMaf 1 -doMajorMinor 1 -minQ 20 -minMapQ 20 -rf $REGFILE -sites $SITESFILE -P 4"

printf "\n%s\n\n" "$CMD"

eval $CMD

--- end bash code ---

Note: GitHub version of /mnt/research/Fitz_Lab/projects/mosaic/popgen/sfs/main_autosome_unrelated_grp_array.sh 
is called main_autosome_unrelated_grp_sfs_array.sh.

Estimate the SFS for subsets of unrelated individuals based on all quality-controlled sites

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/popgen/sfs/main_autosome_unrelated_grp_realsfs_fold_array.sh

--- start bash code ---

GRP_ARR=('contemporary' 'resident' 'translocated')
FSJGRP="${GRP_ARR[$SLURM_ARRAY_TASK_ID]}"
SAFIDX="/mnt/research/Fitz_Lab/projects/mosaic/popgen/sfs/fsj_mosaic_allsites_main_autosomes_qc_${FSJGRP}_unrelated.saf.idx"
OUTSFS="/mnt/research/Fitz_Lab/projects/mosaic/popgen/sfs/fsj_mosaic_allsites_main_autosomes_qc_${FSJGRP}_unrelated.fold.sfs"

CMD="realSFS $SAFIDX -fold 1 -P 16 > $OUTSFS"

printf "\n%s\n\n" "$CMD"

eval $CMD

--- end bash code ---

# R functions for visualizing SFS

--- start R code ---

# plot SFS
plotsfs <- function(x = NULL, outfile = NULL, grp = NULL, fold = 0) {
        if (!is.null(outfile)) pdf(file=outfile) else x11()
        par(mfrow=c(2,2))
        for (i in 1:length(x)) {
                if (fold == 0) {
                        barplot(x[[i]][-c(1,length(x[[i]]))], main = grp[i], ylab="Number sites", xlab="Derived AF", names.arg=1:(length(x[[i]])-2))
                } else if (fold == 1) {
                        barplot(x[[i]][-1], main = grp[i], ylab="Number sites", xlab="MAF", names.arg=1:(length(x[[i]])-1))
                } else {
                        stop("fold argument must be 0 or 1")
                }
                if (is.null(outfile) && i %% 4 == 0) {
                        x11()
                        par(mfrow=c(2,2))
                }
        }
        if (!is.null(outfile)) invisible(dev.off())
}

neutral.sfs <- function(n) {
	# makes expected neutral SFS
        # n: diploid sample size
        sfs.vec <- rep(NA,n)
        for (i in 1:((2*n)-1)) {
                sfs.vec[i] = 1/i
        }
        sfs.vec <- sfs.vec/sum(sfs.vec)
        return(sfs.vec)
}

foldsfs <- function(x) {
	# folds the SFS
        n = length(x)+1
        fold.sfs <- NULL
        for (i in 1:(n/2-1)) {
                fold.sfs <- c(fold.sfs, x[i]+x[n-i])
        }
        fold.sfs <- c(fold.sfs, x[n/2])

        return(fold.sfs)
}

# Examples for reading in SFS data for use the with function above

# define groups and sample sizes
sfsdir='./sfs/'
jaygrp = c('C','E','T','M4','I','all')
dipn = c(28, 11, 29, 13, 6, 87)
sfs.fold <- list()
sfs.ufold <- list()
bisnp.fold <- list()
bisnp.ufold <- list()

# read in SFS data
for (i in 1:length(jaygrp)) {
        grp <- jaygrp[i]
        n <- dipn[i]
        sfs.fold[[i]] <- scan(paste0(sfsdir,"fsj_mosaic_allsites_main_autosomes_qc_",grp,".fold.sfs"))
        sfs.fold[[i]] <- sfs.fold[[i]][1:(n+1)]
        sfs.ufold[[i]] <- scan(paste0(sfsdir,"fsj_mosaic_allsites_main_autosomes_qc_",grp,".unfold.sfs"))
        bisnp.fold[[i]] <- scan(paste0(sfsdir,"fsj_mosaic_biallelic_snps_main_autosomes_qc_",grp,".fold.sfs"))
        bisnp.fold[[i]] <- bisnp.fold[[i]][1:(n+1)]
        bisnp.ufold[[i]] <- scan(paste0(sfsdir,"fsj_mosaic_biallelic_snps_main_autosomes_qc_",grp,".unfold.sfs"))
}

# plot each group (includes Contemporary CR population, 'C', plot)
plotsfs(x=sfs.fold, outfile='fsj_mosaic_allsites_main_autosomes_qc_fold.pdf', grp=jaygrp, fold=1)
plotsfs(x=sfs.ufold, outfile='fsj_mosaic_allsites_main_autosomes_qc_unfold.pdf', grp=jaygrp, fold=0)
plotsfs(x=bisnp.fold, outfile='fsj_mosaic_biallelic_snps_main_autosomes_qc_fold.pdf', grp=jaygrp, fold=1)
plotsfs(x=bisnp.ufold, outfile='fsj_mosaic_biallelic_snps_main_autosomes_qc_ufold.pdf', grp=jaygrp, fold=0)

# Resident CR plot
res <- scan('./sfs/fsj_mosaic_allsites_main_autosomes_qc_resident.fold.sfs')
res.fold <- res[2:((length(res)-1)/2)]

# expected resident SFS
res.exp <- neutral.sfs(n=16)
res.exp.fold <- foldsfs(res.exp)
res.exp.fold.counts <- sum(res.fold) * res.exp.fold

barplot(res.exp.fold.counts, xlab="Minor allele frequency", names.arg = 1:length(res.exp.fold.counts), ylab="Number sites",cex.lab=1.3, cex.axis=1.3)

--- end R code ---

## ---------- FST ---------- ##

FST were calculated using variable sites only

# Estimate unfolded joint SFS to serve as joint allele frequency prior for SNPs

Estimate allele frequency likelihoods for quality-controlled SNPs
Note: the 'translocated' group for FST estimation includes RSW-K (T_072, no translocated) and so really represents the pooled donor sites

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/popgen/sfs/main_autosome_snps_grp_sfs_array2.sh
implements:

--- start bash code ---

GRP_ARR=('resident' 'translocated' 'C')
FSJGRP="${GRP_ARR[$SLURM_ARRAY_TASK_ID]}"
BAMLIST="/mnt/research/Fitz_Lab/projects/mosaic/map/mosaic_${FSJGRP}_bam_list.txt"
OUTPREFIX="/mnt/research/Fitz_Lab/projects/mosaic/popgen/sfs/fsj_mosaic_biallelic_snps_main_autosomes_qc_${FSJGRP}"
REGFILE='/mnt/research/Fitz_Lab/ref/bird/FSJ_V3/FSJ_V3_main_autosomes.txt'
SITESFILE='/mnt/research/Fitz_Lab/projects/mosaic/variants/vcf/biallelic_snps/fsj_mosaic_biallelic_snps_main_autosomes_qc.pos'
REF='/mnt/research/Fitz_Lab/ref/bird/FSJ_V3/FSJ.V3.fa'

CMD="angsd -bam $BAMLIST -out $OUTPREFIX -GL 1 -doSaf 1 -anc $REF -minQ 20 -minMapQ 20 -rf $REGFILE -sites $SITESFILE -P 4"

printf "\n%s\n\n" "$CMD"

eval $CMD

--- end bash code ---


Estimate unfolded 2D-SFS

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/popgen/sfs/main_autosome_snps_2dsfs_array2.sh
implements:

--- start bash code ---

CMP=('resident:C' 'resident:translocated' 'translocated:C')
POP1=$(echo "${CMP[$SLURM_ARRAY_TASK_ID]}" | cut -f1 -d':')
POP2=$(echo "${CMP[$SLURM_ARRAY_TASK_ID]}" | cut -f2 -d':')
SAFIDX1="/mnt/research/Fitz_Lab/projects/mosaic/popgen/sfs/fsj_mosaic_biallelic_snps_main_autosomes_qc_${POP1}.saf.idx"
SAFIDX2="/mnt/research/Fitz_Lab/projects/mosaic/popgen/sfs/fsj_mosaic_biallelic_snps_main_autosomes_qc_${POP2}.saf.idx"
OUTSFS="/mnt/research/Fitz_Lab/projects/mosaic/popgen/sfs/fsj_mosaic_biallelic_snps_main_autosomes_qc_${POP1}_vs_${POP2}.unfold.2dsfs"

CMD="realSFS $SAFIDX1 $SAFIDX2 -P 20 > $OUTSFS"

printf "\n%s\n\n" "$CMD"

eval $CMD

--- end bash code ---

# Estimate pairwise FST for {resident CR vs contemporary CR} and {resident vs pooled donor sites}

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/popgen/fstats/main_autosome_snps_2dsfs_array2.sh
implements:

--- start bash code ---

CMP=('resident:C' 'resident:translocated' 'translocated:C')
POP1=$(echo "${CMP[$SLURM_ARRAY_TASK_ID]}" | cut -f1 -d':')
POP2=$(echo "${CMP[$SLURM_ARRAY_TASK_ID]}" | cut -f2 -d':')
SAFIDX1="/mnt/research/Fitz_Lab/projects/mosaic/popgen/sfs/fsj_mosaic_biallelic_snps_main_autosomes_qc_${POP1}.saf.idx"
SAFIDX2="/mnt/research/Fitz_Lab/projects/mosaic/popgen/sfs/fsj_mosaic_biallelic_snps_main_autosomes_qc_${POP2}.saf.idx"
SFSPRIOR="/mnt/research/Fitz_Lab/projects/mosaic/popgen/sfs/fsj_mosaic_biallelic_snps_main_autosomes_qc_${POP1}_vs_${POP2}.unfold.2dsfs"
OUTFILE="/mnt/research/Fitz_Lab/projects/mosaic/popgen/fstats/fsj_mosaic_biallelic_snps_main_autosomes_qc_${POP1}_vs_${POP2}"

CMD="realSFS fst index $SAFIDX1 $SAFIDX2 -sfs $SFSPRIOR -fstout $OUTFILE"

printf "\n%s\n\n" "$CMD"

eval $CMD

--- end bash code ---

## ---------- GENETIC DIVERSITY ---------- ##

## Heterozygosity

Estimate heterozygosity from each individual's site frequency spectrum.

# Estimate allele frequency (0, 1, or 2 minor alleles) likelihoods at each site

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/popgen/theta/heterozygosity/heterozygosity_array.sh
implements:

--- start bash code ---

BAMLIST='/mnt/research/Fitz_Lab/projects/mosaic/map/mosaic_bam_list.txt'
BAMFILE=$(sed -n "${SLURM_ARRAY_TASK_ID}p" "$BAMLIST")
SAMPLIST='/mnt/research/Fitz_Lab/projects/mosaic/mosiac_ids.txt'
SAMP=$(sed -n "${SLURM_ARRAY_TASK_ID}p" "$SAMPLIST")
REF='/mnt/research/Fitz_Lab/ref/bird/FSJ_V3/FSJ.V3.fa'
REGFILE='/mnt/research/Fitz_Lab/ref/bird/FSJ_V3/FSJ_V3_main_autosomes.txt'
SITESFILE='/mnt/research/Fitz_Lab/projects/mosaic/variants/vcf/all_sites/fsj_mosaic_allsites_main_autosomes_qc.pos'
OUTPREFIX="/mnt/research/Fitz_Lab/projects/mosaic/popgen/theta/heterozygosity/fsj_mosaic_allsites_main_autosomes_qc_${SAMP}"

SAFCMD="angsd -i $BAMFILE -out $OUTPREFIX -GL 1 -doSaf 1 -anc $REF -minQ 20 -minMapQ 20 -rf $REGFILE -sites $SITESFILE"

printf "\n%s\n\n" "$SAFCMD"

eval $SAFCMD

--- end bash code ---

# Estimate SFS for individuals

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/popgen/theta/heterozygosity/heterozygosity_realsfs_array.sh
implements:

--- start bash code ---

SAMPLIST='/mnt/research/Fitz_Lab/projects/mosaic/mosiac_ids.txt'
SAMP=$(sed -n "${SLURM_ARRAY_TASK_ID}p" "$SAMPLIST")
SAFIDX="/mnt/research/Fitz_Lab/projects/mosaic/popgen/theta/heterozygosity/fsj_mosaic_allsites_main_autosomes_qc_${SAMP}.saf.idx"
SFS="/mnt/research/Fitz_Lab/projects/mosaic/popgen/theta/heterozygosity/fsj_mosaic_allsites_main_autosomes_qc_${SAMP}.fold.sfs"

CMD="realSFS $SAFIDX -fold 1 -P 12 > $SFS"

printf "\n%s\n\n" "$CMD"

eval $CMD

--- end bash code ---

Collect SFS for all samples into a single file

--- begin bash code ---

$ for i in {1..87}; do SAMP=$(sed -n "${i}p" /mnt/research/Fitz_Lab/projects/mosaic/mosiac_ids.txt); sfs=$((printf "%s " "$SAMP" && head -n1 fsj_mosaic_allsites_main_autosomes_qc_${SAMP}.fold.sfs) | tr ' ' \\t | cut -f1-3); echo "$sfs" >> fsj_mosaic_allsites_main_autosomes_qc_all.fold.sfs; done

--- end bash code ---

# Calculate H from individual SFS and visualize H distrubutions with boxplots

--- start R code ---

library(scales) # for alpha

# read in metapop data
meta <- read.table('/home/tyler/Dropbox/research/jay/mosaic/metadata/M4_sequenced_FSJsamples_metadata.txt',head=TRUE,sep="\t")
meta$popletter <- popletters(meta)
meta$popcol <- popcolor(meta)

groups <- meta$pop
grplevels <- c("Contemporary", "Resident", "Translocated", "M4")

groups <- replace(groups, which(groups == "Golden_Aster_Scrub" | groups == "Brigman" | groups == "W.Balm" | 
groups == "Duette_headwaters" | groups == "Sun_City"), "M4")

groups <- replace(groups, which(groups == "SITE_1" | groups == "SITE_12" | groups == "SITE_13" | 
groups == "SITE_18" | groups == "TEXACO"), "Translocated")

allsites <- read.table('/home/tyler/Dropbox/research/jay/mosaic/popgen/theta/fsj_mosaic_allsites_main_autosomes_qc_all.fold.sfs',head=FALSE) # H all sites

## calculate H
allsites$H <- sapply(1:nrow(allsites), function(x,df){df[x,3]/sum(df[x,2:3])},df=allsites)
allsites$group = factor(groups,levels=grplevels)

# omit T_072 (RSW-K) from plots and statistical tests because this site 1 bird was not translocated and migrated to LMSP, which is outside of the Core
allsites <- allsites[-which(allsites$V1 == "T_072"),]
meta <- meta[-which(meta$LAB_ID == "T_072"),]

## H boxplots

# set point type
pointcode <- meta$popletter
pointcode <- replace(pointcode, which(pointcode == "C" | pointcode == "R"),NA)
allsites$biopoint = biopoint(meta$pop)
snps$biopoint = biopoint(meta$pop)

#png(file='/home/tyler/Dropbox/research/jay/mosaic/figures/H_distribution.png',width=7, height=7,units='in', res=300)
h_boxplot2(x=allsites, n=4, lev=grplevels, ylabel="Heterozygosity per site", pntlab=allsites$biopoint, seed=10287, color=meta$popcol, ylimits=NULL)
dev.off()

#png(file='/home/tyler/Dropbox/research/jay/mosaic/figures/H_distribution_text.png',width=7, height=7,units='in', res=300)
h_boxplot2(x=allsites, n=4, lev=grplevels, ylabel="Heterozygosity per site", pntlab=NULL, seed=10287, color=meta$popcol, ylimits=NULL, idlabels=allsites$V1)
dev.off()

## write H results
allsites$pop <- meta$pop
colnames(allsites) <- c("SAMPLE", "N_HOMO_SITES", "N_HET_SITES", "H", "CLASS", "POPULATION")
#write.table(allsites,file='/home/tyler/Dropbox/research/jay/mosaic/popgen/theta/fsj_mosaic_allsites_main_autosomes_qc_all.fold.sfs.het2',col.names=TRUE,row.names=FALSE,quote=FALSE,sep="\t")

## summarize heterozygosity and test for differences between groups with first degree relatives excluded, specifically no pairwise r > 0.4

contemp.unrelate <- read.table('/home/tyler/Dropbox/research/jay/mosaic/popgen/roh/inputs/contemporary_cr_relatedness_maxr0.4_ids.txt', head=FALSE)$V1 # this is all contemporary individuals because all pairwise relatedness was < 0.4
res.unrelate <- read.table('/home/tyler/Dropbox/research/jay/mosaic/popgen/roh/inputs/resident_cr_relatedness_maxr0.4_ids.txt', head=FALSE)$V1
donor.unrelate <- read.table('/home/tyler/Dropbox/research/jay/mosaic/popgen/roh/inputs/donor_pops_relatedness_maxr0.4_ids.txt', head=FALSE)$V1
histmeta.unrelate <- read.table('/home/tyler/Dropbox/research/jay/mosaic/popgen/roh/inputs/historic_metapop_relatedness_maxr0.4_ids.txt', head=FALSE)$V1

# Group H summary stats (individuals comprising groups are subsets such that all pairwise r <= 0.4).

# Contemporary (all pairwise r <= 0.4)
mean(allsites$H[which(allsites$CLASS == "Contemporary" & allsites$SAMPLE %in% contemp.unrelate == TRUE)])
#[1] 0.0002010206
sd(allsites$H[which(allsites$CLASS == "Contemporary" & allsites$SAMPLE %in% contemp.unrelate == TRUE)])
#[1] 1.846997e-05
range(allsites$H[which(allsites$CLASS == "Contemporary" & allsites$SAMPLE %in% contemp.unrelate == TRUE)])
#[1] 0.0001593255 0.0002332972

# Resident (all pairwise r <= 0.4)
mean(allsites$H[which(allsites$CLASS == "Resident" & allsites$SAMPLE %in% res.unrelate == TRUE)])
#[1] 0.0002306068
sd(allsites$H[which(allsites$CLASS == "Resident" & allsites$SAMPLE %in% res.unrelate == TRUE)])
#[1] 2.077982e-05
range(allsites$H[which(allsites$CLASS == "Resident" & allsites$SAMPLE %in% res.unrelate == TRUE)])
#[1] 0.0001854781 0.0002576843

# Translocated (all pairwise r <= 0.4)
mean(allsites$H[which(allsites$CLASS == "Translocated" & allsites$SAMPLE %in% donor.unrelate == TRUE)])
#[1] 0.0002138821
sd(allsites$H[which(allsites$CLASS == "Translocated" & allsites$SAMPLE %in% donor.unrelate == TRUE)])
#[1] 3.394935e-05
range(allsites$H[which(allsites$CLASS == "Translocated" & allsites$SAMPLE %in% donor.unrelate == TRUE)])
#[1] 0.0001607426 0.0002839456

# Other M4
mean(allsites$H[which(allsites$CLASS == "M4" & allsites$SAMPLE %in% histmeta.unrelate == TRUE)])
#[1] 0.0002429067
sd(allsites$H[which(allsites$CLASS == "M4" & allsites$SAMPLE %in% histmeta.unrelate == TRUE)])
#[1] 3.167934e-05
range(allsites$H[which(allsites$CLASS == "M4" & allsites$SAMPLE %in% histmeta.unrelate == TRUE)])
#[1] 0.0001966109 0.0003019788

# H for samples (for which all pairwise r <= 0.4) is normally distributed

shapiro.test(allsites$H[which(allsites$CLASS == "Contemporary" & allsites$SAMPLE %in% contemp.unrelate == TRUE)])
#
#	Shapiro-Wilk normality test
#
#data:  allsites$H[which(allsites$group == "Contemporary" & allsites$SAMPLE %in% contemp.unrelate == TRUE)]
#W = 0.96952, p-value = 0.5679

shapiro.test(allsites$H[which(allsites$CLASS == "Resident" & allsites$SAMPLE %in% res.unrelate == TRUE)])
#
#	Shapiro-Wilk normality test
#
#data:  allsites$H[which(allsites$group == "Resident" & allsites$SAMPLE %in% res.unrelate == TRUE)]
#W = 0.95371, p-value = 0.6196

shapiro.test(allsites$H[which(allsites$CLASS == "Translocated" & allsites$SAMPLE %in% donor.unrelate == TRUE)])
#
#	Shapiro-Wilk normality test
#
#data:  allsites$H[which(allsites$group == "Translocated" & allsites$SAMPLE %in% donor.unrelate == TRUE)]
#W = 0.97319, p-value = 0.9022

shapiro.test(allsites$H[which(allsites$CLASS == "M4" & allsites$SAMPLE %in% histmeta.unrelate == TRUE)])
#
#	Shapiro-Wilk normality test
#
#data:  allsites$H[which(allsites$group == "M4" & allsites$SAMPLE %in% histmeta.unrelate == TRUE)]
#W = 0.96109, p-value = 0.8096

# Test for differences in mean H between groups after having removed relatedness > 0.4

# Contemporary CR vs Resident CR
t.test(x=allsites$H[which(allsites$CLASS == "Contemporary" & allsites$SAMPLE %in% contemp.unrelate == TRUE)], y=allsites$H[which(allsites$CLASS == "Resident" & allsites$SAMPLE %in% res.unrelate == TRUE)], alternative="two.sided")
#
#	Welch Two Sample t-test
#
#data:  allsites$H[which(allsites$CLASS == "Contemporary" & allsites$SAMPLE %in% contemp.unrelate == TRUE)] and allsites$H[which(allsites$CLASS == "Resident" & allsites$SAMPLE %in% res.unrelate == TRUE)]
#t = -4.5105, df = 23.531, p-value = 0.0001503
#alternative hypothesis: true difference in means is not equal to 0
#95 percent confidence interval:
# -4.313854e-05 -1.603385e-05
#sample estimates:
#   mean of x    mean of y 
#0.0002010206 0.0002306068

# Contemporary CR vs translocated
t.test(x=allsites$H[which(allsites$CLASS == "Contemporary" & allsites$SAMPLE %in% contemp.unrelate == TRUE)], y=allsites$H[which(allsites$CLASS == "Translocated" & allsites$SAMPLE %in% donor.unrelate == TRUE)], alternative="two.sided")
#
#	Welch Two Sample t-test
#
#data:  allsites$H[which(allsites$CLASS == "Contemporary" & allsites$SAMPLE %in% contemp.unrelate == TRUE)] and allsites$H[which(allsites$CLASS == "Translocated" & allsites$SAMPLE %in% donor.unrelate == TRUE)]
#t = -1.3632, df = 18.55, p-value = 0.1892
#alternative hypothesis: true difference in means is not equal to 0
#95 percent confidence interval:
# -3.264187e-05  6.918801e-06
#sample estimates:
#   mean of x    mean of y 
#0.0002010206 0.0002138821

# Resident CR versus translocated
t.test(x=allsites$H[which(allsites$CLASS == "Resident" & allsites$SAMPLE %in% res.unrelate == TRUE)], y=allsites$H[which(allsites$CLASS == "Translocated" & allsites$SAMPLE %in% donor.unrelate == TRUE)], alternative="two.sided")
#
#	Welch Two Sample t-test
#
#data:  allsites$H[which(allsites$CLASS == "Resident" & allsites$SAMPLE %in% res.unrelate == TRUE)] and allsites$H[which(allsites$CLASS == "Translocated" & allsites$SAMPLE %in% donor.unrelate == TRUE)]
#t = 1.6117, df = 23.43, p-value = 0.1204
#alternative hypothesis: true difference in means is not equal to 0
#95 percent confidence interval:
# -4.719847e-06  3.816916e-05
#sample estimates:
#   mean of x    mean of y 
#0.0002306068 0.0002138821

--- end R code ---

## Watterson's Theta and nucleotide diversity

--- start R code ---

grps = c("C", "contemporary_unrelated", "resident", "resident_unrelated", "T", "translocated_unrelated", "M4")

# T' is actually donor sites because it includes T_072 (RSW-K) who was from Site 1 but not translocated,
# 'translocated_unrelated' are just translocated jays.
# 'unrelated' groups are subsets of individuals for which all pairwise relatedness is <= 0.01

fprefix="/mnt/research/Fitz_Lab/projects/mosaic/popgen/theta/fsj_mosaic_allsites_main_autosomes_qc"

df = NULL
for (g in grps) {
        theta <- read.table(paste0(fprefix,"_",g,".thetas.idx.pestPG"))
        nsites = sum(theta[,14])
        theta$wt = theta[,14]/nsites
        df=rbind(df, data.frame(Group=g, Theta_Watterson = sum(theta[,4])/nsites, Pi = sum(theta[,5])/nsites, TajimaD = sum(theta[,9]*theta$wt)))
}

# write output
#write.table(df,file='/mnt/research/Fitz_Lab/projects/mosaic/popgen/theta/fsj_mosaic_allsites_main_autosomes_qc_genome_all_groups.thetas', col.names=TRUE, row.names=FALSE, quote=FALSE, sep="\t")

--- end R code ---

Reported thetas estimated using all contemporary CR and all resident CR individuals in the manuscript.

## ---------- INBREEDING NGSF ---------- ##

## Individual inbreeding based on deviation from Hardy-Weinberg Equilibrium genotype frequencies

The following describes calculating individual inbreeding coefficients, F, with ngsF based on allele frequencies 
for the population specific to sets of individuals.

# Calculate genotype likelihoods for populations

Genotype likelihoods for the Contemporary CR population

$sbatch /mnt/research/Fitz_Lab/projects/mosaic/popgen/genotypes/contemporary_binary_gl.sh
implements:

--- start bash code ---

BAMLIST='/mnt/research/Fitz_Lab/projects/mosaic/map/population_specific_bam_lists/contemporary_cr_bams.txt'
REGFILE='/mnt/research/Fitz_Lab/ref/bird/FSJ_V3/FSJ_V3_main_autosomes.txt'
SITESFILE='/mnt/research/Fitz_Lab/projects/mosaic/variants/vcf/biallelic_snps/fsj_mosaic_biallelic_snps_main_autosomes_qc.pos'
OUTPREFIX='/mnt/research/Fitz_Lab/projects/mosaic/popgen/genotypes/contemporary_cr_biallelic_snps_main_autosomes_qc_glf3'

angsd -bam $BAMLIST -out $OUTPREFIX -GL 1 -doGlf 3 -doMaf 1 -doMajorMinor 1 -SNP_pval 1e-4 -minQ 20 -minMapQ 20 -remove_bads 1 -only_proper_pairs 1 -uniqueOnly 1 -rf $REGFILE -sites $SITESFILE -P 16

--- end bash code ---

Genotype likelihoods for the resident CR population

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/popgen/genotypes/resident_binary_gl.sh
implements:

--- start bash code ---

BAMLIST='/mnt/research/Fitz_Lab/projects/mosaic/map/population_specific_bam_lists/resident_cr_bams.txt'
REGFILE='/mnt/research/Fitz_Lab/ref/bird/FSJ_V3/FSJ_V3_main_autosomes.txt'
SITESFILE='/mnt/research/Fitz_Lab/projects/mosaic/variants/vcf/biallelic_snps/fsj_mosaic_biallelic_snps_main_autosomes_qc.pos'
OUTPREFIX='/mnt/research/Fitz_Lab/projects/mosaic/popgen/genotypes/resident_cr_biallelic_snps_main_autosomes_qc_glf3'

angsd -bam $BAMLIST -out $OUTPREFIX -GL 1 -doGlf 3 -doMaf 1 -doMajorMinor 1 -SNP_pval 1e-4 -minQ 20 -minMapQ 20 -remove_bads 1 -only_proper_pairs 1 -uniqueOnly 1 -rf $REGFILE -sites $SITESFILE -P 16

--- end bash code ---

Genotype likelihoods for the donor population individuals

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/popgen/genotypes/donor_pop_binary_gl.sh
implements:

--- start bash code ---

BAMLIST='/mnt/research/Fitz_Lab/projects/mosaic/map/population_specific_bam_lists/donor_pop_bams.txt'
REGFILE='/mnt/research/Fitz_Lab/ref/bird/FSJ_V3/FSJ_V3_main_autosomes.txt'
SITESFILE='/mnt/research/Fitz_Lab/projects/mosaic/variants/vcf/biallelic_snps/fsj_mosaic_biallelic_snps_main_autosomes_qc.pos'
OUTPREFIX='/mnt/research/Fitz_Lab/projects/mosaic/popgen/genotypes/donor_pops_biallelic_snps_main_autosomes_qc_glf3'

angsd -bam $BAMLIST -out $OUTPREFIX -GL 1 -doGlf 3 -doMaf 1 -doMajorMinor 1 -SNP_pval 1e-4 -minQ 20 -minMapQ 20 -remove_bads 1 -only_proper_pairs 1 -uniqueOnly 1 -rf $REGFILE -sites $SITESFILE -P 16

--- end bash code ---

Genotype likelihoods for all historic (jays sampled from 2003-2008) M4 metapopulation individuals

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/popgen/genotypes/historic_metapop_binary_gl.sh
implements:

--- start bash code ---

BAMLIST='/mnt/research/Fitz_Lab/projects/mosaic/map/population_specific_bam_lists/historic_metapopulation_bams.txt'
REGFILE='/mnt/research/Fitz_Lab/ref/bird/FSJ_V3/FSJ_V3_main_autosomes.txt'
SITESFILE='/mnt/research/Fitz_Lab/projects/mosaic/variants/vcf/biallelic_snps/fsj_mosaic_biallelic_snps_main_autosomes_qc.pos'
OUTPREFIX='/mnt/research/Fitz_Lab/projects/mosaic/popgen/genotypes/historic_metapop_biallelic_snps_main_autosomes_qc_glf3'

angsd -bam $BAMLIST -out $OUTPREFIX -GL 1 -doGlf 3 -doMaf 1 -doMajorMinor 1 -SNP_pval 1e-4 -minQ 20 -minMapQ 20 -remove_bads 1 -only_proper_pairs 1 -uniqueOnly 1 -rf $REGFILE -sites $SITESFILE -P 16

--- end bash code ---
 
Genotype likelihoods for Site 13

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/popgen/genotypes/site13_binary_gl.sh
implements:

--- start bash code ---

BAMLIST='/mnt/research/Fitz_Lab/projects/mosaic/map/population_specific_bam_lists/site13_bams.txt'
REGFILE='/mnt/research/Fitz_Lab/ref/bird/FSJ_V3/FSJ_V3_main_autosomes.txt'
SITESFILE='/mnt/research/Fitz_Lab/projects/mosaic/variants/vcf/biallelic_snps/fsj_mosaic_biallelic_snps_main_autosomes_qc.pos'
OUTPREFIX='/mnt/research/Fitz_Lab/projects/mosaic/popgen/genotypes/site13_biallelic_snps_main_autosomes_qc_glf3'

angsd -bam $BAMLIST -out $OUTPREFIX -GL 1 -doGlf 3 -doMaf 1 -doMajorMinor 1 -SNP_pval 1e-4 -minQ 20 -minMapQ 20 -remove_bads 1 -only_proper_pairs 1 -uniqueOnly 1 -rf $REGFILE -sites $SITESFILE -P 16

--- end bash code ---

# Calculate inbreeding coefficients with ngsF

Calculate inbreeding coefficient for Contemporary CR individuals using Contemporary CR allele frequencies

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/popgen/fstats/contemporary_inbreed_coef.sh
implements:

--- start bash code ---

GENOLIKES='/mnt/research/Fitz_Lab/projects/mosaic/popgen/genotypes/contemporary_cr_biallelic_snps_main_autosomes_qc_glf3.glf'
OUTFILE='/mnt/research/Fitz_Lab/projects/mosaic/popgen/fstats/contemporary_cr_biallelic_snps_main_autosomes_qc_F.txt'

CMD="ngsF --glf $GENOLIKES --init_values e --out $OUTFILE --n_ind 28 --n_sites 1347940 --max_iters 3000 --n_threads 20"

printf "\n%s\n\n" "$CMD"

eval $CMD

--- end bash code ---

Calculate inbreeding coefficient for Resident CR individuals using Resident CR allele frequencies

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/popgen/fstats/resident_inbreed_coef.sh
implements:

--- start bash code ---

GENOLIKES='/mnt/research/Fitz_Lab/projects/mosaic/popgen/genotypes/resident_cr_biallelic_snps_main_autosomes_qc_glf3.glf'
OUTFILE='/mnt/research/Fitz_Lab/projects/mosaic/popgen/fstats/resident_cr_biallelic_snps_main_autosomes_qc_F.txt'

CMD="ngsF --glf $GENOLIKES --init_values e --out $OUTFILE --n_ind 16 --n_sites 1204026 --max_iters 3000 --n_threads 20"

printf "\n%s\n\n" "$CMD"

eval $CMD

--- end bash code ---

Calculate inbreeding coefficient for Site 13 individuals using Site 13 allele frequencies

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/popgen/fstats/site13_inbreed_coef.sh
implements:

--- start bash code ---

GENOLIKES='/mnt/research/Fitz_Lab/projects/mosaic/popgen/genotypes/site13_biallelic_snps_main_autosomes_qc_glf3.glf'
OUTFILE='/mnt/research/Fitz_Lab/projects/mosaic/popgen/fstats/site13_biallelic_snps_main_autosomes_qc_F.txt'

CMD="ngsF --glf $GENOLIKES --init_values e --out $OUTFILE --n_ind 19 --n_sites 919620 --max_iters 3000 --n_threads 20"

printf "\n%s\n\n" "$CMD"

eval $CMD

--- end bash code ---

Calculate inbreeding coefficient for donor site individuals using pooled donor site allele frequencies

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/popgen/fstats/donor_pops_inbreed_coef.sh
implements:

--- start bash code ---

GENOLIKES='/mnt/research/Fitz_Lab/projects/mosaic/popgen/genotypes/donor_pops_biallelic_snps_main_autosomes_qc_glf3.glf'
OUTFILE='/mnt/research/Fitz_Lab/projects/mosaic/popgen/fstats/donor_pops_biallelic_snps_main_autosomes_qc_F.txt'

CMD="ngsF --glf $GENOLIKES --init_values e --out $OUTFILE --n_ind 30 --n_sites 1391693 --max_iters 3000 --n_threads 20"

printf "\n%s\n\n" "$CMD"

eval $CMD

--- end bash code ---

Calculate inbreeding coefficient for historic metapopulation individuals using historic metapopulation allele frequencies

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/popgen/fstats/historic_metapop_inbreed_coef.sh
implements:

--- start bash code ---

GENOLIKES='/mnt/research/Fitz_Lab/projects/mosaic/popgen/genotypes/historic_metapop_biallelic_snps_main_autosomes_qc_glf3.glf'
OUTFILE='/mnt/research/Fitz_Lab/projects/mosaic/popgen/fstats/historic_metapop_biallelic_snps_main_autosomes_qc_F.txt'

CMD="ngsF --glf $GENOLIKES --init_values e --out $OUTFILE --n_ind 59 --n_sites 1869994 --max_iters 3000 --n_threads 20"

printf "\n%s\n\n" "$CMD"

eval $CMD

--- end bash code ---

Attach individual identity to the output of ngsF and collate results that use population specific allele frequencies. Note that 
{site1, site12, site18, Texaco} used allele frequencies from the pool of all donor sites and all 'other' M4 individuals used 
allele frequencies of the historic metapopulation (all jays sampled from 2003-2008).

--- start R code ---

# read in metadata
meta <- read.table('/mnt/research/Fitz_Lab/projects/mosaic/M4_sequenced_FSJsamples_metadata.txt',head=TRUE,sep="\t")

# read in F values
contemp_cr <- read.table('/mnt/research/Fitz_Lab/projects/mosaic/popgen/fstats/contemporary_cr_biallelic_snps_main_autosomes_qc_F.txt', head=FALSE)
res_cr <- read.table('/mnt/research/Fitz_Lab/projects/mosaic/popgen/fstats/resident_cr_biallelic_snps_main_autosomes_qc_F.txt', head=FALSE)
s13 <- read.table('/mnt/research/Fitz_Lab/projects/mosaic/popgen/fstats/site13_biallelic_snps_main_autosomes_qc_F.txt', head=FALSE)
donor <- read.table('/mnt/research/Fitz_Lab/projects/mosaic/popgen/fstats/donor_pops_biallelic_snps_main_autosomes_qc_F.txt', head=FALSE)
histmeta <- read.table('/mnt/research/Fitz_Lab/projects/mosaic/popgen/fstats/historic_metapop_biallelic_snps_main_autosomes_qc_F.txt', head=FALSE)

# read in lists of bam files used to calculate genotype likelihood input for ngsF
contemp_bam <- read.table('/mnt/research/Fitz_Lab/projects/mosaic/map/population_specific_bam_lists/contemporary_cr_bams.txt', head=FALSE)
res_bam <- read.table('/mnt/research/Fitz_Lab/projects/mosaic/map/population_specific_bam_lists/resident_cr_bams.txt', head=FALSE)
s13_bam <- read.table('/mnt/research/Fitz_Lab/projects/mosaic/map/population_specific_bam_lists/site13_bams.txt', head=FALSE)
donor_bam <- read.table('/mnt/research/Fitz_Lab/projects/mosaic/map/population_specific_bam_lists/donor_pop_bams.txt', head=FALSE)
histmeta_bam <- read.table('/mnt/research/Fitz_Lab/projects/mosaic/map/population_specific_bam_lists/historic_metapopulation_bams.txt', head=FALSE)

# Associate IDs with F values
contemp_cr$ID <- gsub('/mnt/research/Fitz_Lab/projects/mosaic/map/bam/|.bam','',contemp_bam$V1)
res_cr$ID <- gsub('/mnt/research/Fitz_Lab/projects/mosaic/map/bam/|.bam','',res_bam$V1)
s13$ID <- gsub('/mnt/research/Fitz_Lab/projects/mosaic/map/bam/|.bam','',s13_bam$V1)
donor$ID <- gsub('/mnt/research/Fitz_Lab/projects/mosaic/map/bam/|.bam','',donor_bam$V1)
histmeta$ID <- gsub('/mnt/research/Fitz_Lab/projects/mosaic/map/bam/|.bam','',histmeta_bam$V1)

# collate values
combF <- data.frame(ID=read.table('/mnt/research/Fitz_Lab/projects/mosaic/M4_sequenced_FSJsamples_metadata.txt',head=TRUE,sep="\t")$LAB_ID)
combF$F_CONTEMPORARY_CR_AF <- unname(sapply(combF$ID,function(x,df){idx = which(df$ID == x); ifelse(length(idx) > 0, df$V1[idx], NA)}, df=contemp_cr))
combF$F_RESIDENT_CR_AF <- unname(sapply(combF$ID,function(x,df){idx = which(df$ID == x); ifelse(length(idx) > 0, df$V1[idx], NA)}, df=res_cr))
combF$F_SITE13_AF <- unname(sapply(combF$ID,function(x,df){idx = which(df$ID == x); ifelse(length(idx) > 0, df$V1[idx], NA)}, df=s13))
combF$F_DONOR_AF <- unname(sapply(combF$ID,function(x,df){idx = which(df$ID == x); ifelse(length(idx) > 0, df$V1[idx], NA)}, df=donor))
combF$F_HISTORIC_METAPOP_AF <- unname(sapply(combF$ID,function(x,df){idx = which(df$ID == x); ifelse(length(idx) > 0, df$V1[idx], NA)}, df=histmeta))

# Generate a column of F calculated using population specific allele frequencies
combF$F_POP_SPECIFIC_AF <- NA
for (i in 1:nrow(combF)) {
	id <- combF$ID[i]
	pop <- meta$pop[which(meta$LAB_ID == id)]
	if (pop == "Contemporary") {
		combF$F_POP_SPECIFIC_AF[i] <- combF$F_CONTEMPORARY_CR_AF[i]
	} else if (pop == "Resident") {
		combF$F_POP_SPECIFIC_AF[i] <- combF$F_RESIDENT_CR_AF[i]
	} else if (pop == "SITE_13") {
		combF$F_POP_SPECIFIC_AF[i] <- combF$F_SITE13_AF[i]
	} else if (pop == "SITE_1" || pop == "SITE_12" || pop == "SITE_18" || pop == "TEXACO") {
		combF$F_POP_SPECIFIC_AF[i] <- combF$F_DONOR_AF[i]
	} else if (pop == "Golden_Aster_Scrub" || pop == "Brigman" || pop == "W.Balm" || pop == "Duette_headwaters" || pop == "Sun_City") {
		combF$F_POP_SPECIFIC_AF[i] <- combF$F_HISTORIC_METAPOP_AF[i]
	} else {
		stop(paste0("Unknown population ",pop))
	}
}

# write results
# write.table(combF, file='/mnt/research/Fitz_Lab/projects/mosaic/popgen/fstats/fsj_mosaic_biallelic_snps_main_autosomes_qc_all_F_pop_specific_ref_AF.txt', col.names=TRUE, row.names=FALSE, sep="\t", quote=FALSE)

--- end R code ---

## Statistical tests comparing F between groups

--- start R code ---

# read in F values calculated using population-specific allele frequencies
f.popaf <- read.table('/mnt/research/Fitz_Lab/projects/mosaic/popgen/fstats/fsj_mosaic_biallelic_snps_main_autosomes_qc_all_F_pop_specific_ref_AF.txt', head=TRUE)

# read in IDs for subsets of individuals for which all pairwise relatedness is <= 0.4 (subsets exclude first degree relatives)
contemp.all <- read.table('/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/inputs/contemporary_cr_ids.txt',head=FALSE)$V1 # pairwise relatedness between all of these samples is < 0.4, so is an "unrelated" sample for this analysis
res.all <- read.table('/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/inputs/resident_cr_ids.txt',head=FALSE)$V1
res.unrelate <- read.table('/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/inputs/resident_cr_relatedness_maxr0.4_ids.txt',head=FALSE)$V1
donors.all <- read.table('/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/inputs/donor_pops_ids.txt',head=FALSE)$V1
trans.all <- donors.all[-which(donors.all == "T_072")] # all translocated individuals
donors.unrelated <- read.table('/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/inputs/donor_pops_relatedness_maxr0.4_ids.txt',head=FALSE)$V1
trans.unrelated <- donors.unrelated[-which(donors.unrelated == "T_072")] # translocated individuals with no first degree relatives

## F is not normally distributed

shapiro.test(f.popaf$F_POP_SPECIFIC_AF[which(f.popaf$ID %in% contemp.all == TRUE)])
#
#	Shapiro-Wilk normality test
#
#data:  f.popaf$F_POP_SPECIFIC_AF[which(f.popaf$ID %in% contemp.all == TRUE)]
#W = 0.52384, p-value = 2.028e-08

shapiro.test(f.popaf$F_POP_SPECIFIC_AF[which(f.popaf$ID %in% res.unrelate == TRUE)])
#
#	Shapiro-Wilk normality test
#
#data:  f.popaf$F_POP_SPECIFIC_AF[which(f.popaf$ID %in% res.unrelate == TRUE)]
#W = 0.45359, p-value = 2.618e-06

shapiro.test(f.popaf$F_POP_SPECIFIC_AF[which(f.popaf$ID %in% trans.unrelated == TRUE)])
#
#	Shapiro-Wilk normality test
#
#data:  f.popaf$F_POP_SPECIFIC_AF[which(f.popaf$ID %in% trans.unrelated == TRUE)]
#W = 0.68529, p-value = 0.0001738

## F summary stats for different groups

# All Contemporary CR individuals (all pairwise r < 0.4, i.e. no first degree relatives)
mean(f.popaf$F_POP_SPECIFIC_AF[which(f.popaf$ID %in% contemp.all == TRUE)])
#[1] 0.01707861 
sd(f.popaf$F_POP_SPECIFIC_AF[which(f.popaf$ID %in% contemp.all == TRUE)])
#[1] 0.02587532
range(f.popaf$F_POP_SPECIFIC_AF[which(f.popaf$ID %in% contemp.all == TRUE)])
#[1] 0.001406 0.137558

# All resident CR individuals
mean(f.popaf$F_POP_SPECIFIC_AF[which(f.popaf$ID %in% res.all == TRUE)])
#[1] 0.01012019
sd(f.popaf$F_POP_SPECIFIC_AF[which(f.popaf$ID %in% res.all == TRUE)])
#[1] 0.02268801
range(f.popaf$F_POP_SPECIFIC_AF[which(f.popaf$ID %in% res.all == TRUE)])
#[1] 0.000277 0.091737

# Resident CR individuals without first degree relatives (r <= 0.4)
mean(f.popaf$F_POP_SPECIFIC_AF[which(f.popaf$ID %in% res.unrelate == TRUE)])
#[1] 0.01033443
#sd(f.popaf$F_POP_SPECIFIC_AF[which(f.popaf$ID %in% res.unrelate == TRUE)])
[1] 0.02424458
range(f.popaf$F_POP_SPECIFIC_AF[which(f.popaf$ID %in% res.unrelate == TRUE)])
#[1] 0.000277 0.091737

# All translocated individuals
mean(f.popaf$F_POP_SPECIFIC_AF[which(f.popaf$ID %in% trans.all == TRUE)])
#[1] 0.004767345
sd(f.popaf$F_POP_SPECIFIC_AF[which(f.popaf$ID %in% trans.all == TRUE)])
#[1] 0.009077819
#range(f.popaf$F_POP_SPECIFIC_AF[which(f.popaf$ID %in% trans.all == TRUE)])
[1] 0.000092 0.042977

# Translocated individuals without first degree relatives (r <= 0.4)
mean(f.popaf$F_POP_SPECIFIC_AF[which(f.popaf$ID %in% trans.unrelated == TRUE)])
#[1] 0.008187267
sd(f.popaf$F_POP_SPECIFIC_AF[which(f.popaf$ID %in% trans.unrelated == TRUE)])
#[1] 0.01176101
range(f.popaf$F_POP_SPECIFIC_AF[which(f.popaf$ID %in% trans.unrelated == TRUE)])
#[1] 0.000183 0.042977

## Test for differences in F distribution

# Contemporary vs Resident CR after removing relatedness > 0.4
wilcox.test(x=f.popaf$F_POP_SPECIFIC_AF[which(f.popaf$ID %in% contemp.all == TRUE)], y=f.popaf$F_POP_SPECIFIC_AF[which(f.popaf$ID %in% res.unrelate == TRUE)], alternative="two.sided")
#
#	Wilcoxon rank sum exact test
#
#data:  f.popaf$F_POP_SPECIFIC_AF[which(f.popaf$ID %in% contemp.all == TRUE)] and f.popaf$F_POP_SPECIFIC_AF[which(f.popaf$ID %in% res.unrelate == TRUE)]
#W = 308, p-value = 0.002208
#alternative hypothesis: true location shift is not equal to 0

# Contemporary versus translocated after removing relatedness > 0.4
wilcox.test(x=f.popaf$F_POP_SPECIFIC_AF[which(f.popaf$ID %in% contemp.all == TRUE)], y=f.popaf$F_POP_SPECIFIC_AF[which(f.popaf$ID %in% trans.unrelated == TRUE)], alternative="two.sided")
#
#	Wilcoxon rank sum exact test
#
#data:  f.popaf$F_POP_SPECIFIC_AF[which(f.popaf$ID %in% contemp.all == TRUE)] and f.popaf$F_POP_SPECIFIC_AF[which(f.popaf$ID %in% trans.unrelated == TRUE)]
#W = 298, p-value = 0.02453
#alternative hypothesis: true location shift is not equal to 0

# Resident CR versus translocated individuals after removing relatedness > 0.4
wilcox.test(x=f.popaf$F_POP_SPECIFIC_AF[which(f.popaf$ID %in% res.unrelate == TRUE)], y=f.popaf$F_POP_SPECIFIC_AF[which(f.popaf$ID %in% trans.unrelated == TRUE)], alternative="two.sided")
#
#	Wilcoxon rank sum exact test
#
#data:  f.popaf$F_POP_SPECIFIC_AF[which(f.popaf$ID %in% res.unrelate == TRUE)] and f.popaf$F_POP_SPECIFIC_AF[which(f.popaf$ID %in% trans.unrelated == TRUE)]
#W = 89, p-value = 0.5045
#alternative hypothesis: true location shift is not equal to 0


--- end R code ---


## boxplots comparing individual inbreeding estimated with ngsF using population-specific allele frequencies

--- start R code ---

library(scales)

meta <- read.table('/home/tyler/Dropbox/research/jay/mosaic/metadata/M4_sequenced_FSJsamples_metadata.txt',head=TRUE,sep="\t")
fdf <- read.table('/home/tyler/Dropbox/research/jay/mosaic/popgen/fstats/fsj_mosaic_biallelic_snps_main_autosomes_qc_all_F_pop_specific_ref_AF.txt', head=TRUE)
fdf <- fdf[match(meta$LAB_ID, fdf$ID),] # ensure that the order of individuals matches the metadata

meta$popletter <- popletters(meta) # popletters function defined in /home/tyler/Dropbox/research/jay/mosaic/popgen/fstats/README_MOSAIC_ANALYSIS
meta$popcol <- popcolor(meta) # popcolor function defined in /home/tyler/Dropbox/research/jay/mosaic/popgen/fstats/README_MOSAIC_ANALYSIS
meta$colors <- sitecol(meta) # sitecol function defined in /home/tyler/Dropbox/research/jay/mosaic/popgen/fstats/README_MOSAIC_ANALYSIS

# define groups
groups <- meta$pop
grplevels <- c("Contemporary", "Resident", "Translocated", "M4")

groups <- replace(groups, which(groups == "Golden_Aster_Scrub" | groups == "Brigman" | groups == "W.Balm" | 
groups == "Duette_headwaters" | groups == "Sun_City"), "M4")

groups <- replace(groups, which(groups == "SITE_1" | groups == "SITE_12" | groups == "SITE_13" | 
groups == "SITE_18" | groups == "TEXACO"), "Translocated")

fdf$group = factor(groups,levels=grplevels)

# omit T_072 (RSW-K) because this site 1 bird was not translocated and migrated to LMSP, which is outside of the Core
fdf <- fdf[-which(fdf$ID == "T_072"),]
meta <- meta[-which(meta$LAB_ID == "T_072"),]

# set point type
fdf$biopoint = biopoint(meta$pop) # biopoint function defined in /home/tyler/Dropbox/research/jay/mosaic/popgen/fstats/README_MOSAIC_ANALYSIS

max(fdf$F_POP_SPECIFIC_AF)
# [1] 0.137558 # set upper y-limit above this value

# plot

#png(file='/home/tyler/Dropbox/research/jay/mosaic/figures/F_distribution_pop_specific_AF.png',width=7, height=7,units='in', res=300)
h_boxplot2(x=fdf, n=7, lev=grplevels, ylabel=expression(Individual~inbreeding~(italic(F))), pntlab=fdf$biopoint, seed=1947, color=meta$popcol, ylim=c(0,0.145))
axis(2, at=c((0.0+0.05)/2, (0.05+0.1)/2, (0.1+0.15)/2), line=NA, labels=NA) # add some extra axis tick marks for clarity
#dev.off()

# make plot with IDs at points
#pdf(file='/home/tyler/Dropbox/research/jay/mosaic/figures/F_distribution_pop_specific_AF_text.pdf',width=7, height=7)
h_boxplot2(x=fdf, n=7, lev=grplevels, ylabel=expression(Individual~inbreeding~(italic(F))), pntlab=NULL, seed=1947, color=meta$popcol, ylimits=c(0,0.145), idlabels=fdf$ID)
axis(2, at=c((0.0+0.05)/2, (0.05+0.1)/2, (0.1+0.15)/2), line=NA, labels=NA) # add some extra axis tick marks for clarity

# zoomed in plot to better distinguish IDs
h_boxplot2(x=fdf, n=7, lev=grplevels, ylabel=expression(Individual~inbreeding~(italic(F))), pntlab=NULL, seed=1947, color=meta$popcol, ylimits=c(0,0.05), idlabels=fdf$ID)
axis(2, at=c((0.0+0.05)/2, (0.05+0.1)/2, (0.1+0.15)/2), line=NA, labels=NA) # add some extra axis tick marks for clarity

# zoomed in more
h_boxplot2(x=fdf, n=7, lev=grplevels, ylabel=expression(Individual~inbreeding~(italic(F))), pntlab=NULL, seed=1947, color=meta$popcol, ylimits=c(0,0.008), idlabels=fdf$ID)
axis(2, at=c((0.0+0.05)/2, (0.05+0.1)/2, (0.1+0.15)/2), line=NA, labels=NA) # add some extra axis tick marks for clarity

# zoom even more
h_boxplot2(x=fdf, n=7, lev=grplevels, ylabel=expression(Individual~inbreeding~(italic(F))), pntlab=NULL, seed=1947, color=meta$popcol, ylimits=c(0,0.003), idlabels=fdf$ID)
axis(2, at=c((0.0+0.05)/2, (0.05+0.1)/2, (0.1+0.15)/2), line=NA, labels=NA) # add some extra axis tick marks for clarity

#dev.off()

## make a plot to find where the top 5 pedigree-based contributors circled in figure 3A are in the boxplot

h_boxplot_mask <- function(x=NULL, n=NULL, lev=grplevels, ylabel="Heterozygosity", pntlab=NULL, seed=10287, color=NULL, ylimits=NULL, idlabels=NULL) {
        if (length(grep("TeachingDemos",(.packages()))) == 0) library(TeachingDemos) # for shadowtext()
        nlevel = length(lev)

        par(mar=c(5,5,2,2))
        boxplot(x[,n] ~ group, data=x, outline=FALSE, names=c(rep("",nlevel)), xlab="", ylab=ylabel, main="", col="gray80", cex.axis=1.5, cex.lab=1.5, lwd=2, ylim=ylimits)
        #mtext(lev,1,at=1:nlevel, padj=1, cex=1.5)
        mtext(c(lev[1:3],paste("Other","M4",sep="\n")), 1,at=1:nlevel, padj=1, cex=1.5)
        #mtext("Group",1,at=3,padj=2.5, cex=1.5)

        # add points
        for (i in lev) {
                idx = which(as.character(x$group) == i)
                set.seed(seed)
                xjitter = jitter(rep(which(lev == i),length(idx)), amount=0.2)
                ptcol = NULL
                for (j in 1:length(idx)) {
                        if (is.null(color)) ptcol = alpha("maroon",0.5) else ptcol = color[idx[j]]
                        if (is.null(pntlab) || is.na(pntlab[idx[j]])) {
                                if (!is.null(idlabels)) {
                                  text(y=x[idx[j],n], x=xjitter[j],idlabels[idx[j]],cex=0.5,col="red")
                                } else {
                                  points(y=x[idx[j],n], x=xjitter[j], pch=1, cex=1.2)
                                  points(y=x[idx[j],n], x=xjitter[j], pch=16, cex=1.2, col=ptcol)
                                }
                        } else if (class(pntlab) == "numeric") {
                                points(y=x[idx[j],n], x=xjitter[j], pch=pntlab[idx[j]], col=alpha("grey70",0.5), bg=color[idx[j]],lwd=1.3,cex=1.5)
                        }  else if (class(pntlab) == "character") {
                                shadowtext(y=x[idx[j],n], x=xjitter[j], labels=pntlab[idx[j]], col=color[idx[j]], bg=alpha("black",0.5), r=0.07, cex=1.2)       
                        } else stop("Unknown argument to pntlab")
                }
        }

}

meta$maskcol = meta$popcol
meta$maskcol[-which(meta$LAB_ID == "T_071" | meta$LAB_ID == "T_099" | meta$LAB_ID == "T_081" | meta$LAB_ID == "T_086" | meta$LAB_ID == "T_067")] <- alpha("grey90",0)
meta$maskcol[which(meta$LAB_ID == "T_071")] <- alpha(meta$popcol[which(meta$LAB_ID == "T_071")],0.65)
meta$maskcol[which(meta$LAB_ID == "T_099")] <- alpha(meta$popcol[which(meta$LAB_ID == "T_099")],0.65)
meta$maskcol[which(meta$LAB_ID == "T_081")] <- alpha(meta$popcol[which(meta$LAB_ID == "T_081")],0.65)
meta$maskcol[which(meta$LAB_ID == "T_086")] <- alpha(meta$popcol[which(meta$LAB_ID == "T_086")],0.65)
meta$maskcol[which(meta$LAB_ID == "T_067")] <- alpha(meta$popcol[which(meta$LAB_ID == "T_067")],0.65)

h_boxplot_mask(x=fdf, n=7, lev=grplevels, ylabel=expression(Individual~inbreeding~(italic(F))), pntlab=fdf$biopoint, seed=1947, color=meta$maskcol, ylim=c(0,0.145))

--- end R code ---

## ---------- RUNS OF HOMOZYGOSITY (ROH) ---------- ##

Identify runs of homozygosity with bcftools roh HMM.

## Define reference populations and calculate allele frequencies

Reference population allele frequencies estimated for groups with >= 10 individuals after pruning potential 
first degree relatives (r > 0.4).


--- start R code ---

rmat <- as.matrix(read.table('/mnt/research/Fitz_Lab/projects/mosaic/popgen/relatedness/fsj_mosaic_biallelic_snps_main_autosomes_qc_relatedness_matrix.txt',head=TRUE,row.names=1))
colnames(rmat) <- gsub('\\..+$', '', colnames(rmat), perl=TRUE) # remove location info
meta <- read.table('/mnt/research/Fitz_Lab/projects/mosaic/M4_sequenced_FSJsamples_metadata.txt',head=TRUE,sep="\t")

# collect IDs of individuals in each group
c.id <- meta$LAB_ID[which(meta$pop == "Contemporary")]
r.id <- meta$LAB_ID[which(meta$pop == "Resident")]
s13.id <- meta$LAB_ID[which(meta$pop == "SITE_13")]
histmeta.id <- meta$LAB_ID[which(meta$year_sampled < 2021)]

# note: exclude RSW-K from CR founders in case I use them as a reference pop for the Contemporary CR individuals at some point
crfounders.id <- meta$LAB_ID[which((meta$pop == "Resident" | meta$pop == "SITE_1" | meta$pop == "SITE_12" | meta$pop == "SITE_13" | meta$pop == "SITE_18" | meta$pop == "TEXACO") & meta$LAB_ID != "T_072")]

# note: include RSW-K for the donor site group because they are relevant for estimating the allele frequencies in this metapopulation subset
donor.id <- meta$LAB_ID[which(meta$pop == "SITE_1" | meta$pop == "SITE_12" | meta$pop == "SITE_13" | meta$pop == "SITE_18" | meta$pop == "TEXACO")]

# extract relatedness matrix subsets
c.rmat <- rmat[which(colnames(rmat) %in% c.id == TRUE), which(colnames(rmat) %in% c.id == TRUE)]
r.rmat <- rmat[which(colnames(rmat) %in% r.id == TRUE), which(colnames(rmat) %in% r.id == TRUE)]
s13.rmat <- rmat[which(colnames(rmat) %in% s13.id == TRUE), which(colnames(rmat) %in% s13.id == TRUE)]
histmeta.rmat <- rmat[which(colnames(rmat) %in% histmeta.id == TRUE), which(colnames(rmat) %in% histmeta.id == TRUE)]
crfounders.rmat <- rmat[which(colnames(rmat) %in% crfounders.id == TRUE), which(colnames(rmat) %in% crfounders.id == TRUE)]
donor.rmat <- rmat[which(colnames(rmat) %in% donor.id == TRUE), which(colnames(rmat) %in% donor.id == TRUE)]

# output relatedness submatrices
#write.table(c.rmat, file='/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/contemporary_cr_relatedness_matrix.txt', col.names=TRUE, row.names=FALSE, quote=FALSE, sep="\t")
#write.table(r.rmat, file='/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/resident_cr_relatedness_matrix.txt', col.names=TRUE, row.names=FALSE, quote=FALSE, sep="\t")
#write.table(s13.rmat, file='/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/site13_relatedness_matrix.txt', col.names=TRUE, row.names=FALSE, quote=FALSE, sep="\t")
#write.table(histmeta.rmat, file='/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/historic_metapop_relatedness_matrix.txt', col.names=TRUE, row.names=FALSE, quote=FALSE, sep="\t")
#write.table(crfounders.rmat, file='/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/cr_founders_relatedness_matrix.txt', col.names=TRUE, row.names=FALSE, quote=FALSE, sep="\t")
#write.table(donor.rmat, file='/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/donor_pops_relatedness_matrix.txt', col.names=TRUE, row.names=FALSE, quote=FALSE, sep="\t")

# output the original relatedness matrix of all samples, entirely unchanged except for removing the row names and simplifying the IDs (remove population labels)
#write.table(rmat, file='/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/fsj_mosaic_biallelic_snps_main_autosomes_qc_relatedness_matrix_fmt.txt', col.names=TRUE, row.names=FALSE, quote=FALSE, sep="\t")

--- end R code ---

Randomly prune out individuals involved in relationships having pairwise relatedness > 0.4 (removes first degree relatives).

$ /mnt/research/Fitz_Lab/projects/mosaic/popgen/relatedness/scripts/subsetUnrelated.R contemporary_cr_relatedness_matrix.txt 0.4 836241 > contemporary_cr_relatedness_maxr0.4_ids.txt
$ /mnt/research/Fitz_Lab/projects/mosaic/popgen/relatedness/scripts/subsetUnrelated.R resident_cr_relatedness_matrix.txt 0.4 836241 > resident_cr_relatedness_maxr0.4_ids.txt
$ /mnt/research/Fitz_Lab/projects/mosaic/popgen/relatedness/scripts/subsetUnrelated.R site13_relatedness_matrix.txt 0.4 836241 > site13_relatedness_maxr0.4_ids.txt
$ /mnt/research/Fitz_Lab/projects/mosaic/popgen/relatedness/scripts/subsetUnrelated.R historic_metapop_relatedness_matrix.txt 0.4 836241 > historic_metapop_relatedness_maxr0.4_ids.txt
$ /mnt/research/Fitz_Lab/projects/mosaic/popgen/relatedness/scripts/subsetUnrelated.R cr_founders_relatedness_matrix.txt 0.4 836241 > cr_founders_relatedness_maxr0.4_ids.txt
$ /mnt/research/Fitz_Lab/projects/mosaic/popgen/relatedness/scripts/subsetUnrelated.R donor_pops_relatedness_matrix.txt 0.4 836241 > donor_pops_relatedness_maxr0.4_ids.txt
$ /mnt/research/Fitz_Lab/projects/mosaic/popgen/relatedness/scripts/subsetUnrelated.R fsj_mosaic_biallelic_snps_main_autosomes_qc_relatedness_matrix_fmt.txt 0.4 836241 > fsj_mosaic_biallelic_snps_main_autosomes_qc_relatedness_maxr0.4_ids.txt

Identify sites segregating within subsetted reference groups.

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/scripts/mosaic_groups_segregating_sites_array.sh
implements:

--- start bash code ---

VCF='/mnt/research/Fitz_Lab/projects/mosaic/variants/vcf/biallelic_snps/fsj_mosaic_biallelic_snps_main_autosomes_qc.vcf.gz'
POPLIST='/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/scripts/mosaic_reference_pop_maxr0.4_list.txt'
POP=$(sed -n "${SLURM_ARRAY_TASK_ID}p" "$POPLIST" | cut -f1)
SAMPLES=$(sed -n "${SLURM_ARRAY_TASK_ID}p" "$POPLIST" | cut -f2)
OUTFILE="/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/inputs/${POP}_biallelic_snps_main_autosomes_qc.pos"

CMD="bcftools view -O u -a -S $SAMPLES -c 1:minor -m2 -M2 $VCF | bcftools query -f '%CHROM\t%POS\t%REF\t%ALT\n' > $OUTFILE"

printf "\n%s\n\n" "$CMD"

eval $CMD

wait

CMD2="angsd sites index $OUTFILE"

printf "\n%s\n\n" "$CMD2"

eval $CMD2

--- end bash code ---

Calculate alternate allele (in this case same as the Mosaic-wide minor allele) frequency.

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/scripts/mosaic_reference_pop_allele_freq_array.sh
implements:

--- start bash code ---

INPUT_LIST='/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/scripts/mosaic_reference_pop_maxr0.4_af_estimate_inputs.txt'
POP=$(sed -n "${SLURM_ARRAY_TASK_ID}p" "$INPUT_LIST" | cut -f1)
BAMS=$(sed -n "${SLURM_ARRAY_TASK_ID}p" "$INPUT_LIST" | cut -f2)
SITESFILE=$(sed -n "${SLURM_ARRAY_TASK_ID}p" "$INPUT_LIST" | cut -f3)
OUTPREFIX="/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/inputs/${POP}_maxr0.4_biallelic_snps_main_autosomes_qc"

CMD="angsd -bam $BAMS -out $OUTPREFIX -GL 1 -doMaf 1 -doMajorMinor 3 -sites $SITESFILE -minQ 20 -minMapQ 20 -remove_bads 1 -only_proper_pairs 1 -uniqueOnly 1 -P 8"

printf "\n%s\n\n" "$CMD"

eval $CMD

--- end bash code ---

Format allele frequencies for bcftools roh.

$ zcat contemporary_cr_maxr0.4_biallelic_snps_main_autosomes_qc.mafs.gz | tail -n+2 | perl -ne 'chomp; @tok=split(/\t/,$_); print "$tok[0]\t$tok[1]\t$tok[2],$tok[3]\t$tok[4]\n";' | bgzip -c > contemporary_cr_maxr0.4_biallelic_snps_main_autosomes_qc.af.gz
$ tabix -s1 -b2 -e2 contemporary_cr_maxr0.4_biallelic_snps_main_autosomes_qc.af.gz

$ zcat resident_cr_maxr0.4_biallelic_snps_main_autosomes_qc.mafs.gz | tail -n+2 | perl -ne 'chomp; @tok=split(/\t/,$_); print "$tok[0]\t$tok[1]\t$tok[2],$tok[3]\t$tok[4]\n";' | bgzip -c > resident_cr_maxr0.4_biallelic_snps_main_autosomes_qc.af.gz
$ tabix -s1 -b2 -e2 resident_cr_maxr0.4_biallelic_snps_main_autosomes_qc.af.gz

$ zcat cr_founders_maxr0.4_biallelic_snps_main_autosomes_qc.mafs.gz | tail -n+2 | perl -ne 'chomp; @tok=split(/\t/,$_); print "$tok[0]\t$tok[1]\t$tok[2],$tok[3]\t$tok[4]\n";' | bgzip -c > cr_founders_maxr0.4_biallelic_snps_main_autosomes_qc.af.gz
$ tabix -s1 -b2 -e2 cr_founders_maxr0.4_biallelic_snps_main_autosomes_qc.af.gz

$ zcat donor_pops_maxr0.4_biallelic_snps_main_autosomes_qc.mafs.gz | tail -n+2 | perl -ne 'chomp; @tok=split(/\t/,$_); print "$tok[0]\t$tok[1]\t$tok[2],$tok[3]\t$tok[4]\n";' | bgzip -c > donor_pops_maxr0.4_biallelic_snps_main_autosomes_qc.af.gz
$ tabix -s1 -b2 -e2 donor_pops_maxr0.4_biallelic_snps_main_autosomes_qc.af.gz

$ zcat site13_maxr0.4_biallelic_snps_main_autosomes_qc.mafs.gz | tail -n+2 | perl -ne 'chomp; @tok=split(/\t/,$_); print "$tok[0]\t$tok[1]\t$tok[2],$tok[3]\t$tok[4]\n";' | bgzip -c > site13_maxr0.4_biallelic_snps_main_autosomes_qc.af.gz
$ tabix -s1 -b2 -e2 site13_maxr0.4_biallelic_snps_main_autosomes_qc.af.gz

$ zcat historic_metapop_maxr0.4_biallelic_snps_main_autosomes_qc.mafs.gz | tail -n+2 | perl -ne 'chomp; @tok=split(/\t/,$_); print "$tok[0]\t$tok[1]\t$tok[2],$tok[3]\t$tok[4]\n";' | bgzip -c > historic_metapop_maxr0.4_biallelic_snps_main_autosomes_qc.af.gz
$ tabix -s1 -b2 -e2 historic_metapop_maxr0.4_biallelic_snps_main_autosomes_qc.af.gz

$ zcat mosaic_all_maxr0.4_biallelic_snps_main_autosomes_qc.mafs.gz | tail -n+2 | perl -ne 'chomp; @tok=split(/\t/,$_); print "$tok[0]\t$tok[1]\t$tok[2],$tok[3]\t$tok[4]\n";' | bgzip -c > mosaic_all_maxr0.4_biallelic_snps_main_autosomes_qc.af.gz
$ tabix -s1 -b2 -e2 mosaic_all_maxr0.4_biallelic_snps_main_autosomes_qc.af.gz

## Identify ROH

Use a constant recombination rate that reflects the average across different bird species.

# recombination rate estimates for birds:
# Backstrom etal 2010: mean 1.5 cM/Mb in zebra finch exluding 10 microchromsomes and projected to be ~2 cM/Mb with the microchromosomes
# Singhal etal 2015: median 0.14 cM/Mb in both Taeniopygia guttata (zebra finch) and Poephila acuticuada (long-tailed finch)
# Bascon-Cardozo etal 2024: mean 5.8 cM/Mb in Eurasian blackcap
# Smeds etal 2016: mean 3.08 cM/Mb in collared flycatcher
# Ellegren 2005: median 2.8 cM/Mb for macrochromosomes in chicken
# Hagen etal 2020: mean 1.78 cM/Mb for macrochromosomes and 6.41 cM/Mb for microchromosomes, genome average = 4.095 cM/Mb, in house sparrows
# Groenen etal 2000: mean 6.02 cM/Mb in chicken
# Groenen etal 2009: mean 3.11 cM/Mb in chicken
# Stapley etal 2008: mean 3.18 cM/Mb in zebra finch
# Kawakami etal 2014: mean 3.1 cM/Mb in collared flycatcher

# Used in average estimate
# Backstrom etal 2010: 2 cM/Mb in zebrafinch
# Bascon-Cardozo etal 2024: 5.8 cM/Mb in Eurasian blackcap
# Smeds etal 2016: 3.08 cM/Mb in collared flycatcher
# Hagen etal 2020: 4.095 in house sparrows
# Groenen etal 2009: 3.11 cM/Mb in chicken

# Will use average of the mean recombination rates for the different species above:
# mean(c(2, 5.8, 3.08, 4.095, 3.11)) == 3.617 cM/Mb == 3.6e-8 crossovers/bp (expected)

Determine whether each SNP is in an autozygous or nonautozygous tract for individuals.

ROH for the Contemporary CR population using Contemporary CR population specific allele frequencies (estimated after pruning relatedness > 0.4) as reference.

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/scripts/contemporary_cr_roh_array.sh
implements:

--- start bash code ---

VCF='/mnt/research/Fitz_Lab/projects/mosaic/variants/vcf/biallelic_snps/fsj_mosaic_biallelic_snps_main_autosomes_qc.vcf.gz'
SAMPLE_LIST='/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/inputs/contemporary_cr_ids.txt'
SAMP=$(sed -n "${SLURM_ARRAY_TASK_ID}p" "$SAMPLE_LIST")
AF_FILE='/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/inputs/contemporary_cr_maxr0.4_biallelic_snps_main_autosomes_qc.af.gz'
OUTFILE="/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/estimates/${SAMP}_contemporary_cr_af_roh.txt"

CMD="bcftools roh --samples $SAMP --AF-file $AF_FILE --rec-rate 3.6e-8 --output $OUTFILE --output-type sr --skip-indels --viterbi-training 1e-10 --threads 12 $VCF"

printf "\n%s\n\n" "$CMD"

eval $CMD

--- end bash code ---


ROH for the Resident CR population using Resident CR population specific alelle frequencies (estimated after pruning relatedness > 0.4) as reference.

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/scripts/resident_cr_roh_array.sh
implements:

--- start bash code ---

VCF='/mnt/research/Fitz_Lab/projects/mosaic/variants/vcf/biallelic_snps/fsj_mosaic_biallelic_snps_main_autosomes_qc.vcf.gz'
SAMPLE_LIST='/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/inputs/resident_cr_ids.txt'
SAMP=$(sed -n "${SLURM_ARRAY_TASK_ID}p" "$SAMPLE_LIST")
AF_FILE='/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/inputs/resident_cr_maxr0.4_biallelic_snps_main_autosomes_qc.af.gz'
OUTFILE="/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/estimates/${SAMP}_resident_cr_af_roh.txt"

CMD="bcftools roh --samples $SAMP --AF-file $AF_FILE --rec-rate 3.6e-8 --output $OUTFILE --output-type sr --skip-indels --viterbi-training 1e-10 --threads 12 $VCF"

printf "\n%s\n\n" "$CMD"

eval $CMD

--- end bash code ---


ROH for all Site 13 individuals using allele frequencies estimated from Site 13 individuals (estimated after pruning relatedness < 0.4) as reference.

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/scripts/site13_roh_array.sh
implements:

--- start bash code ---

VCF='/mnt/research/Fitz_Lab/projects/mosaic/variants/vcf/biallelic_snps/fsj_mosaic_biallelic_snps_main_autosomes_qc.vcf.gz'
SAMPLE_LIST='/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/inputs/site13_ids.txt'
SAMP=$(sed -n "${SLURM_ARRAY_TASK_ID}p" "$SAMPLE_LIST")
AF_FILE='/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/inputs/site13_maxr0.4_biallelic_snps_main_autosomes_qc.af.gz'
OUTFILE="/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/estimates/${SAMP}_site13_af_roh.txt"

CMD="bcftools roh --samples $SAMP --AF-file $AF_FILE --rec-rate 3.6e-8 --output $OUTFILE --output-type sr --skip-indels --viterbi-training 1e-10 --threads 12 $VCF"

printf "\n%s\n\n" "$CMD"

eval $CMD

--- end bash code ---


ROH for all donor site individuals (includes translocated individuals) using donor population allele frequencies (estimated after pruning relatedness > 0.4) as reference

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/scripts/donor_pop_roh_array.sh
implements:

--- start bash code ---

VCF='/mnt/research/Fitz_Lab/projects/mosaic/variants/vcf/biallelic_snps/fsj_mosaic_biallelic_snps_main_autosomes_qc.vcf.gz'
SAMPLE_LIST='/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/inputs/donor_pops_ids.txt'
SAMP=$(sed -n "${SLURM_ARRAY_TASK_ID}p" "$SAMPLE_LIST")
AF_FILE='/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/inputs/donor_pops_maxr0.4_biallelic_snps_main_autosomes_qc.af.gz'
OUTFILE="/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/estimates/${SAMP}_donor_pops_af_roh.txt"

CMD="bcftools roh --samples $SAMP --AF-file $AF_FILE --rec-rate 3.6e-8 --output $OUTFILE --output-type sr --skip-indels --viterbi-training 1e-10 --threads 12 $VCF"

printf "\n%s\n\n" "$CMD"

eval $CMD

--- end bash code ---


ROH for all historic individuals (jays sampled from 2003-2008) throughout the M4 metapopulation using historic metapopulation allele frequencies (estimated after pruning relatedness > 0.4) as reference.

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/scripts/historic_metapop_roh_array.sh
implements:

--- start bash code ---

VCF='/mnt/research/Fitz_Lab/projects/mosaic/variants/vcf/biallelic_snps/fsj_mosaic_biallelic_snps_main_autosomes_qc.vcf.gz'
SAMPLE_LIST='/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/inputs/historic_metapop_ids.txt'
SAMP=$(sed -n "${SLURM_ARRAY_TASK_ID}p" "$SAMPLE_LIST")
AF_FILE='/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/inputs/historic_metapop_maxr0.4_biallelic_snps_main_autosomes_qc.af.gz'
OUTFILE="/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/estimates/${SAMP}_historic_metapop_af_roh.txt"

CMD="bcftools roh --samples $SAMP --AF-file $AF_FILE --rec-rate 3.6e-8 --output $OUTFILE --output-type sr --skip-indels --viterbi-training 1e-10 --threads 12 $VCF"

printf "\n%s\n\n" "$CMD"

eval $CMD

--- end bash code ---


ROH for all Mosaic individuals using allele frequencies estimated from all Mosaic individuals (after pruning relatedness < 0.4) as reference.

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/scripts/mosaic_all_roh_array.sh
implements:

--- start bash code ---

VCF='/mnt/research/Fitz_Lab/projects/mosaic/variants/vcf/biallelic_snps/fsj_mosaic_biallelic_snps_main_autosomes_qc.vcf.gz'
SAMPLE_LIST='/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/inputs/mosaic_all_ids.txt'
SAMP=$(sed -n "${SLURM_ARRAY_TASK_ID}p" "$SAMPLE_LIST")
AF_FILE='/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/inputs/mosaic_all_maxr0.4_biallelic_snps_main_autosomes_qc.af.gz'
OUTFILE="/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/estimates/${SAMP}_mosaic_all_af_roh.txt"

CMD="bcftools roh --samples $SAMP --AF-file $AF_FILE --rec-rate 3.6e-8 --output $OUTFILE --output-type sr --skip-indels --viterbi-training 1e-10 --threads 12 $VCF"

printf "\n%s\n\n" "$CMD"

eval $CMD

--- end bash code ---

Identify ROH regions and calculate FROH from bcftools roh HMM output.

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/scripts/mosaic_roh_regions_array.sh
implements:

--- start bash code ---

HMM_FILE_LIST='/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/scripts/mosaic_individual_roh_hmm_list.txt'
HMMF=$(sed -n "${SLURM_ARRAY_TASK_ID}p" "$HMM_FILE_LIST")
REGION_OUT=$(echo "$HMMF" | sed 's/\.txt$/\.regions/')
FROH_OUT=$(echo "$HMMF" | sed 's/\.txt$/\.froh/')
EXEC='/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/scripts/rohRegions.pl'

CMD="$EXEC 20 $HMMF $REGION_OUT > $FROH_OUT"

printf "\n%s\n\n" "$CMD"

eval $CMD

--- end bash code ---

## Collate FROH estimates

Collect FROH estimates for Contemporary CR individuals calculated using allele frequencies estimated from the Contemporary CR sample with relatedness <= 0.4.

--- start bash code ---

OUTF='/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/estimates/froh/contemporary_cr_froh_using_contemporary_cr_ref.txt'
printf "ID\tFROH\tFROH_HIQUAL\n" > "$OUTF"
while read id
do
	FILE="/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/estimates/${id}_contemporary_cr_af_roh.froh"
	(printf "%s\t" $id && (tail -n1 "$FILE" | cut -f1,2)) >> "$OUTF"
done < /mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/inputs/contemporary_cr_ids.txt

--- end bash code ---


Collect FROH estimates for Resident CR individuals calculated using allele frequencies estimated from the Resident CR population sample with relatedness <= 0.4.

--- start bash code ---

OUTF='/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/estimates/froh/resident_cr_froh_using_resident_cr_ref.txt'
printf "ID\tFROH\tFROH_HIQUAL\n" > "$OUTF"
while read id
do
	FILE="/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/estimates/${id}_resident_cr_af_roh.froh"
	(printf "%s\t" $id && (tail -n1 "$FILE" | cut -f1,2)) >> "$OUTF"
done < /mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/inputs/resident_cr_ids.txt

--- end bash code ---


Collect FROH estimates for Site 13 individuals calculated using allele frequencies estimated from the Site 13 population sample with relatedness <= 0.4.

--- start bash code ---

OUTF='/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/estimates/froh/site13_froh_using_site13_ref.txt'
printf "ID\tFROH\tFROH_HIQUAL\n" > "$OUTF"
while read id
do
	FILE="/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/estimates/${id}_site13_af_roh.froh"
	(printf "%s\t" $id && (tail -n1 "$FILE" | cut -f1,2)) >> "$OUTF"
done < /mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/inputs/site13_ids.txt

--- end bash code ---


Collect FROH estimates for donor population individuals calculated using allele frequencies estimated from pooled donor populations after removing relatedness > 0.4.

--- start bash code ---

OUTF='/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/estimates/froh/donor_froh_using_pooled_donor_ref.txt'
printf "ID\tFROH\tFROH_HIQUAL\n" > "$OUTF"
while read id
do
	FILE="/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/estimates/${id}_donor_pops_af_roh.froh"
	(printf "%s\t" $id && (tail -n1 "$FILE" | cut -f1,2)) >> "$OUTF"
done < /mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/inputs/donor_pops_ids.txt

--- end bash code ---

Collect FROH estimates for historic metapopulation individuals (jays sampled from 2003-2008) calculated using allele frequencies estimated from the historic metapopulation samples with relatedness <= 0.4.

--- start bash code ---

OUTF='/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/estimates/froh/historic_metapop_froh_using_historic_metapop_ref.txt'
printf "ID\tFROH\tFROH_HIQUAL\n" > "$OUTF"
while read id
do
	FILE="/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/estimates/${id}_historic_metapop_af_roh.froh"
	(printf "%s\t" $id && (tail -n1 "$FILE" | cut -f1,2)) >> "$OUTF"
done < /mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/inputs/historic_metapop_ids.txt

--- end bash code ---

Collect FROH estimates for all Mosaic individuals calculated using allele frequencies estimated from all pooled Mosaic individuals having relatedness <= 0.4.

--- start bash code ---

OUTF='/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/estimates/froh/all_mosaic_individuals_froh_using_all_pooled_mosaic_ref.txt'
printf "ID\tFROH\tFROH_HIQUAL\n" > "$OUTF"
while read id
do
	FILE="/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/estimates/${id}_mosaic_all_af_roh.froh"
	(printf "%s\t" $id && (tail -n1 "$FILE" | cut -f1,2)) >> "$OUTF"
done < /mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/inputs/mosaic_all_ids.txt

--- end bash code ---

Combine high quality FROH estimates across all samples into a single file.

'FROH_BEST' (what I consider the best Froh estimate) is 
Froh estimated using population-specific allele frequencies (when they could be estimated with a sample size >= 10 after removing 
first degree relatives, r > 0.4) when possible. When estimating population-specific allele frequencies was not possible the next 
most appropriate reference population was chosen, specifically the pooled donor sites for translocated jays or the entire historic metapopulation 
for the 'other' M4 population individuals.

--- start R code ---

# read in metadata
meta <- read.table('/mnt/research/Fitz_Lab/projects/mosaic/M4_sequenced_FSJsamples_metadata.txt',head=TRUE,sep="\t")

# read in froh values
contemp_cr <- read.table('/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/estimates/froh/contemporary_cr_froh_using_contemporary_cr_ref.txt', head=TRUE)
res_cr <- read.table('/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/estimates/froh/resident_cr_froh_using_resident_cr_ref.txt', head=TRUE)
s13 <- read.table('/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/estimates/froh/site13_froh_using_site13_ref.txt',head=TRUE)
donor <- read.table('/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/estimates/froh/donor_froh_using_pooled_donor_ref.txt',head=TRUE)
histmeta <- read.table('/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/estimates/froh/historic_metapop_froh_using_historic_metapop_ref.txt',head=TRUE)
allmosaic <- read.table('/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/estimates/froh/all_mosaic_individuals_froh_using_all_pooled_mosaic_ref.txt',head=TRUE)

# combine froh values
allcomb <- allmosaic[,c(1,3)]
colnames(allcomb) <- c('ID', 'FROH_ALL_MOSAIC_AF')
allcomb$FROH_CONTEMPORARY_CR_AF <- unname(sapply(allcomb$ID, function(x,df){idx = which(df$ID == x); ifelse(length(idx) > 0, df$FROH_HIQUAL[idx], NA)}, df = contemp_cr))
allcomb$FROH_RESIDENT_CR_AF <- unname(sapply(allcomb$ID, function(x,df){idx = which(df$ID == x); ifelse(length(idx) > 0, df$FROH_HIQUAL[idx], NA)}, df = res_cr))
allcomb$FROH_SITE13_AF <- unname(sapply(allcomb$ID, function(x,df){idx = which(df$ID == x); ifelse(length(idx) > 0, df$FROH_HIQUAL[idx], NA)}, df = s13))
allcomb$FROH_DONOR_AF <- unname(sapply(allcomb$ID, function(x,df){idx = which(df$ID == x); ifelse(length(idx) > 0, df$FROH_HIQUAL[idx], NA)}, df = donor))
allcomb$FROH_HISTORIC_METAPOP_AF <- unname(sapply(allcomb$ID, function(x,df){idx = which(df$ID == x); ifelse(length(idx) > 0, df$FROH_HIQUAL[idx], NA)}, df = histmeta))

allcomb$FROH_BEST <- NA
for (i in 1:nrow(allcomb)) {
	id <- allcomb$ID[i]
	pop <- meta$pop[which(meta$LAB_ID == id)]
	if (pop == "Contemporary") {
		allcomb$FROH_BEST[i] <- allcomb$FROH_CONTEMPORARY_CR_AF[i]
	} else if (pop == "Resident") {
		allcomb$FROH_BEST[i] <- allcomb$FROH_RESIDENT_CR_AF[i]
	} else if (pop == "SITE_13") {
		allcomb$FROH_BEST[i] <- allcomb$FROH_SITE13_AF[i]
	} else if (pop == "SITE_1" || pop == "SITE_12" || pop == "SITE_18" || pop == "TEXACO") {
		allcomb$FROH_BEST[i] <- allcomb$FROH_DONOR_AF[i]
	} else if (pop == "Golden_Aster_Scrub" || pop == "Brigman" || pop == "W.Balm" || pop == "Duette_headwaters" || pop == "Sun_City") {
		allcomb$FROH_BEST[i] <- allcomb$FROH_HISTORIC_METAPOP_AF[i]
	} else {
		stop(paste0("Unknown population ",pop))
	}
}

allcomb <- allcomb[,c(1,8,3:7,2)]

# write combined results
#write.table(allcomb, file='/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/estimates/froh/mosaic_collated_froh.txt', col.names=TRUE, row.names=FALSE, sep="\t", quote=FALSE)

--- end R code ---

## Statistical tests comparing FROH distributions betwen groups

Froh tests for the paper used only the subsets of individuals for which all pairwise relatedness was below 0.4.

--- start R code ---

fdf <- read.table('/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/estimates/froh/mosaic_collated_froh.txt',head=TRUE)

contemp.unrelate <- read.table('/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/inputs/contemporary_cr_relatedness_maxr0.4_ids.txt',head=FALSE)$V1 # this is the same as all conetmporary individuals because none had r > 0.4
res.unrelate <- read.table('/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/inputs/resident_cr_relatedness_maxr0.4_ids.txt',head=FALSE)$V1
res.all <- read.table('/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/inputs/resident_cr_ids.txt',head=FALSE)$V1
donors.all <- read.table('/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/inputs/donor_pops_ids.txt',head=FALSE)$V1
trans.all <- donors.all[-which(donors.all == "T_072")] # all translocated individuals
donors.unrelated <- read.table('/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/inputs/donor_pops_relatedness_maxr0.4_ids.txt',head=FALSE)$V1
trans.unrelated <- donors.unrelated[-which(donors.unrelated == "T_072")] # translocated individuals with no first degree relatives

## froh are not normally distributed

shapiro.test(fdf$FROH_BEST[which(fdf$ID %in% contemp.unrelate == TRUE)])
#
#	Shapiro-Wilk normality test
#
#data:  fdf$FROH_BEST[which(fdf$ID %in% contemp.unrelate == TRUE)]
#W = 0.8966, p-value = 0.009531

shapiro.test(fdf$FROH_BEST[which(fdf$ID %in% res.unrelate == TRUE)])
#
#	Shapiro-Wilk normality test
#
#data:  fdf$FROH_BEST[which(fdf$ID %in% res.unrelate == TRUE)]
#W = 0.69944, p-value = 0.0003645

shapiro.test(fdf$FROH_BEST[which(fdf$ID %in% trans.unrelated == TRUE)])
#
#	Shapiro-Wilk normality test
#
#data:  fdf$FROH_BEST[which(fdf$ID %in% trans.unrelated == TRUE)]
#W = 0.75867, p-value = 0.001137


## test for differences in the distributions of froh

# contemporary versus resident CR indivdiuals after removing first degree relatives (r > 0.4)
wilcox.test(x=fdf$FROH_BEST[which(fdf$ID %in% contemp.unrelate == TRUE)], y=fdf$FROH_BEST[which(fdf$ID %in% res.unrelate == TRUE)], alternative="two.sided")
#
#	Wilcoxon rank sum exact test
#
#data:  fdf$FROH_BEST[which(fdf$ID %in% contemp.unrelate == TRUE)] and fdf$FROH_BEST[which(fdf$ID %in% res.unrelate == TRUE)]
#W = 273, p-value = 0.04018
#alternative hypothesis: true location shift is not equal to 0

# Contemporary CR versus translocated individuals after removing first degree relatives (r > 0.4)
wilcox.test(x=fdf$FROH_BEST[which(fdf$ID %in% contemp.unrelate == TRUE)], y=fdf$FROH_BEST[which(fdf$ID %in% trans.unrelated == TRUE)], alternative="two.sided")
#
#	Wilcoxon rank sum exact test
#
#data:  fdf$FROH_BEST[which(fdf$ID %in% contemp.unrelate == TRUE)] and fdf$FROH_BEST[which(fdf$ID %in% trans.unrelated == TRUE)]
#W = 283, p-value = 0.06421
#alternative hypothesis: true location shift is not equal to 0

# resident CR versus translocated individuals after removing first degree relatives (r > 0.4)
wilcox.test(x=fdf$FROH_BEST[which(fdf$ID %in% res.unrelate == TRUE)], y=fdf$FROH_BEST[which(fdf$ID %in% trans.unrelated == TRUE)], alternative="two.sided")
#
#	Wilcoxon rank sum exact test
#
#data:  fdf$FROH_BEST[which(fdf$ID %in% res.unrelate == TRUE)] and fdf$FROH_BEST[which(fdf$ID %in% trans.unrelated == TRUE)]
#W = 99, p-value = 0.8132
#alternative hypothesis: true location shift is not equal to 0

## Calculate Froh summary stats for groups of individuals

# All (same as subset with r <= 0.4) Contemporary CR
mean(fdf$FROH_BEST[which(fdf$ID %in% contemp.unrelate == TRUE)])
#[1] 0.09776112
sd(fdf$FROH_BEST[which(fdf$ID %in% contemp.unrelate == TRUE)])
#[1] 0.04031343
range(fdf$FROH_BEST[which(fdf$ID %in% contemp.unrelate == TRUE)])
#[1] 0.04617017 0.23007078

# Resident CR subset with r <= 0.4
mean(fdf$FROH_BEST[which(fdf$ID %in% res.unrelate == TRUE)])
#[1] 0.08342186
sd(fdf$FROH_BEST[which(fdf$ID %in% res.unrelate == TRUE)])
#[1] 0.05677626
range(fdf$FROH_BEST[which(fdf$ID %in% res.unrelate == TRUE)])
#[1] 0.0386152 0.2439435

# All resident CR
mean(fdf$FROH_BEST[which(fdf$ID %in% res.all == TRUE)])
#[1] 0.08915113
sd(fdf$FROH_BEST[which(fdf$ID %in% res.all == TRUE)])
#[1] 0.05549573
range(fdf$FROH_BEST[which(fdf$ID %in% res.all == TRUE)])
#[1] 0.0386152 0.2439435

# Translocated subset with r <= 0.4
mean(fdf$FROH_BEST[which(fdf$ID %in% trans.unrelated == TRUE)])
#[1] 0.08030449
sd(fdf$FROH_BEST[which(fdf$ID %in% trans.unrelated == TRUE)])
#[1] 0.0413815
range(fdf$FROH_BEST[which(fdf$ID %in% trans.unrelated == TRUE)])
#[1] 0.04389309 0.20818305

# All translocated
mean(fdf$FROH_BEST[which(fdf$ID %in% trans.all == TRUE)])
#[1] 0.07140679
sd(fdf$FROH_BEST[which(fdf$ID %in% trans.all == TRUE)])
#[1] 0.03424103
range(fdf$FROH_BEST[which(fdf$ID %in% trans.all == TRUE)])
#[1] 0.03469923 0.20818305

--- end R code ---

## Froh boxplots

--- start R code ---

library(scales)

meta <- read.table('/home/tyler/Dropbox/research/jay/mosaic/metadata/M4_sequenced_FSJsamples_metadata.txt',head=TRUE,sep="\t")
frohdf <- read.table('/home/tyler/Dropbox/research/jay/mosaic/popgen/roh/estimate/froh/mosaic_collated_froh.txt',head=TRUE)

frohdf <- frohdf[match(meta$LAB_ID, frohdf$ID),] # ensure that the order of individuals matches the metadata

meta$popletter <- popletters(meta) # popletters function defined in /home/tyler/Dropbox/research/jay/mosaic/popgen/fstats/README_MOSAIC_ANALYSIS
meta$popcol <- popcolor(meta) # popcolor function defined in /home/tyler/Dropbox/research/jay/mosaic/popgen/fstats/README_MOSAIC_ANALYSIS
meta$colors <- sitecol(meta) # sitecol function defined in /home/tyler/Dropbox/research/jay/mosaic/popgen/fstats/README_MOSAIC_ANALYSIS

# define groups
groups <- meta$pop
grplevels <- c("Contemporary", "Resident", "Translocated", "M4")

groups <- replace(groups, which(groups == "Golden_Aster_Scrub" | groups == "Brigman" | groups == "W.Balm" | 
groups == "Duette_headwaters" | groups == "Sun_City"), "M4")

groups <- replace(groups, which(groups == "SITE_1" | groups == "SITE_12" | groups == "SITE_13" | 
groups == "SITE_18" | groups == "TEXACO"), "Translocated")

frohdf$group = factor(groups,levels=grplevels)

# omit T_072 (RSW-K) because this site 1 bird was not translocated and migrated to LMSP, which is outside of the Core
frohdf <- frohdf[-which(frohdf$ID == "T_072"),]
meta <- meta[-which(meta$LAB_ID == "T_072"),]

# set point type
frohdf$biopoint = biopoint(meta$pop) # biopoint function defined in /home/tyler/Dropbox/research/jay/mosaic/popgen/fstats/README_MOSAIC_ANALYSIS

max(frohdf$FROH_BEST)
#[1] 0.2478308 # max Froh - set y-limit above this

# plot

#png(file='/home/tyler/Dropbox/research/jay/mosaic/figures/Froh_distribution_pop_specific_AF.png',width=7, height=7,units='in', res=300)
h_boxplot2(x=frohdf, n=2, lev=grplevels, ylabel=expression(Individual~inbreeding~(italic(F[roh]))), pntlab=frohdf$biopoint, seed=1947, color=meta$popcol, ylim=c(0,0.26))
#dev.off()

# make plot with IDs as points
#pdf(file='/home/tyler/Dropbox/research/jay/mosaic/figures/Froh_distribution_pop_specific_AF_text.pdf',width=7, height=7)
h_boxplot2(x=frohdf, n=2, lev=grplevels, ylabel=expression(Individual~inbreeding~(italic(F[roh]))), pntlab=NULL, seed=1947, color=meta$popcol, ylimits=c(0,0.26), idlabels=frohdf$ID)

# zoom in to better distinguish IDs
h_boxplot2(x=frohdf, n=2, lev=grplevels, ylabel=expression(Individual~inbreeding~(italic(F[roh]))), pntlab=NULL, seed=1947, color=meta$popcol, ylimits=c(0,0.15), idlabels=frohdf$ID)

#dev.off()

--- end R code ---


## ---------- PRINCIPAL COMPONENT ANALYSIS ---------- ##

# Estimate genetic covariance among all individuals

Calculate genotype posterior probabilities using a HWE prior.

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/popgen/genotypes/genotype_post_prob.sh
implements:

--- start bash code ---

BAMLIST='/mnt/research/Fitz_Lab/projects/mosaic/map/mosaic_bam_list.txt'
REGFILE='/mnt/research/Fitz_Lab/ref/bird/FSJ_V3/FSJ_V3_main_autosomes.txt'
SITESFILE='/mnt/research/Fitz_Lab/projects/mosaic/variants/vcf/biallelic_snps/fsj_mosaic_biallelic_snps_main_autosomes_qc.pos'
OUTPREFIX='/mnt/research/Fitz_Lab/projects/mosaic/popgen/genotypes/fsj_mosaic_biallelic_snps_main_autosomes_qc_all'

angsd -bam $BAMLIST -out $OUTPREFIX -GL 1 -doGeno 32 -doPost 1 -doMajorMinor 1 -doMaf 1 -minQ 20 -minMapQ 20 -rf $REGFILE -sites $SITESFILE -P 16

--- end bash code ---

Estimate genetic covariance based on genotype posterior probabilities and using a 2% MAF cutoff.

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/popgen/pca/covar_mat_unweighted.sh
implements:

--- start bash code ---

GENOFILE='/mnt/research/Fitz_Lab/projects/mosaic/popgen/genotypes/fsj_mosaic_biallelic_snps_main_autosomes_qc_all.geno'
OUTPUT='/mnt/research/Fitz_Lab/projects/mosaic/popgen/pca/fsj_mosaic_biallelic_snps_main_autosomes_qc_all_unweighted.covar'

CMD="ngsCovar -probfile $GENOFILE -outfile $OUTPUT -nind 87 -nsites 2049176 -norm 0 -call 0 -minmaf 0.02"

printf "\n%s\n\n" "$CMD"

eval $CMD

--- end bash code ---

Calculate eigen vectors and values and visualize PCA

--- start R code ---

# read in covariance matrix and perform eigen decomposition on it

covar <- as.matrix(read.table('/home/tyler/Dropbox/research/jay/mosaic/popgen/pca/fsj_mosaic_biallelic_snps_main_autosomes_qc_all_unweighted.covar',head=FALSE))
eig <- eigen(covar) # PCs
var <- round((eig$values/sum(eig$values))*100, digits=2) # variance explained by PCs

# set plotting values

meta <- read.table('/home/tyler/Dropbox/research/jay/mosaic/metadata/M4_sequenced_FSJsamples_metadata.txt',head=TRUE,sep="\t")
meta$letter_code <- pointletters(meta)
meta$grpcol <- pntcol(meta)
meta$popcode <- popletters(meta)
meta$popcol <- popcolor(meta)

# Add color band IDs to metadata data.frame
jayid <- read.csv('/home/tyler/Dropbox/research/jay/mosaic/metadata/jayid_map_20230512.txt',head=TRUE,sep="\t") # this is just a data.frame to map between USFWS, color band, and Fitz Lab IDs
meta$COLOR_ID = unname(sapply(meta$LAB_ID,function(x,df){id=df$COLOR_ID[which(df$LAB_ID == x)]; ifelse(id=="*",x,id)},df=jayid)) # uses M4 Fitz Lab IDs since the M4 birds don't have color IDs

# visualize PCAs

# The following PCAs were just used as exploratory analyses (not for final figures/results)

# plot PCA using type (i.e. E, C, T, I, M4) text as points and colored by type
#pdf(file='/home/tyler/Dropbox/research/jay/mosaic/popgen/pca/plots/mosaic_fsj_locality_colors2_print.pdf',width=8,height=8)
i = 1
while (i < 7) {
	j = i+1
	par(mar=c(5.1,4.1,4,2)+0.1)
	plot(x=eig$vectors[,i], y=eig$vectors[,j], xlab=paste0("PC",i,", ",var[i],"%"), ylab=paste0("PC",j,", ",var[j],"%"), type="n", cex.axis=1.4, cex.lab=1.4)
	text(x=eig$vectors[,i],y=eig$vectors[,j], labels = meta$letter_code, col=meta$grpcol, cex=1.2)
	if (i == 1) legend('topleft',fill=c(meta$grpcol[which(meta$type == "E")[1]], meta$grpcol[which(meta$type == "C")[1]], meta$grpcol[which(meta$type == "T")[1]], meta$grpcol[which(meta$type == "M4")[1]], meta$grpcol[which(meta$type == "I")[1]]), c("E","C","T","M4","U"),bty="n", horiz=TRUE, cex=1.3)
	i = i+2
}
#dev.off()

# plot PCA using individual Fitz Lab ID text as points colored by population
#pdf(file='/home/tyler/Dropbox/research/jay/mosaic/popgen/pca/plots/mosaic_fsj_individual_popcol.pdf',width=8,height=8)
i = 1
while (i < 13) {
        j = i+1
        plot(x=eig$vectors[,i], y=eig$vectors[,j], xlab=paste0("PC",i,", ",var[i],"%"), ylab=paste0("PC",j,", ",var[j],"%"), type="n")
        #text(x=eig$vectors[,i],y=eig$vectors[,j], labels = meta$LAB_ID, col=meta$grpcol, cex=0.6) # group coloring
        text(x=eig$vectors[,i],y=eig$vectors[,j], labels = meta$LAB_ID, col=meta$popcol, cex=0.6) # pop coloring
        #if (i == 1) legend('topleft',fill=c(meta$grpcol[which(meta$type == "E")[1]], meta$grpcol[which(meta$type == "C")[1]], meta$grpcol[which(meta$type == "T")[1]], meta$grpcol[which(meta$type == "M4")[1]], meta$grpcol[which(meta$type == "I")[1]]), c("E","C","T","M4","I"),bty="n", horiz=TRUE, cex=0.8)
        i = i+2
}
#dev.off()

# plot PCA using population code text colored by population
idx.wellfield = which(meta$pop == "Resident" | meta$pop == "Contemporary")
#pdf(file='/home/tyler/Dropbox/research/jay/mosaic/popgen/pca/plots/mosaic_fsj_pop.pdf',width=8,height=8)
i=1
while (i < 13) {
	j = i+1
	par(mar=c(5.1,4.1,4,2)+0.1)
	plot(x=eig$vectors[,i], y=eig$vectors[,j], xlab=paste0("PC",i,", ",var[i],"%"), ylab=paste0("PC",j,", ",var[j],"%"), type="n", cex.axis=1.4, cex.lab=1.4)
	# text is added in two steps just so that wellfield points are on top
	text(x=eig$vectors[-idx.wellfield,i],y=eig$vectors[-idx.wellfield,j], labels = meta$popcode[-idx.wellfield], col=meta$popcol[-idx.wellfield], cex=1.2)
	text(x=eig$vectors[idx.wellfield,i],y=eig$vectors[idx.wellfield,j], labels = meta$popcode[idx.wellfield], col=meta$popcol[idx.wellfield], cex=1.2)
	i = i+2
}
#dev.off()

# plot amount of variance explained by each PC
#pdf(file='/home/tyler/Dropbox/research/jay/mosaic/popgen/pca/plots/mosaic_fsj_pca_variance_explained.pdf',width=7,height=7)
n = length(eig$vector[,1])
for (i in 0:2) {
	barplot(var,ylab="% variance explained", xlab="PCs", names.arg=1:n,col=c(rep("gray",i*2),rep("plum4",2),rep("gray",n-(2*(i+1)))))
}
#dev.off()

# The following PCA was used for finalized inferences.

# Plot PC1 vs PC2 with individuals labeled according to biological origin. This is the PCA displayed in the paper.

meta$biopoint <- biopoint(meta$pop)
rswk.idx = which(meta$COLOR_ID == "RSW-K")
#meta$biopoint[rswk.idx] <- 22 # RSW-K was from Site 1B and immigrated into Little Manatee State Park (not part of The Core and was not translocated).

pc1.scale = var[1]/var[2]
axis.height = 8
axis.width = axis.height * pc1.scale

# shape points
x11(width=axis.width,height=axis.height)
#png(file='/home/tyler/Dropbox/research/jay/mosaic/figures/pca_pop_colors.png',width=axis.width, height=axis.height, units='in', res=300)
par(mar=c(5.1,4.1,4,2)+0.1)
plot(x=eig$vectors[,1], y=eig$vectors[,2], xlab=paste0("PC",1,", ",var[1],"%"), ylab=paste0("PC",2,", ",var[2],"%"),cex.axis=1.4, cex.lab=1.4,
pch=meta$biopoint, col=meta$popcol, bg=alpha(meta$popcol,0.65), cex=1.7, lwd=1.2)
points(x=eig$vectors[rswk.idx,1], y=eig$vector[rswk.idx,2], pch=3, cex=1.3, col="grey20", lwd=1.5)

#dev.off()

# text points
x11(width=axis.width,height=axis.height)
#png(file='/home/tyler/Dropbox/research/jay/mosaic/figures/pca_pop_colors_text.png',width=axis.width, height=axis.height, units='in', res=300)
par(mar=c(5.1,4.1,4,2)+0.1)
plot(x=eig$vectors[,1], y=eig$vectors[,2], xlab=paste0("PC",1,", ",var[1],"%"), ylab=paste0("PC",2,", ",var[2],"%"),cex.axis=1.4, cex.lab=1.4, type="n")
text(x=eig$vectors[,1],y=eig$vectors[,2], labels = meta$COLOR_ID, col=meta$popcol, cex=0.5)

#dev.off()

--- end R code ---


## ---------- PEDIGREE SKEW ANALYSIS ---------- ##

## Generate pedigree

# Extract census data for only the core population (Mosaic Wellfield + Duette Preserve + Coker Tract) from metadata.

--- begin R code for extracting core pop individuals ---

census <- read.csv(/home/tyler/Dropbox/research/jay/mosaic/metadata/20230512_metadata/Longform_Data_05122023.tsv',head=TRUE,sep="\t")
core <- census[which(census$PROPERTY == "MW" | census$PROPERTY == "DUETTE PRESERVE" | census$PROPERTY == "COKER"),]
core.ids <- toupper(unique(core$COLOR_ID)) # unique set of IDs for birds censused in the core region
write.table(data.frame(ID=core.ids),file='/home/tyler/Dropbox/research/jay/mosaic/metadata/20230512_metadata/core_pop/core_pop_color_ids.txt',col.names=FALSE,row.names=FALSE,quote=FALSE)
write.table(core,file='/home/tyler/Dropbox/research/jay/mosaic/metadata/20230512_metadata/core_pop/Longform_Data_05122023_core.tsv',col.names=TRUE,row.names=FALSE,quote=FALSE,sep="\t")

--- end R code for extracting core pop individuals ---

# Make inputs for makePed.pl, which constructs the pedigree in ped format.

--- begin R code for formatting census data ---
census <- read.csv('/home/tyler/Dropbox/research/jay/mosaic/metadata/20230512_metadata/Longform_Data_05122023.tsv',head=TRUE,sep="\t")
census.sub <- census[which(census$Present == 1),]
write.table(census.sub[,c(1,2,3,4,5,12)],file='/home/tyler/Dropbox/research/jay/mosaic/pedigree/mosaic_census_20230512.tsv',col.names=TRUE,row.names=FALSE,sep="\t",quote=FALSE)
--- end R code for formatting census data ---

--- start bash code ---

cut -f2,3,12 /home/tyler/Dropbox/research/jay/mosaic/metadata/20230512_metadata/CUMULATIVE_NESTING_DATA_FINAL_05122023.tsv | sed -s 's/\t/,/g' > cumulative_nesting_data_20230512.csv
cut -f1,2,5,10,16,17 /home/tyler/Dropbox/research/jay/mosaic/metadata/20230512_metadata/JAYID_05122023.tsv | sed -s 's/\t/,/g' > jayid_20230512.csv

--- end bash code ---

## Expected genetic contribution based on the pedigree

# Calculate pairwise relatedness from the pedigree

Make pedigree input for nadiv R package to calculate pedigree-based relatedness.

--- start bash code ----

./makePed.pl jayid_20230512.csv cumulative_nesting_data_20230512.csv mosaic_census_20230512.tsv 2> ./troubleshoot/mosaic_ped_20230512_raw_warnings.txt > mosaic_ped_20230512_raw.csv

--- end bash code ---

Manually modified the pedigree in some instances for the following individuals per Lauren's notes:

SR-LK (1063-09904): cohort_last set to 2004 per Lauren's notes "banded as HY august 2004 and never seen again".
OK-OS (1573-41864): Did not change missing survival data as I only see it recorded in Site 18. Luaren's notes "banded June 2004 and not seen on the July 2004 census or thereafter".
GF-SG (1713-54398): set cohort and cohort_last to 2016 per Lauren's notes "banded as immigrant in 2016 and never observed on a census" and this bird nested in DP.
PF-LS (1713-82944): Did not change missing survival data per Lauren's notes "rutland bird - never on census"
GF-AS (1713-82946): Did not change missing surivial data per Lauren's notes "rutland bird - never on census"
LDZ-F (1873-26844): set cohort_last to individuals year class (2021) per Lauren's notes "banded as Hy and never seen again"
BDZ-F (1873-26845): set cohort_last to individuals year class (2021) per Lauren's notes "banded as Hy and never seen again"
WDZ-F (1873-26846): set cohort_last to individuals year class (2021) per Lauren's notes "banded as Hy and never seen again"

# Set cohort and population for translocated pedigree individuals to year of translocation and donor patch respectively.

--- begin R code for reconciling translocation with pedigree data ---

ped <- read.csv('/home/tyler/Dropbox/research/jay/mosaic/pedigree/mosaic_ped_20230512_raw.csv',head=TRUE, na.strings="*")
trans <- read.csv('/home/tyler/Dropbox/research/jay/mosaic/metadata/Translocated_Jay_Individual_Statistics.tsv',head=TRUE,sep="\t",na.strings="*")
trans$COLOR_ID[which(trans$COLOR_ID == "PK-AS")] <- "PK-OS" # Laurens notes in the cumulative nest data say that "PK-AS and PK-OS are the same bird. Did not have any more orange bands at the time of capture and replaced with azure".
trans$Donor_Patch <- gsub(" ", "_", trans$Donor_Patch)
for (i in 1:nrow(trans)) {
	id <- trans$COLOR_ID[i]
	yr <- trans$Year_Translocated[i]
	patch <- trans$Donor_Patch[i]
	idx <- which(ped$ID == id)
	if (length(idx) > 0) {
		ped$COHORT[idx] = yr
		ped$POPULATION[idx] = patch
	} else {
		print(paste0("Could not find ", id, " in pedigree"))
	}
}

# if last observation year is missing set it to the first observation year to indicate bird was censused once and never seen again
for (i in 1:nrow(ped)) {
	if (!is.na(ped$COHORT[i]) && is.na(ped$COHORT_LAST[i])) ped$COHORT_LAST[i] = ped$COHORT[i]
}

# write full M4 pedigree
write.table(ped,file='/home/tyler/Dropbox/research/jay/mosaic/pedigree/mosaic_ped_20230512.csv',col.names=TRUE,row.names=FALSE,quote=FALSE,na="*",sep=",")
write.table(ped,file='/home/tyler/Dropbox/research/jay/mosaic/pedigree/mosaic_ped_20230512.tsv',col.names=TRUE,row.names=FALSE,quote=FALSE,na="*",sep="\t")

# write core population pedigree
core <- ped[which(!is.na(ped$COHORT)),] # individuals never censused in (i.e. part of) the Core Region will have missing COHORT because this is the first time censused in the Core

write.table(core,file='/home/tyler/Dropbox/research/jay/mosaic/pedigree/cr_ped_20230512.csv',col.names=TRUE,row.names=FALSE,quote=FALSE,na="*",sep=",")
write.table(core,file='/home/tyler/Dropbox/research/jay/mosaic/pedigree/cr_ped_20230512.tsv',col.names=TRUE,row.names=FALSE,quote=FALSE,na="*",sep="\t")

--- end R code for reconciling translocation with pedigree data ---


Make additive genetic relatedness matrix based on pedigree

--- start R code for pedigree-based relatedness matrix ---

# load required packages
library(nadiv)

# read in and format pedigree
# using full M4 pedigree to account for relatdness among CR founders
ped.raw <- read.csv('/home/tyler/Dropbox/research/jay/mosaic/pedigree/mosaic_ped_20230512.csv',head=TRUE)

ped2 <- prepPed(ped.raw[,1:4], gender='SEX', check=TRUE)
ped2 <- ped2[,1:3]

# calculate additive genetic matrix
r_mat <- makeA(ped2)
r_mat2 <- as.matrix(r_mat) # convert sparse dsCMatrix into normal matrix

# ouput full m4 matrix
write.table(r_mat2,file='/home/tyler/Dropbox/research/jay/mosaic/pedigree/mosaic_ped_20230512_relatedness_matrix.txt',col.names=TRUE,row.names=FALSE,quote=FALSE)

# subset matrix down to only Core Region individuals
core <- read.table('/home/tyler/Dropbox/research/jay/mosaic/pedigree/cr_ped_20230512.tsv',head=TRUE)
core.idx <- which(colnames(r_mat2) %in% core$ID == TRUE)
r_mat.core <- r_mat2[core.idx,core.idx]
write.table(r_mat.core,file='/home/tyler/Dropbox/research/jay/mosaic/pedigree/cr_ped_20230512_relatedness_matrix.txt',col.names=TRUE,row.names=FALSE,quote=FALSE)

--- end R code for pedigree-based relatedness matrix ---


## Expected genetic contribution to 2021 cohort with relateStats

Make inputs for relateStats

--- begin R code for making relateStats inputs ---

jaymeta <- read.csv('~/Dropbox/research/jay/mosaic/metadata/20230512_metadata/JAYID_05122023.tsv',head=TRUE,sep="\t")
jaymeta$COLOR_ID <- toupper(jaymeta$COLOR_ID)
core <- read.table('~/Dropbox/research/jay/mosaic/pedigree/cr_ped_20230512.tsv',head=TRUE) # for screening individuals that were not present in the Core Region
ind.e <- data.frame(ID=c("SW-RK", "SW-OKB", "SW-LK", "SR-WK", "SW-BK", "K-SRB")) # individuals classified as Residents in the genetic data and LR in the jayID metadata


# make file of T and IE ancestors
anc1 <- data.frame(ID=jaymeta$COLOR_ID[which(jaymeta$Biological_Origin_Status == "T" | jaymeta$Biological_Origin_Status == "IE")])
anc1 <- rbind(anc1,ind.e)
anc1.core <- data.frame(ID = anc1$ID[which(anc1$ID %in% core$ID)])
write.table(anc1.core,file='/home/tyler/Dropbox/research/jay/mosaic/pedigree/relateStat_inputs/CR_T_IE_ancestors_20230512.txt',col.names=FALSE,row.names=FALSE,quote=FALSE)

# make file of sequenced contemporary color band IDs

seqmeta <- read.table('~/Dropbox/research/jay/mosaic/metadata/M4_sequenced_FSJsamples_metadata.txt',head=TRUE,sep="\t")
c_seq_ids <- unname(sapply(seqmeta$USFWS_ID[which(seqmeta$pop == "Contemporary")],function(x,df){df$COLOR_ID[which(df$FEDERAL_ID == x)]},df=jaymeta))
write.table(data.frame(id=c_seq_ids),file='/home/tyler/Dropbox/research/jay/mosaic/pedigree/relateStat_inputs/CR_sequenced_contemporary_ids_20230512.txt',col.names=FALSE,row.names=FALSE,quote=FALSE)

# make files of local recruits (LR) by year class
jaymeta$YEAR_CLASS[which(jaymeta$YEAR_CLASS == "Unknown_Adult" | jaymeta$YEAR_CLASS == "unknown" | jaymeta$YEAR_CLASS == "*")] <- NA # mask unknown year classes
jaymeta$YEAR_CLASS <- as.numeric(jaymeta$YEAR_CLASS)
lr <- jaymeta[which(jaymeta$Biological_Origin_Status == "LR"),] # subset of local recruits
lr <- lr[which(lr$Natal_Patch == "MW" | lr$Natal_Patch == "DP" | lr$Natal_Patch == "COKER"),] # ensure all individuals were born in Core Region
lr <- lr[-grep("UNBAND|MWUUNB",lr$COLOR_ID),] # remove unbanded individuals

for (i in min(lr$YEAR_CLASS,na.rm=TRUE):max(lr$YEAR_CLASS,na.rm=TRUE)){
	id <- lr$COLOR_ID[which(lr$YEAR_CLASS == i)]
	if (length(id) > 0 ) {
		write.table(data.frame(ID=id),file=paste0('/home/tyler/Dropbox/research/jay/mosaic/pedigree/relateStat_inputs/CR_LR_ids_20230512_',i,'.txt'),col.names=FALSE,row.names=FALSE,quote=FALSE)
	}
}

--- end R code for making relateStats inputs ---

NOTE: All of the following samples (except RSW-K) considered residents in the genetic analyses were missing among the T, IE, and I ancestors so 
were manually added to the ancestors list file: /home/tyler/Dropbox/research/jay/mosaic/pedigree/relateStat_inputs/CR_T_IE_ancestors_20230512.txt.

SW-RK (LR)
SW-OKB (LR)
SW-LK (LR)
SR-WK (LR)
SW-BK (LR)
K-SRB (LR)
RSW-K (Donor Population, T_072 in the genetic data) was not translocated into the Core Region. This bird was from Site 1B and immigrated into Little Manatee State Park (which is not part of the Core)

## Calculate expected genetic contributions from Mosaic pedigree with relateStats

Abbreviations:
T = translocated.
IE = AHY bird banded in Mosaic Wellfield in 2002 prior to translocations (residents).
I = unbanded (excluded from skew analyses).

Calculate contribution of T and IE ancestors to population from 2002 (oldest cohort) to 2022 (most recent cohort).

--- start bash code ---

for i in {2002..2022}; do echo "$i"; ~/code_projects/PopGenomicsTools/relateStats --pedstat 1 --ped cr_ped_20230512.tsv --rmat cr_ped_20230512_relatedness_matrix.txt --anc ./relateStat_inputs/CR_T_IE_ancestors_20230512.txt --time2 "$i" --draw --out "./results/pop_temporal/T_IE_20230512_${i}_pop_contribution" 2> "./results/pop_temporal/T_IE_20230512_${i}_pop_contribution.log"; wait; done

--- end bash code ---

Calculate contribution of T and IE ancestors to local recruits born in 2004 (first local recruit) to 2022 (latest local recruit cohort).

--- start bash code ---

for i in {2004..2022}; do COHORT_FILE="./relateStat_inputs/CR_LR_ids_20230512_${i}.txt"; echo "$COHORT_FILE"; ~/code_projects/PopGenomicsTools/relateStats --pedstat 1 --ped cr_ped_20230512.tsv --rmat cr_ped_20230512_relatedness_matrix.txt --anc ./relateStat_inputs/CR_T_IE_ancestors_20230512.txt --cohort "$COHORT_FILE" --draw --out "./results/lr_temporal/T_IE_20230512_to_${i}_LR_contribution" 2> "./results/lr_temporal/T_IE_20230512_to_${i}_LR_contribution.log"; wait; done

--- end bash code ---

Calculate contribution of T and IE ancestors to sequenced contemporary individuals.

--- start bash code ---

$ ~/code_projects/PopGenomicsTools/relateStats --pedstat 1 --ped cr_ped_20230512.tsv --rmat cr_ped_20230512_relatedness_matrix.txt --anc ./relateStat_inputs/CR_T_IE_ancestors_20230512.txt --cohort ./relateStat_inputs/CR_sequenced_contemporary_ids_20230512.txt --draw --out ./results/sequenced_contemporary/T_IE_20230512_to_seq_contemporary 2> ./results/sequenced_contemporary/T_IE_20230512_to_seq_contemporary.log

--- end bash code ---

## ---------- SKEW ANALYSIS WITH GENOMIC DATA ---------- ##

## Calculate genetic skew (K) statistic for all sequenced translocated and resident individuals with respect to the contemporary sample with --background_r set to the 95th quantile 
## for relatedness between resident CR and translocated individuals (0.0243058).

--- begin R code for subsetting genetic relatedness matrix ---

rmat <- as.matrix(read.table('/home/tyler/Dropbox/research/jay/mosaic/popgen/relatedness/fsj_mosaic_biallelic_snps_main_autosomes_qc_relatedness_matrix_relateStats_input.txt', head=TRUE))
idmap <- read.csv('/home/tyler/Dropbox/research/jay/mosaic/metadata/jayid_map_20230512.txt',head=TRUE,sep="\t")
core <- read.table('/home/tyler/Dropbox/research/jay/mosaic/pedigree/cr_ped_20230512.tsv',head=TRUE)
core.anc <- read.table('/home/tyler/Dropbox/research/jay/mosaic/pedigree/relateStat_inputs/CR_T_IE_ancestors_20230512.txt',head=FALSE) # T, IE
colnames(rmat) <- toupper(unname(sapply(colnames(rmat),function(x,df){df$COLOR_ID[which(df$LAB_ID == x)]},df=idmap))) # convert relatedness IDs to COLOR_IDs
idx <- which(colnames(rmat) %in% core$ID)
rmat.sub <- rmat[idx,idx]
seq.ids <- colnames(rmat)

# write relatedness matrix containing only Core Region individuals
write.table(rmat.sub,file='/home/tyler/Dropbox/research/jay/mosaic/popgen/relatedness/fsj_mosaic_biallelic_snps_main_autosomes_qc_relatedness_matrix_relateStats_input_CR.txt',col.names=TRUE,row.names=FALSE,quote=FALSE)

# Make list of sequenced T and IE ancestors and contemporary individuals
write.table(data.frame(ID=seq.ids[which(seq.ids %in% core.anc$V1)]),file='/home/tyler/Dropbox/research/jay/mosaic/popgen/relatedness/CR_T_IE_sequenced.txt',col.names=FALSE,row.names=FALSE,quote=FALSE)

--- end R code for subsetting genetic relatedness matrix ---

Calculate skew statistic for CR T and IE individuals

--- start bash code ---

./PopGenomicsTools/relateStats --skewstat 3 --rmat fsj_mosaic_biallelic_snps_main_autosomes_qc_relatedness_matrix_relateStats_input_CR.txt --anc CR_T_IE_sequenced.txt --cohort /home/tyler/Dropbox/research/jay/mosaic/pedigree/relateStat_inputs/CR_sequenced_contemporary_ids_20230512.txt --background_r 0.0243058 --out ./skew/CR_T_IE_to_C_contributions_c0.0243058

--- end bash code ---

## Plot of average rank-weighted skew distribution

--- begin R code for plotting individual average rank-weighted skew distribution ---

library(scales)

kstat <- read.table('/home/tyler/Dropbox/research/jay/mosaic/popgen/relatedness/skew/CR_T_IE_to_C_contributions_c0.0243058.skewstat3',head=TRUE)
meta <- read.table('/home/tyler/Dropbox/research/jay/mosaic/metadata/M4_sequenced_FSJsamples_metadata.txt',head=TRUE,sep="\t")
idmap <- read.csv('/home/tyler/Dropbox/research/jay/mosaic/metadata/jayid_map_20230512.txt',head=TRUE,sep="\t")
meta$popcol <- popcolor(meta)
meta$COLOR_ID <- unname(sapply(meta$LAB_ID,function(x,df){df$COLOR_ID[which(df$LAB_ID == x)]},df=idmap))
meta$COLOR_ID[which(meta$COLOR_ID == "*")] <- NA

# nonparametric measure of skew
npskew = (mean(kstat$Swtr) - median(kstat$Swtr))/sd(kstat$Swtr)
npskew
#[1] 0.252958

kstat.sort <- kstat[order(-kstat$Swtr),] # sort data.frame by descending skew statistics

# plot genetic skew statistic, K
# png(file='/home/tyler/Dropbox/research/jay/mosaic/figures/k_statistic_distribution_v2.png',width=9, height=7, units='in', res=300) # use italics in axis titles
X11(width=9,height=7)
par(mar=c(5,5.2,4,2)+0.1)
plot(x=1:nrow(kstat.sort), y=kstat.sort$Swtr, type="l", lwd=4, col="grey60", ylab = expression(paste("Average weighted relatedness (", italic("K"), ")")), xlab="", xaxt='n',cex.lab=1.6, cex.axis=1.4) # v2
axis(1, at=1:nrow(kstat.sort), labels=kstat.sort$ID,cex=1.2,las=2)
# add points
pointcols = meta$popcol[sapply(kstat.sort$ID,function(x,df){which(df$COLOR_ID == x)},df=meta, USE.NAMES=FALSE)]
points(x=1:nrow(kstat.sort), y=kstat.sort$Swtr, pch=19, col=alpha(pointcols,0.8), cex=1.7)
# add vertical bars
lh = kstat.sort$Swtr
lines(x=1:nrow(kstat.sort), y=lh, type="h", lwd=13.5, col=alpha(pointcols,0.4))
# add point outlines
points(x=1:nrow(kstat.sort), y=kstat.sort$Swtr, pch=1, col=pointcols, cex=1.7, lwd=1.7)

#dev.off()

--- end R code for plotting individual average rank-weighted skew distribution ---

## Plots of expected genetic contribution through time to population - TL TODO

--- begin R code for T and IE temporal contributions to population ---

library(scales) # for alpha colors
library(ggplot2)

meta <- read.table("/home/tyler/Dropbox/research/jay/mosaic/metadata/jayid_map_20230512.txt",head=TRUE,sep="\t")
fdir='/home/tyler/Dropbox/research/jay/mosaic/pedigree/results/pop_temporal/'
ped <- read.table('/home/tyler/Dropbox/research/jay/mosaic/pedigree/cr_ped_20230512.tsv', head=TRUE, na.strings='*')

pop.n <- NULL # data frame of number of expected genomic copies
pop.pfocal <- NULL # data frame of contributions normalized by focal ancestors
pop.pmax <- NULL # data frame of contribution normalized by max cohort pop contribution

# read in pedstat files for time points 2002-2022

time.periods = 2002:2022

# subset time periods for plots that follow so that they span years 2003-2022 (exclude 2002)
time.periods2 <- time.periods[2:length(time.periods)]

tidx <- 2:(length(time.periods)+1) # these are the contribution columns in matrix
id <- NULL
for (t in time.periods) {
	df <- read.table(paste0(fdir,'T_IE_20230512_',t,'_pop_contribution.pedstat1'),head=TRUE)
	if (is.null(id)) id <- df[,1]
	pop.n <- cbind(pop.n, df[,2])
	pop.pfocal <- cbind(pop.pfocal, df[,3])
	pop.pmax <- cbind(pop.pmax, df[,4])
}

# mask values of individuals if they weren't born
ped.sub <- ped[which(ped$ID %in% id),c(1,5)]
ped.sub <- ped.sub[match(id,ped.sub$ID),]
for (i in 1:length(time.periods)) {
	t = time.periods[i]
	idx <- which(ped.sub$COHORT > t)
	if (length(idx) > 0) {
		pop.n[idx,i] <- NA
		pop.pfocal[idx,i] <- NA
		pop.pmax[idx,i] <- NA	
	}
}

# NOTE: Recalculating proportions here such that they sum to 1 because KRS- and SR-PK sired translocated individuals
# prior to arriving in the Wellfield in 2005 and 2009, respectively. Counting contributions AFTER existing in 
# the CR makes the total contribution of ancestors <1. Therefore, resumming to count only the contributions
# of individuals after they arrive in the CR (after masking has been applied). Total ancestor contribution will now be 1.

for (i in 1:ncol(pop.pfocal)) {
	pop.pfocal[,i] <- pop.pfocal[,i]/sum(pop.pfocal[,i], na.rm=TRUE)
}

#
#


pop.n <- cbind(data.frame(ID=id),as.data.frame(pop.n)) # add sample names
colnames(pop.n) <- c("ID",paste0("cohort.",time.periods))

pop.pfocal <- cbind(data.frame(ID=id),as.data.frame(pop.pfocal)) # add sample names
colnames(pop.pfocal) <- c("ID",paste0("cohort.",time.periods))

pop.pmax <- cbind(data.frame(ID=id),as.data.frame(pop.pmax)) # add sample names
colnames(pop.pmax) <- c("ID",paste0("cohort.",time.periods))

# proportion with respect to focal ancestors plot

# get ID of top contributors to 2022 cohort
id.sort <- pop.pfocal$ID[order(-pop.pfocal$cohort.2022)] # individuals ordered by contribution in 2022
pop.pfocal$rank.2022 <- match(pop.pfocal$ID,id.sort)

#> id.sort[1:16]
# [1] "RLS-K" "WSA-K" "K-SLA" "OK-RS" "SK-RG" "BK-FS" "K-RSW" "K-SBF" "SR-PK"
# [10] "BK-LS" "K-GSW" "WSF-K" "LK-SG" "BK-AS" "WK-LS" "F-BPS"

# set colors for individuals (lines) of interest: top 16 contributors to 2022 population, which contributed over 75% of ancestry since 2015.
pop.pfocal$color <- "gray30"
pop.pfocal$color[which(pop.pfocal$ID == "RLS-K")] <- "red3"
pop.pfocal$color[which(pop.pfocal$ID == "WSA-K")] <- "blue1"
pop.pfocal$color[which(pop.pfocal$ID == "K-SLA")] <- "cyan"
pop.pfocal$color[which(pop.pfocal$ID == "OK-RS")] <- "steelblue1"
pop.pfocal$color[which(pop.pfocal$ID == "SK-RG")] <- "darkorange"
pop.pfocal$color[which(pop.pfocal$ID == "BK-FS")] <- "indianred4"
pop.pfocal$color[which(pop.pfocal$ID == "K-RSW")] <- "peru"
pop.pfocal$color[which(pop.pfocal$ID == "K-SBF")] <- "tan"
pop.pfocal$color[which(pop.pfocal$ID == "SR-PK")] <- "purple"
pop.pfocal$color[which(pop.pfocal$ID == "BK-LS")] <- "mediumpurple1"
pop.pfocal$color[which(pop.pfocal$ID == "K-GSW")] <- "plum2"
pop.pfocal$color[which(pop.pfocal$ID == "WSF-K")] <- "magenta"
pop.pfocal$color[which(pop.pfocal$ID == "LK-SG")] <- "deeppink3"
pop.pfocal$color[which(pop.pfocal$ID == "BK-AS")] <- "hotpink"
pop.pfocal$color[which(pop.pfocal$ID == "WK-LS")] <- "darkmagenta"
pop.pfocal$color[which(pop.pfocal$ID == "F-BPS")] <- "darkblue"

# set line width for top 16 contributors to 2022
pop.pfocal$lw <- 1
pop.pfocal$lw[which(pop.pfocal$ID == "RLS-K")] <- 2
pop.pfocal$lw[which(pop.pfocal$ID == "WSA-K")] <- 2
pop.pfocal$lw[which(pop.pfocal$ID == "K-SLA")] <- 2
pop.pfocal$lw[which(pop.pfocal$ID == "OK-RS")] <- 2
pop.pfocal$lw[which(pop.pfocal$ID == "SK-RG")] <- 2
pop.pfocal$lw[which(pop.pfocal$ID == "BK-FS")] <- 2
pop.pfocal$lw[which(pop.pfocal$ID == "K-RSW")] <- 2
pop.pfocal$lw[which(pop.pfocal$ID == "K-SBF")] <- 2
pop.pfocal$lw[which(pop.pfocal$ID == "SR-PK")] <- 2
pop.pfocal$lw[which(pop.pfocal$ID == "BK-LS")] <- 2
pop.pfocal$lw[which(pop.pfocal$ID == "K-GSW")] <- 2
pop.pfocal$lw[which(pop.pfocal$ID == "WSF-K")] <- 2
pop.pfocal$lw[which(pop.pfocal$ID == "LK-SG")] <- 2
pop.pfocal$lw[which(pop.pfocal$ID == "BK-AS")] <- 2
pop.pfocal$lw[which(pop.pfocal$ID == "WK-LS")] <- 2
pop.pfocal$lw[which(pop.pfocal$ID == "F-BPS")] <- 2

# color below are deprecated
# set colors for individuals (lines) of interest (top 10 contributors to 2022 cohort)
#pop.pfocal$color <- "gray30" # use for top 10
#pop.pfocal$color <- "black" # use for top 3
#pop.pfocal$color[which(pop.pfocal$ID == "RLS-K")] <- "red"
#pop.pfocal$color[which(pop.pfocal$ID == "WSA-K")] <- "purple"
#pop.pfocal$color[which(pop.pfocal$ID == "K-SLA")] <- "steelblue1" # used for top 3 
#pop.pfocal$color[which(pop.pfocal$ID == "K-SLA")] <- "cyan" # used for top 10
# uncomment individuals below to denote top 10 contributors
#pop.pfocal$color[which(pop.pfocal$ID == "OK-RS")] <- "orange"
#pop.pfocal$color[which(pop.pfocal$ID == "SK-RG")] <- "magenta"
#pop.pfocal$color[which(pop.pfocal$ID == "BK-FS")] <- "royalblue1"
#pop.pfocal$color[which(pop.pfocal$ID == "K-RSW")] <- "turquoise3"
#pop.pfocal$color[which(pop.pfocal$ID == "K-SBF")] <- "palevioletred1"
#pop.pfocal$color[which(pop.pfocal$ID == "SR-PK")] <- "red4"
#pop.pfocal$color[which(pop.pfocal$ID == "BK-LS")] <- "blue"

# set line width
#pop.pfocal$lw = 1
#pop.pfocal$lw[which(pop.pfocal$ID == "RLS-K")] <- 2
#pop.pfocal$lw[which(pop.pfocal$ID == "WSA-K")] <- 2
#pop.pfocal$lw[which(pop.pfocal$ID == "K-SLA")] <- 2
# uncomment individuals below to denote top 10 contributors
#pop.pfocal$lw[which(pop.pfocal$ID == "OK-RS")] <- 2
#pop.pfocal$lw[which(pop.pfocal$ID == "SK-RG")] <- 2
#pop.pfocal$lw[which(pop.pfocal$ID == "BK-FS")] <- 2
#pop.pfocal$lw[which(pop.pfocal$ID == "K-RSW")] <- 2
#pop.pfocal$lw[which(pop.pfocal$ID == "K-SBF")] <- 2
#pop.pfocal$lw[which(pop.pfocal$ID == "SR-PK")] <- 2
#pop.pfocal$lw[which(pop.pfocal$ID == "BK-LS")] <- 2

# set line type according to resident vs translocated
pop.pfocal$ltype <- unname(sapply(id,function(x,df){df$Biological_Origin_Status}[which(df$COLOR_ID == x)],df=meta))
pop.pfocal$ltype[which(pop.pfocal$ltype == "T" | pop.pfocal$ltype == "Donor_Population")] <- 1
pop.pfocal$ltype[which(pop.pfocal$ltype == "IE" | pop.pfocal$ltype == "LR")] <- 2
pop.pfocal$ltype <- as.numeric(pop.pfocal$ltype)

# plot proportion of focal ancestor contributions over time

#pdf(file='/home/tyler/Dropbox/research/jay/mosaic/pedigree/results/pop_temporal/T_IE_20230512_pop_contributions.pdf', width=16, height=7) # deprecated
#png(file='/home/tyler/Dropbox/research/jay/mosaic/figures/T_IE_pop_contribution_pfocal.png',width=16, height=7, units='in', res=300)
#png(file='/home/tyler/Dropbox/research/jay/mosaic/figures/T_IE_pop_contribution_pfocal_v2.png',width=16, height=7, units='in', res=300)
#png(file='/home/tyler/Dropbox/research/jay/mosaic/figures/T_IE_pop_contribution_pfocal_v3.png',width=16, height=7, units='in', res=300)
#par(mgp = c(2.75,1,0))
x11(width=16,height=7)

plot(1, type="n", xlim=c(time.periods[1],time.periods[length(time.periods)]), ylim=c(0,max(pop.pfocal[,tidx],na.rm=TRUE)+0.00),
xlab="Year", ylab="Proportion ancestor contribution to population", main="",xaxt='n', cex.axis=1.3, cex.lab=1.5)
axis(side=1,at=time.periods,labels=time.periods,cex=1.5,cex.axis=1.3)

for (i in 1:nrow(pop.pfocal)) {
	# draw lines
	lines(x=time.periods, y=pop.pfocal[i,tidx],col=alpha(pop.pfocal$color[i],0.6), lty=pop.pfocal$ltype[i], lwd=pop.pfocal$lw[i])
}

# plot mean line (omitted for v3)
#lines(x=time.periods, y=sapply(tidx,function(x,df){mean(df[,x],na.rm=TRUE)},df=pop.pfocal), lty=6, col="black", lwd=2)

# add legend
#grid(nx=110, ny=50, lty=2) # for aligning things

# legend configuration 1
#legend(x=2004, y=0.2625,"Translocated",lty=1,bty='n',cex=1.3, lwd=1.7, seg.len=2.9)
#legend(x=2008, y=0.2625,"Resident",lty=2,bty='n',cex=1.3, lwd=1.7, seg.len=2.9)
#legend(x=2011.4, y=0.2625,"Mean",lty=6,bty='n',cex=1.3, lwd=1.7, seg.len=2.9)

# legend configuration 2 - works best with added nesting annotations
legend('topright',c("Translocated","Resident"),lty=c(1,2),bty='n', lwd=1.7, cex=1.3, seg.len=2.9) # v3
#legend('topright',c("Translocated","Resident","Mean"),lty=c(1,2,6),bty='n', lwd=1.7, cex=1.3, seg.len=2.9) # v2


# legend configuration 3
#legend('topleft',c("Translocated","Resident","Mean"),lty=c(1,2,6),bty='n',cex=1.3)

#dev.off()

# calculate number of ancestors present in the CR that make a genetic contribtuion to the population
anc.contributors <- NULL
for (i in 1:length(time.periods)) {
	j <- i+1
	nexist <- length(which(!is.na(pop.pfocal[,j])))
	n <- length(which(pop.pfocal[,j] > 0))
	anc.contributors <- rbind(anc.contributors, data.frame(year=time.periods[i], N=n, Percent=((n/nexist)*100),N_EXIST=nexist))
}

#> anc.contributors
#   year  N   Percent N_EXIST
#1  2002  4 100.00000       4
#2  2003 20 100.00000      20
#3  2004 29  82.85714      35
#4  2005 20  51.28205      39
#5  2006 11  28.20513      39
#6  2007 14  33.33333      42
#7  2008 27  46.55172      58
#8  2009 28  43.75000      64
#9  2010 35  47.29730      74
#10 2011 32  43.24324      74
#11 2012 32  43.24324      74
#12 2013 30  40.54054      74
#13 2014 30  40.54054      74
#14 2015 29  39.18919      74
#15 2016 29  39.18919      74
#16 2017 26  35.13514      74
#17 2018 25  33.78378      74
#18 2019 25  33.78378      74
#19 2020 25  33.78378      74
#20 2021 25  33.78378      74
#21 2022 25  33.78378      74

# plot number of contributing ancestors out of the potential number of ancestral lineages over time
anc.df <- NULL
for (i in 1:nrow(anc.contributors)) {
	anc.df <- rbind(anc.df, data.frame(year=anc.contributors$year[i], count="total", N=anc.contributors$N_EXIST[i]))
	anc.df <- rbind(anc.df, data.frame(year=anc.contributors$year[i], count="contributors", N=anc.contributors$N[i]))
}

anc.df$count <- factor(anc.df$count, levels=c("total", "contributors"))
anc.df.sub <- anc.df[which(anc.df$year > 2002),] # only plot years 2003+

# stacked area chart

#png(file='/home/tyler/Dropbox/research/jay/mosaic/figures/T_IE_population_number_ancestors_area_chart.png',width=16, height=5, units='in', res=300)
x11(width=16,height=5)

ggplot(anc.df.sub, aes(x=year, y=N, fill=count)) + 

theme_classic() +

geom_vline(xintercept=time.periods2, col="gray80", linetype="dashed") +

geom_hline(yintercept=seq(from=0,to=75,by=5),col="gray90", linetype="dashed") +

geom_area(position="identity") + 

coord_cartesian(xlim=c(2003,2022),ylim=c(0,75)) +

scale_fill_manual(values=c(alpha("gray70",0.6),alpha("gray40",0.6))) +

geom_line() +

scale_x_continuous(breaks=time.periods2) +

scale_y_continuous(name="Number ancestors", breaks=seq(from=0,to=75,by=5)) +

#scale_y_continuous(name="Number ancestors", breaks=seq(from=0,to=75,by=5), sec.axis=) + # use for one axis


theme(legend.position="none", axis.text.x = element_text(size=17,color="black"), axis.ticks.length.x=unit(0.25,"cm"), axis.title.x=element_text(size=20, color="black"),
axis.text.y = element_text(size=17,color="black"), axis.ticks.length.y=unit(0.25,"cm"),axis.title.y=element_text(size=20,color="black", vjust=1.5)) +

xlab("Year")

#dev.off()

########

#png(file='/home/tyler/Dropbox/research/jay/mosaic/figures/T_IE_pop_contribution_pfocal_barplot_2003_2022.png',width=16, height=7, units='in', res=300)
x11(width=16,height=7)
ggplot(pop.pgroup3, aes(fill=ID, y=proportion, x=year)) +

theme_classic() +

geom_bar_pattern(position="stack", stat="identity", pattern=pop.pgroup3$pattern, pattern_fill = "black", fill=pop.pgroup3$color, linewidth=0.5, color="black",
pattern_spacing = 0.012, pattern_density=0.05, pattern_size=0.45, pattern_yoffset=rep(pat.shift,nyears)) +

#geom_bar(position="stack", stat="identity", fill=pop.pgroup3$color, linewidth=0.5, color="black", width=0.83) + # for testing purposes - no pattern

theme(legend.position="none", axis.text.x = element_text(size=17, color="black",vjust=4), axis.text.y = element_text(size=17, color="black"), axis.ticks.x=element_blank(),
axis.title.x=element_text(size = 20, color="black", vjust=2), axis.title.y=element_text(size = 20, color="black",vjust=2), axis.line.x=element_blank(), axis.line.y=element_blank(),
axis.ticks.length.y=unit(0.25, "cm")) +

annotate(x=0, xend=0, y=0, yend=1, colour="black", lwd=0.75, geom="segment") +

xlab("Year") +

ylab("Proportion ancestor contribution to population")

#dev.off()

#######

# average and maximum contributions of specific lineages

# RLKS-K from 2008-2022
mean(as.matrix(pop.pfocal[which(pop.pfocal$ID == "RLS-K"),which(colnames(pop.pfocal) == "cohort.2008"):which(colnames(pop.pfocal) == "cohort.2022")])) # mean
# [1] 0.1339778 # mean
sd(as.matrix(pop.pfocal[which(pop.pfocal$ID == "RLS-K"),which(colnames(pop.pfocal) == "cohort.2008"):which(colnames(pop.pfocal) == "cohort.2022")])) # stanard deviation
# [1] 0.03263044 # standard deviation
max(as.matrix(pop.pfocal[which(pop.pfocal$ID == "RLS-K"),which(colnames(pop.pfocal) == "cohort.2008"):which(colnames(pop.pfocal) == "cohort.2022")])) # max
#[1] 0.1730849 # max

# WSA-K from 2008-2022
mean(as.matrix(pop.pfocal[which(pop.pfocal$ID == "WSA-K"),which(colnames(pop.pfocal) == "cohort.2008"):which(colnames(pop.pfocal) == "cohort.2022")])) # mean
# [1] 0.1041607 # mean
sd(as.matrix(pop.pfocal[which(pop.pfocal$ID == "WSA-K"),which(colnames(pop.pfocal) == "cohort.2008"):which(colnames(pop.pfocal) == "cohort.2022")])) # standard deviation
# [1] 0.03203001 # standard deviation
max(as.matrix(pop.pfocal[which(pop.pfocal$ID == "WSA-K"),which(colnames(pop.pfocal) == "cohort.2008"):which(colnames(pop.pfocal) == "cohort.2022")])) # max
# [1] 0.149241 # max

# mean contribution for all individuals since 2008
avg.contribution <- NULL
for (id in pop.pfocal$ID) {
	val <- mean(as.matrix(pop.pfocal[which(pop.pfocal$ID == id),which(colnames(pop.pfocal) == "cohort.2008"):which(colnames(pop.pfocal) == "cohort.2022")]), na.rm=TRUE)
	avg.contribution <- rbind(avg.contribution, data.frame(ID=id, AVG_PROPORTION=val))
}

avg.contribution <- avg.contribution[order(-avg.contribution$AVG_PROPORTION),]

#> head(avg.contribution, n=16)
#      ID AVG_PROPORTION
#44 RLS-K     0.13397785
#5  WSA-K     0.10416071
#46 OK-RS     0.05648191
#22 K-SLA     0.05161644
#60 SK-RG     0.04947236
#53 BK-FS     0.04824063
#45 BK-AS     0.04575711
#1  SR-PK     0.04531992
#8  K-RSW     0.03753052
#40 BK-LS     0.03660300
#4  WSF-K     0.03217750
#23 K-SBF     0.02936139
#14 LK-SG     0.02834174
#17 AK-SP     0.02629410
#7  K-GSW     0.02488999
#66 F-BPS     0.02471368

# average collective contribution of RLS-K and WSA-K since 2008
rlsk.idx = which(pop.pfocal$ID == "RLS-K")
wsak.idx = which(pop.pfocal$ID == "WSA-K")
comb.contribution <- NULL
for (tidx in which(colnames(pop.pfocal) == "cohort.2008"):which(colnames(pop.pfocal) == "cohort.2022")) {
	comb.contribution = c(comb.contribution,pop.pfocal[rlsk.idx,tidx] + pop.pfocal[wsak.idx,tidx])
}
mean(comb.contribution)
# [1] 0.2381386 # mean
sd(comb.contribution)
#[1] 0.06403289 # standard deviation
max(comb.contribution)
#[1] 0.322263 # max

# assess relationship between RLS-K and K-SLA
rmat <- read.table('/home/tyler/Dropbox/research/jay/mosaic/pedigree/cr_ped_20230512_relatedness_matrix.txt',head=TRUE)
rmat[which(colnames(rmat) == "RLS.K"),which(colnames(rmat) == "K.SLA")]
# [1] 0.125 # r between RLS-K and K-SLA

# find all translocated relatives of RLS-K
trans <- read.csv('/home/tyler/Dropbox/research/jay/mosaic/metadata/Translocated_Jay_Individual_Statistics.tsv',head=TRUE,sep="\t")
rlsk.relatives <- colnames(rmat)[which(rmat[which(colnames(rmat) == "RLS.K"),] > 0)]
trans.id <- gsub("-",".",trans$COLOR_ID)
rlsk.relatives.trans <- rlsk.relatives[rlsk.relatives %in% trans.id]
#> rlsk.relatives.trans
#[1] "RLS.K" "SK.RG" "SK.RB" "SK.RP" "SRR.K" "K.SAP" "K.SLA" "K.SPR" "K.SAG"

# Proportion of genomic copies contributed by the top 16 contributors in 2022

ntop = 16
# pop.pfocal row indices of the top contributors in 2022 
topidx = unname(sapply(pop.pfocal[order(-pop.pfocal$cohort.2022),1][1:ntop],function(x,df){which(df$ID == x)},df=pop.pfocal))
# calculate the sum of the top contributor's genomic contribution for each year
top.contribution <- NULL
for (i in 1:length(time.periods)) {
	top.contribution <- rbind(top.contribution, data.frame(YEAR=time.periods[i], PROPORTION_GENOMIC_COPIES = sum(pop.pfocal[topidx,i+1], na.rm=TRUE)))
}

#> top.contribution
#   YEAR PROPORTION_GENOMIC_COPIES
#1  2002                 0.2500000
#2  2003                 0.2000000
#3  2004                 0.1707317
#4  2005                 0.3076927
#5  2006                 0.4999996
#6  2007                 0.5270272
#7  2008                 0.6368874
#8  2009                 0.7583543
#9  2010                 0.6504852
#10 2011                 0.6963268
#11 2012                 0.6982892
#12 2013                 0.6773675
#13 2014                 0.7156768
#14 2015                 0.7716050
#15 2016                 0.7612648
#16 2017                 0.7900778
#17 2018                 0.8003363
#18 2019                 0.8580870
#19 2020                 0.8346470
#20 2021                 0.8618459
#21 2022                 0.8802618

# minimum contribution since 2015
min(top.contribution[which(top.contribution$YEAR == 2015):nrow(top.contribution),2])
# [1] 0.7612648

## Stacked barplot of contribution to population relative to other ancestors

# color top 10 contributors

topN = 10
grp.idx <- list()
grp.id <- NULL
member.id <- list()

for (i in id.sort[1:topN]) {
	member.id <- c(member.id, i)
	grp.id <- c(grp.id, i)
	grp.idx <- c(grp.idx, which(pop.pfocal$ID == i))
}

# get index of all other translocated and resident individuals
grp.id <- c(grp.id,"other_translocated")
grp.idx[[topN+1]] <- which(pop.pfocal$ltype == 1 & pop.pfocal$ID %in% id.sort[1:topN] == FALSE)
member.id[[topN+1]] <- pop.pfocal$ID[grp.idx[[topN+1]]]

grp.id <- c(grp.id,"other_resident")
grp.idx[[topN+2]] <- which(pop.pfocal$ltype == 2 & pop.pfocal$ID %in% id.sort[1:topN] == FALSE)
member.id[[topN+2]] <- pop.pfocal$ID[grp.idx[[topN+2]]]

# calculate proportion group contribution to population
pop.pgroup <- NULL
for (j in 2:((ncol(pop.pfocal))-4)) {
	x <- NULL
	for (i in 1:length(grp.idx)) {
		x <- c(x,sum(pop.pfocal[grp.idx[[i]],j],na.rm=TRUE))
	}
	x.df <- data.frame(x)
	if (is.null(pop.pgroup) == TRUE) pop.pgroup = x.df else pop.pgroup <- cbind(pop.pgroup, x.df)
}
colnames(pop.pgroup) <- colnames(pop.pfocal)[2:((ncol(pop.pfocal))-4)]
pop.pgroup <- cbind(data.frame(ID=grp.id),pop.pgroup)

# stacked barplot of group contributions
barcol <- c(unname(sapply(pop.pgroup$ID[1:topN],function(x,df){df$color[which(df$ID == x)]},df=pop.pfocal)), "gray40", "gray70")

#png(file='/home/tyler/Dropbox/research/jay/mosaic/figures/T_IE_pop_contribution_pfocal_barplot.png',width=16, height=7, units='in', res=300)
x11(width=16,height=7)
par(mgp = c(2.8,1,0))
barplot(as.matrix(pop.pgroup[2:ncol(pop.pgroup)]), names.arg=time.periods, border=NA, col=barcol, xlab="Year", ylab="Proportion ancestor contribution", cex.names=1.27, cex.axis=1.3, cex.lab=1.5)
#dev.off()

# alternatively, make stacked barplot where each individual is a box and color by group using gradients and distinct colors
topid <- pop.pfocal$ID[topidx] # these are the individuals that contributed >75% ancestry to the CR population since 2015
#topid
# [1] "RLS-K" "WSA-K" "K-SLA" "OK-RS" "SK-RG" "BK-FS" "K-RSW" "K-SBF" "SR-PK"
# [10] "BK-LS" "K-GSW" "WSF-K" "LK-SG" "BK-AS" "WK-LS" "F-BPS

# set groups for barplot coloring

pop.pgroup2 <- pop.pfocal[,1:22]
pop.pgroup2$biotype = unname(sapply(pop.pgroup2$ID, function(x,df){idx=which(df$COLOR_ID == x); btype=df$Biological_Origin_Status[idx];ifelse(btype == "T", "Trans", "Res")},df=meta))

pop.pgroup2$bargrp <- pop.pgroup2$biotype
pop.pgroup2$bargrp[which(pop.pgroup2$ID %in% topid == TRUE)] <- "top"

# sort by descending contribution to 2022 within groups
pop.pgroup2$bargrp <- factor(pop.pgroup2$bargrp,levels=c("top","Trans","Res"),ordered=TRUE)
pop.pgroup2 <- pop.pgroup2[order(pop.pgroup2$bargrp,-pop.pgroup2$cohort.2022),]

# color top individuals

pop.pgroup2$barcol <- pop.pfocal$ID
pop.pgroup2$barcol[which(pop.pgroup2$ID == "RLS-K")] <- "red3"
pop.pgroup2$barcol[which(pop.pgroup2$ID == "WSA-K")] <- "blue1"
pop.pgroup2$barcol[which(pop.pgroup2$ID == "K-SLA")] <- "cyan"
pop.pgroup2$barcol[which(pop.pgroup2$ID == "OK-RS")] <- "steelblue1"
pop.pgroup2$barcol[which(pop.pgroup2$ID == "SK-RG")] <- "darkorange"
pop.pgroup2$barcol[which(pop.pgroup2$ID == "BK-FS")] <- "indianred4"
pop.pgroup2$barcol[which(pop.pgroup2$ID == "K-RSW")] <- "peru"
pop.pgroup2$barcol[which(pop.pgroup2$ID == "K-SBF")] <- "tan"
pop.pgroup2$barcol[which(pop.pgroup2$ID == "SR-PK")] <- "purple"
pop.pgroup2$barcol[which(pop.pgroup2$ID == "BK-LS")] <- "mediumpurple1"
pop.pgroup2$barcol[which(pop.pgroup2$ID == "K-GSW")] <- "plum2"
pop.pgroup2$barcol[which(pop.pgroup2$ID == "WSF-K")] <- "magenta"
pop.pgroup2$barcol[which(pop.pgroup2$ID == "LK-SG")] <- "deeppink3"
pop.pgroup2$barcol[which(pop.pgroup2$ID == "BK-AS")] <- "hotpink"
pop.pgroup2$barcol[which(pop.pgroup2$ID == "WK-LS")] <- "darkmagenta"
pop.pgroup2$barcol[which(pop.pgroup2$ID == "F-BPS")] <- "darkblue"

# gradient color remaining translocated individuals
trans.col.vec = NULL
trans.col="gold2"
trans.idx <- which(pop.pgroup2$bargrp == "Trans")
step = 1/(length(trans.idx)+10)
c = 1;
for (i in trans.idx) {
	pop.pgroup2$barcol[i] <- alpha(trans.col,c)
	trans.col.vec <- c(trans.col.vec,pop.pgroup2$barcol[i])
	c = c-step
}

# gradient color for remaining resident individuals
res.col.vec = NULL
res.col="gray30"
res.idx <- which(pop.pgroup2$bargrp == "Res")
step = 1/(length(res.idx)+5)
c = 1;
for (i in res.idx) {
        pop.pgroup2$barcol[i] <- alpha(res.col,c)
	res.col.vec <- c(res.col.vec,pop.pgroup2$barcol[i])
        c = c-step
}

# convert data.frame into matrix for plotting
#pop.pgroup2.mat <- as.matrix(pop.pgroup2[,2:22])
pop.pgroup2.mat <- as.matrix(pop.pgroup2[,3:22]) # excludes 2002
pop.pgroup2.mat[which(is.na(pop.pgroup2.mat))] <- 0

# barplot
x11(width=16,height=7)
par(mgp = c(2.8,1,0))
#barplot(pop.pgroup2.mat, names.arg=time.periods, border="black", col=pop.pgroup2$barcol, xlab="Year", ylab="Proportion ancestor contribution", cex.names=1.27, cex.axis=1.3, cex.lab=1.5)
barplot(pop.pgroup2.mat, names.arg=time.periods2, border="black", col=pop.pgroup2$barcol, xlab="Year", ylab="Proportion ancestor contribution", cex.names=1.27, cex.axis=1.3, cex.lab=1.5) # exclude 2002

# gradient color box for legend

trans.col.width = seq(from=0,to=1,by=(1/length(trans.col.vec)))
res.col.width = seq(from=0,to=1,by=(1/length(res.col.vec)))

X11()
#png(file='/home/tyler/Dropbox/research/jay/mosaic/figures/T_IE_pop_contribution_pfocal_barplot_key.png', width=7, height=7, units='in', res=300)
#pdf(file='/home/tyler/Dropbox/research/jay/mosaic/figures/T_IE_pop_contribution_pfocal_barplot_key.pdf', width=7, height=7)
#plot.new()

yb = 0.1
yt = 0.3
plot(1, type="n", xlab="", ylab="", xlim=c(-0.05,1.05), ylim=c(-0.05,1.05))
for (i in 1:(length(trans.col.width)-1)) {
	xs = trans.col.width[i]
	xe = trans.col.width[i+1]
	rect(xleft=xs, xright=xe, ybottom=yb, ytop=yt, border="gray50", lwd=0.3, col=trans.col.vec[i])
}
rect(xleft=trans.col.width[1], xright=trans.col.width[length(trans.col.width)], ybottom=yb, ytop=yt, border="gray20", lwd=1, col=NA)

res.col.width = seq(from=0,to=1,by=(1/length(res.col.vec)))
yb = 0.5
yt = 0.7
for (i in 1:(length(res.col.width)-1)) {
        xs = res.col.width[i]
        xe = res.col.width[i+1]
        rect(xleft=xs, xright=xe, ybottom=yb, ytop=yt, border="gray10", lwd=0.3, col=res.col.vec[i])
}
rect(xleft=res.col.width[1], xright=res.col.width[length(res.col.width)], ybottom=yb, ytop=yt, border="gray20", lwd=1, col=NA)

#dev.off()

# ggplot stacked barplot version to accommodate pattern
library(ggpattern)

#nyears = length(time.periods)
nyears = length(time.periods2)

years.vec <- NULL
#for (i in time.periods) { years.vec <- c(years.vec,rep(i,nrow(pop.pgroup2))) }
for (i in time.periods2) { years.vec <- c(years.vec,rep(i,nrow(pop.pgroup2))) }

contribution.p = NULL
for (i in 1:ncol(pop.pgroup2.mat)) {contribution.p <- c(contribution.p, unname(pop.pgroup2.mat[,i]))}

pat <- replace(pop.pgroup2$biotype, which(pop.pgroup2$biotype == "Res"), "stripe")
pat <- replace(pat, which(pat != "stripe"), "none")

pop.pgroup3 <- data.frame(year=years.vec, ID=rep(pop.pgroup2$ID,nyears), proportion=contribution.p, color=rep(pop.pgroup2$barcol,nyears), pattern=rep(pat,nyears))
pop.pgroup3$year <- as.factor(pop.pgroup3$year) # need to do this for proper x-axis labels

pat.shift = NULL
xshift=0
pstep = 1/length(which(pat=="stripe"))
for (i in pat) {
	if (i == "stripe") {
		xshift = xshift + pstep
		pat.shift = c(pat.shift,xshift)
	} else pat.shift = c(pat.shift,0)
}

# begin plot
#png(file='/home/tyler/Dropbox/research/jay/mosaic/figures/T_IE_pop_contribution_pfocal_barplot.png',width=16, height=7, units='in', res=300)
#png(file='/home/tyler/Dropbox/research/jay/mosaic/figures/T_IE_pop_contribution_pfocal_barplot_2003_2022.png',width=16, height=7, units='in', res=300)
x11(width=16,height=7)
ggplot(pop.pgroup3, aes(fill=ID, y=proportion, x=year)) +

theme_classic() +

geom_bar_pattern(position="stack", stat="identity", pattern=pop.pgroup3$pattern, pattern_fill = "black", fill=pop.pgroup3$color, linewidth=0.5, color="black",
pattern_spacing = 0.012, pattern_density=0.05, pattern_size=0.45, pattern_yoffset=rep(pat.shift,nyears)) +

#geom_bar(position="stack", stat="identity", fill=pop.pgroup3$color, linewidth=0.5, color="black", width=0.83) + # for testing purposes - no pattern

theme(legend.position="none", axis.text.x = element_text(size=17, color="black",vjust=4), axis.text.y = element_text(size=17, color="black"), axis.ticks.x=element_blank(),
axis.title.x=element_text(size = 20, color="black", vjust=2), axis.title.y=element_text(size = 20, color="black",vjust=2), axis.line.x=element_blank(), axis.line.y=element_blank(), 
axis.ticks.length.y=unit(0.25, "cm")) +

annotate(x=0, xend=0, y=0, yend=1, colour="black", lwd=0.75, geom="segment") +

xlab("Year") +

ylab("Proportion ancestor contribution to population")

#dev.off()

# stacked area chart of contributing ancestors with individual ancestor lines (ignore warnings)

pop.pfocal$lstr <- replace(pop.pfocal$ltype,which(pop.pfocal$ltype == 1), "solid")
pop.pfocal$lstr <- replace(pop.pfocal$lstr,which(pop.pfocal$ltype == "2"), "dashed")
pop.pfocal$lw2 <- replace(pop.pfocal$lw,which(pop.pfocal$lw == 2), 0.75)
pop.pfocal$lw2 <- replace(pop.pfocal$lw2,which(pop.pfocal$lw2 == 1), 0.50)


#png(file='/home/tyler/Dropbox/research/jay/mosaic/figures/T_IE_population_number_ancestors_area_chart_v2.png',width=16, height=7, units='in', res=300)
#png(file='/home/tyler/Dropbox/research/jay/mosaic/figures/T_IE_population_number_ancestors_area_chart_v3.png',width=16, height=7, units='in', res=300) # offset x-axis title
x11(width=16,height=7)

gg.pop <- ggplot(anc.df.sub, aes(x=year, y=N, fill=count)) +

theme_classic() +

geom_area(position="identity") +

coord_cartesian(xlim=c(2003,2022),ylim=c(0,75)) +

scale_fill_manual(values=c(alpha("gray70",0.6),alpha("gray40",0.6))) +

scale_x_continuous(breaks=time.periods2) +

scale_y_continuous(name="Number ancestors", breaks=seq(from=0,to=75,by=5), sec.axis=sec_axis(~./75*prop.cutoff, name="Proportion ancestor contribution to population", 
breaks=seq(from=0,to=prop.cutoff,by=0.02), )) +

theme(legend.position="none", axis.text.x = element_text(size=17,color="black"), axis.ticks.length.x=unit(0.25,"cm"), axis.title.x=element_text(size=20, color="black", hjust=0.8),
axis.text.y = element_text(size=17,color="black"), axis.ticks.length.y=unit(0.25,"cm"),axis.title.y=element_text(size=20,color="black", vjust=1.5),
axis.title.y.right = element_text(size=20, color="black", vjust=1.5)) +

xlab("Year")

for (k in 1:nrow(pop.pfocal)) {
	tmpvec <- NULL
	for (j in 3:22) { tmpvec <- c(tmpvec,c(pop.pfocal[k,j],NA)) }
	gg.pop <- gg.pop + geom_line(aes_string(y=tmpvec*(75/prop.cutoff)), color=pop.pfocal$color[k], linetype=pop.pfocal$lstr[k], lwd=pop.pfocal$lw2[k])
}

gg.pop

#dev.off()

# proportion with respect to maximum ancestor pop contribution (Hunter normalization) plot

# get ID of top contributors to 2022 cohort
id.sort.hunter <- pop.pmax$ID[order(-pop.pmax$cohort.2022)] # individuals ordered by contribution in 2022
pop.pmax$rank.2022 <- match(pop.pmax$ID,id.sort.hunter)

#> id.sort.hunter[1:10]
# [1] "BK-LS" "RLS-K" "OK-RS" "K-RSW" "WSA-K" "K-SLA" "BK-AS" "SK-RG" "BK-FS"
#[10] "WK-LS"

# set colors for individuals (lines) of interest (top 10 contributors to 2022 cohort)
pop.pmax$color <- "gray30"
pop.pmax$color[which(pop.pmax$ID == "RLS-K")] <- "red"
pop.pmax$color[which(pop.pmax$ID == "WSA-K")] <- "purple"
pop.pmax$color[which(pop.pmax$ID == "K-SLA")] <- "cyan"
pop.pmax$color[which(pop.pmax$ID == "OK-RS")] <- "orange"
pop.pmax$color[which(pop.pmax$ID == "SK-RG")] <- "magenta"
pop.pmax$color[which(pop.pmax$ID == "BK-FS")] <- "royalblue1"
pop.pmax$color[which(pop.pmax$ID == "K-RSW")] <- "turquoise3"
pop.pmax$color[which(pop.pmax$ID == "BK-AS")] <- "yellow3"
pop.pmax$color[which(pop.pmax$ID == "BK-LS")] <- "blue"
pop.pmax$color[which(pop.pmax$ID == "WK-LS")] <- "salmon2" # individual not among top 10 in focal ancestor normalization

# set line width
pop.pmax$lw = 1
pop.pmax$lw[which(pop.pmax$ID == "RLS-K")] <- 2
pop.pmax$lw[which(pop.pmax$ID == "WSA-K")] <- 2
pop.pmax$lw[which(pop.pmax$ID == "K-SLA")] <- 2
pop.pmax$lw[which(pop.pmax$ID == "OK-RS")] <- 2
pop.pmax$lw[which(pop.pmax$ID == "SK-RG")] <- 2
pop.pmax$lw[which(pop.pmax$ID == "BK-FS")] <- 2
pop.pmax$lw[which(pop.pmax$ID == "K-RSW")] <- 2
pop.pmax$lw[which(pop.pmax$ID == "BK-AS")] <- 2
pop.pmax$lw[which(pop.pmax$ID == "BK-LS")] <- 2
pop.pmax$lw[which(pop.pmax$ID == "WK-LS")] <- 2

# set line type according to resident vs translocated
pop.pmax$ltype <- unname(sapply(id,function(x,df){df$Biological_Origin_Status}[which(df$COLOR_ID == x)],df=meta))
pop.pmax$ltype[which(pop.pmax$ltype == "T" | pop.pmax$ltype == "Donor_Population")] <- 1
pop.pmax$ltype[which(pop.pmax$ltype == "IE" | pop.pmax$ltype == "LR")] <- 2
pop.pmax$ltype <- as.numeric(pop.pmax$ltype)

# plot proportion of focal ancestor contributions over time

#png(file='/home/tyler/Dropbox/research/jay/mosaic/figures/T_IE_pop_contribution_pmax.png',width=16, height=7, units='in', res=300)
x11(width=16,height=7)
par(mgp = c(2.75,1,0))
plot(1, type="n", xlim=c(time.periods[1],time.periods[length(time.periods)]), ylim=c(0,max(pop.pmax[,tidx],na.rm=TRUE)+0.01),
xlab="Year", ylab="Proportion ancestor contribution relative to pop max", main="",xaxt='n', cex.axis=1.3, cex.lab=1.5)
axis(side=1,at=time.periods,labels=time.periods,cex=1.5,cex.axis=1.3)

for (i in 1:nrow(pop.pmax)) {
	# draw lines
	lines(x=time.periods, y=pop.pmax[i,tidx],col=alpha(pop.pmax$color[i],0.6), lty=pop.pmax$ltype[i], lwd=pop.pmax$lw[i])
}
# plot mean line
lines(x=time.periods, y=sapply(tidx,function(x,df){mean(df[,x],na.rm=TRUE)},df=pop.pmax), lty=6, col="black", lwd=2)

# add legend
legend('topleft',c("Translocated","Resident","Mean"),lty=c(1,2,6),bty='n',cex=1.3, lwd=1.7, seg.len=2.9)

#dev.off()

--- end R code for T and IE temporal contributions to population ---

--- begin R code for T, IE, and I temporal contributions to population (TODO: RERUN ON NEW DATA) ---

library(scales) # for alpha colors

meta <- read.table("/home/tyler/Dropbox/research/jay/mosaic/metadata/jayid_map_20230512.txt",head=TRUE,sep="\t")
fdir='/home/tyler/Dropbox/research/jay/mosaic/pedigree/results/pop_temporal/'
ped <- read.table('/home/tyler/Dropbox/research/jay/mosaic/pedigree/cr_ped_20230512.tsv', head=TRUE, na.strings='*')

pop.n <- NULL # data frame of number of expected genomic copies
pop.pfocal <- NULL # data frame of contributions normalized by focal ancestors
pop.pmax <- NULL # data frame of contribution normalized by max cohort pop contribution

# read in pedstat files for time points 2002-2022
time.periods = 2002:2022
tidx <- 2:(length(time.periods)+1) # these are the contribution columns in matrix
id <- NULL
for (t in time.periods) {
	df <- read.table(paste0(fdir,'T_IE_I_20230512_',t,'_pop_contribution.pedstat1'),head=TRUE)
	if (is.null(id)) id <- df[,1]
	pop.n <- cbind(pop.n, df[,2])
	pop.pfocal <- cbind(pop.pfocal, df[,3])
	pop.pmax <- cbind(pop.pmax, df[,4])
}

# mask values of individuals if they weren't born
ped.sub <- ped[which(ped$ID %in% id),c(1,5)]
ped.sub <- ped.sub[match(id,ped.sub$ID),]
for (i in 1:length(time.periods)) {
	t = time.periods[i]
	idx <- which(ped.sub$COHORT > t)
	if (length(idx) > 0) {
		pop.n[idx,i] <- NA
		pop.pfocal[idx,i] <- NA
		pop.pmax[idx,i] <- NA	
	}
}

pop.n <- cbind(data.frame(ID=id),as.data.frame(pop.n)) # add sample names
colnames(pop.n) <- c("ID",paste0("cohort.",time.periods))

pop.pfocal <- cbind(data.frame(ID=id),as.data.frame(pop.pfocal)) # add sample names
colnames(pop.pfocal) <- c("ID",paste0("cohort.",time.periods))

pop.pmax <- cbind(data.frame(ID=id),as.data.frame(pop.pmax)) # add sample names
colnames(pop.pmax) <- c("ID",paste0("cohort.",time.periods))

# proportion with respect to focal ancestors plot

# get ID of top contributors to 2022 cohort
id.sort <- pop.pfocal$ID[order(-pop.pfocal$cohort.2022)] # individuals ordered by contribution in 2022
pop.pfocal$rank.2022 <- match(pop.pfocal$ID,id.sort)

# set colors for individuals (lines) of interest (top 10 contributors to 2022 cohort)
pop.pfocal$color <- "gray30"
pop.pfocal$color[which(pop.pfocal$ID == "RLS-K")] <- "red"
pop.pfocal$color[which(pop.pfocal$ID == "WSA-K")] <- "purple"
pop.pfocal$color[which(pop.pfocal$ID == "K-SLA")] <- "cyan"
pop.pfocal$color[which(pop.pfocal$ID == "OK-RS")] <- "orange"
pop.pfocal$color[which(pop.pfocal$ID == "PK-SG")] <- "cornflowerblue"
pop.pfocal$color[which(pop.pfocal$ID == "PF-SH")] <- "darkcyan"
pop.pfocal$color[which(pop.pfocal$ID == "SK-RG")] <- "magenta"
pop.pfocal$color[which(pop.pfocal$ID == "BK-FS")] <- "royalblue1"
pop.pfocal$color[which(pop.pfocal$ID == "RF-SF")] <- "burlywood3"
pop.pfocal$color[which(pop.pfocal$ID == "K-RSW")] <- "turquoise3"

# set line type according to resident vs translocated
pop.pfocal$ltype <- unname(sapply(id,function(x,df){df$Biological_Origin_Status}[which(df$COLOR_ID == x)],df=meta))
pop.pfocal$ltype[which(pop.pfocal$ltype == "T" | pop.pfocal$ltype == "Donor_Population")] <- 1
pop.pfocal$ltype[which(pop.pfocal$ltype == "IE" | pop.pfocal$ltype == "LR")] <- 2
pop.pfocal$ltype[which(pop.pfocal$ltype == "I")] <- 3
pop.pfocal$ltype <- as.numeric(pop.pfocal$ltype)

# set line width
pop.pfocal$lw = 1
pop.pfocal$lw[which(pop.pfocal$ltype == 3)] <- 1.8 # need to increase size of dots for visibility
isize = 2.8
pop.pfocal$lw[which(pop.pfocal$ID == "RLS-K")] <- 1.8
pop.pfocal$lw[which(pop.pfocal$ID == "WSA-K")] <- 1.8
pop.pfocal$lw[which(pop.pfocal$ID == "K-SLA")] <- 1.8
pop.pfocal$lw[which(pop.pfocal$ID == "OK-RS")] <- 1.8
pop.pfocal$lw[which(pop.pfocal$ID == "PK-SG")] <- isize # immigrant
pop.pfocal$lw[which(pop.pfocal$ID == "PF-SH")] <- isize # immigrant
pop.pfocal$lw[which(pop.pfocal$ID == "SK-RG")] <- 1.8
pop.pfocal$lw[which(pop.pfocal$ID == "BK-FS")] <- 1.8
pop.pfocal$lw[which(pop.pfocal$ID == "RF-SF")] <- isize # immigrant
pop.pfocal$lw[which(pop.pfocal$ID == "K-RSW")] <- 1.8

# plot proportion of focal ancestor contributions over time

#pdf(file='/home/tyler/Dropbox/research/jay/mosaic/pedigree/results/pop_temporal/T_IE_I_20230512_pop_contributions.pdf', width=16, height=7)
x11(width=16,height=7)
par(mgp = c(2.75,1,0))
plot(1, type="n", xlim=c(time.periods[1],time.periods[length(time.periods)]), ylim=c(0,max(pop.pfocal[,tidx],na.rm=TRUE)+0.05),
xlab="Year", ylab="Proportion ancestor contribution to population", main="",xaxt='n', cex.axis=1.3, cex.lab=1.5)
axis(side=1,at=time.periods,labels=time.periods,cex=1.5,cex.axis=1.3)

for (i in 1:nrow(pop.pfocal)) {
	# draw lines
	lines(x=time.periods, y=pop.pfocal[i,tidx],col=alpha(pop.pfocal$color[i],0.6), lty=pop.pfocal$ltype[i], lwd=pop.pfocal$lw[i])
}
# plot mean line
lines(x=time.periods, y=sapply(tidx,function(x,df){mean(df[,x],na.rm=TRUE)},df=pop.pfocal), lty=6, col="black", lwd=1.8)

# add legend
legend('topleft',c("Translocated","Resident","Immigrant","Mean"),lty=c(1,2,3,6),bty='n',cex=1.2)

# proportion with respect to maximum ancestor pop contribution (Hunter normalization) plot

# get ID of top contributors to 2022 cohort
id.sort.hunter <- pop.pmax$ID[order(-pop.pmax$cohort.2022)] # individuals ordered by contribution in 2022
pop.pmax$rank.2022 <- match(pop.pmax$ID,id.sort.hunter)

# set colors for individuals (lines) of interest (top 10 contributors to 2022 cohort)
pop.pmax$color <- "gray30"
pop.pmax$color[which(pop.pmax$ID == "RLS-K")] <- "red"
pop.pmax$color[which(pop.pmax$ID == "WSA-K")] <- "purple"
pop.pmax$color[which(pop.pmax$ID == "OK-RS")] <- "orange"
pop.pmax$color[which(pop.pmax$ID == "BK-LS")] <- "blue"
pop.pmax$color[which(pop.pmax$ID == "K-SLA")] <- "cyan"
pop.pmax$color[which(pop.pmax$ID == "SK-RG")] <- "magenta"
pop.pmax$color[which(pop.pmax$ID == "BK-FS")] <- "royalblue1"
pop.pmax$color[which(pop.pmax$ID == "PK-SG")] <- "cornflowerblue"
pop.pmax$color[which(pop.pmax$ID == "SR-PK")] <- "red4"
pop.pmax$color[which(pop.pmax$ID == "WK-LS")] <- "salmon2"

# set line type according to resident vs translocated
pop.pmax$ltype <- unname(sapply(id,function(x,df){df$Biological_Origin_Status}[which(df$COLOR_ID == x)],df=meta))
pop.pmax$ltype[which(pop.pmax$ltype == "T" | pop.pmax$ltype == "Donor_Population")] <- 1
pop.pmax$ltype[which(pop.pmax$ltype == "IE" | pop.pmax$ltype == "LR")] <- 2
pop.pmax$ltype[which(pop.pmax$ltype == "I")] <- 3
pop.pmax$ltype <- as.numeric(pop.pmax$ltype)

# set line width
pop.pmax$lw = 1
pop.pmax$lw[which(pop.pmax$ltype == 3)] <- 1.8 # need to increase size of dots for visibility
pop.pmax$lw[which(pop.pmax$ID == "RLS-K")] <- 1.8
pop.pmax$lw[which(pop.pmax$ID == "WSA-K")] <- 1.8
pop.pmax$lw[which(pop.pmax$ID == "OK-RS")] <- 1.8
pop.pmax$lw[which(pop.pmax$ID == "BK-LS")] <- 1.8
pop.pmax$lw[which(pop.pmax$ID == "K-SLA")] <- 1.8
pop.pmax$lw[which(pop.pmax$ID == "SK-RG")] <- 1.8
pop.pmax$lw[which(pop.pmax$ID == "BK-FS")] <- 1.8
pop.pmax$lw[which(pop.pmax$ID == "PK-SG")] <- isize # immigrant
pop.pmax$lw[which(pop.pmax$ID == "SR-PK")] <- 1.8
pop.pmax$lw[which(pop.pmax$ID == "WK-LS")] <- 1.8

# plot proportion of focal ancestor contributions over time

x11(width=16,height=7)
par(mgp = c(2.75,1,0))
plot(1, type="n", xlim=c(time.periods[1],time.periods[length(time.periods)]), ylim=c(0,max(pop.pmax[,tidx],na.rm=TRUE)+0.05),
xlab="Year", ylab="Proportion ancestor contribution relative to pop max", main="",xaxt='n', cex.axis=1.3, cex.lab=1.5)
axis(side=1,at=time.periods,labels=time.periods,cex=1.5,cex.axis=1.3)

for (i in 1:nrow(pop.pmax)) {
	# draw lines
	lines(x=time.periods, y=pop.pmax[i,tidx],col=alpha(pop.pmax$color[i],0.6), lty=pop.pmax$ltype[i], lwd=pop.pmax$lw[i])
}
# plot mean line
lines(x=time.periods, y=sapply(tidx,function(x,df){mean(df[,x],na.rm=TRUE)},df=pop.pmax), lty=6, col="black", lwd=1.8)

# add legend
legend('topleft',c("Translocated","Resident","Immigrant","Mean"),lty=c(1,2,3,6),bty='n',cex=1.2)

--- end R code for T, IE, and I temporal contributions to population ---

## Plots of expected genetic contribution through time to individuals born in a cohort

--- begin R code for T and IE temporal contributions to cohort ---

library(scales) # for alpha colors

meta <- read.table("/home/tyler/Dropbox/research/jay/mosaic/metadata/jayid_map_20230512.txt",head=TRUE,sep="\t")
fdir='/home/tyler/Dropbox/research/jay/mosaic/pedigree/results/lr_temporal/'
ped <- read.table('/home/tyler/Dropbox/research/jay/mosaic/pedigree/cr_ped_20230512.tsv', head=TRUE, na.strings='*')

cohort.n <- NULL # data frame of number of expected genomic copies
cohort.pfocal <- NULL # data frame of contributions normalized by focal ancestors
cohort.pmax <- NULL # data frame of contribution normalized by max ancestral cohort pop contribution

# read in pedstat files for time points 2004-2022
time.periods = 2004:2022
tidx <- 2:(length(time.periods)+1) # these are the contribution columns in matrix
id <- NULL
for (t in time.periods) {
	df <- read.table(paste0(fdir,'T_IE_20230512_to_',t,'_LR_contribution.pedstat1'),head=TRUE)
	if (is.null(id)) id <- df[,1]
	cohort.n <- cbind(cohort.n, df[,2])
	cohort.pfocal <- cbind(cohort.pfocal, df[,3])
	cohort.pmax <- cbind(cohort.pmax, df[,4])
}

# mask values of individuals if they weren't born
ped.sub <- ped[which(ped$ID %in% id),c(1,5)]
ped.sub <- ped.sub[match(id,ped.sub$ID),]
for (i in 1:length(time.periods)) {
	t = time.periods[i]
	idx <- which(ped.sub$COHORT > t)
	if (length(idx) > 0) {
		cohort.n[idx,i] <- NA
		cohort.pfocal[idx,i] <- NA
		cohort.pmax[idx,i] <- NA	
	}
}

cohort.n <- cbind(data.frame(ID=id),as.data.frame(cohort.n)) # add sample names
colnames(cohort.n) <- c("ID",paste0("cohort.",time.periods))

cohort.pfocal <- cbind(data.frame(ID=id),as.data.frame(cohort.pfocal)) # add sample names
colnames(cohort.pfocal) <- c("ID",paste0("cohort.",time.periods))

cohort.pmax <- cbind(data.frame(ID=id),as.data.frame(cohort.pmax)) # add sample names
colnames(cohort.pmax) <- c("ID",paste0("cohort.",time.periods))

# proportion with respect to focal ancestors plot

# get ID of top contributors to 2022 cohort
id.sort <- cohort.pfocal$ID[order(-cohort.pfocal$cohort.2022)] # individuals ordered by contribution in 2022
cohort.pfocal$rank.2022 <- match(cohort.pfocal$ID,id.sort)

#> id.sort[1:10]
# [1] "RLS-K" "WSA-K" "K-SLA" "OK-RS" "BK-FS" "SK-RG" "SR-PK" "K-RSW" "K-SBF"
#[10] "BK-LS"


# set colors for individuals (lines) of interest: top 16 contributors to 2022 population, which contributed over 75% of ancestry since 2015.
cohort.pfocal$color <- "gray30"
cohort.pfocal$color[which(cohort.pfocal$ID == "RLS-K")] <- "red3"
cohort.pfocal$color[which(cohort.pfocal$ID == "WSA-K")] <- "blue1"
cohort.pfocal$color[which(cohort.pfocal$ID == "K-SLA")] <- "cyan"
cohort.pfocal$color[which(cohort.pfocal$ID == "OK-RS")] <- "steelblue1"
cohort.pfocal$color[which(cohort.pfocal$ID == "SK-RG")] <- "darkorange"
cohort.pfocal$color[which(cohort.pfocal$ID == "BK-FS")] <- "indianred4"
cohort.pfocal$color[which(cohort.pfocal$ID == "K-RSW")] <- "peru"
cohort.pfocal$color[which(cohort.pfocal$ID == "K-SBF")] <- "tan"
cohort.pfocal$color[which(cohort.pfocal$ID == "SR-PK")] <- "purple"
cohort.pfocal$color[which(cohort.pfocal$ID == "BK-LS")] <- "mediumpurple1"
cohort.pfocal$color[which(cohort.pfocal$ID == "K-GSW")] <- "plum2"
cohort.pfocal$color[which(cohort.pfocal$ID == "WSF-K")] <- "magenta"
cohort.pfocal$color[which(cohort.pfocal$ID == "LK-SG")] <- "deeppink3"
cohort.pfocal$color[which(cohort.pfocal$ID == "BK-AS")] <- "hotpink"
cohort.pfocal$color[which(cohort.pfocal$ID == "WK-LS")] <- "darkmagenta"
cohort.pfocal$color[which(cohort.pfocal$ID == "F-BPS")] <- "darkblue"

# set line width
cohort.pfocal$lw <- 1
cohort.pfocal$lw[which(cohort.pfocal$ID == "RLS-K")] <- 2
cohort.pfocal$lw[which(cohort.pfocal$ID == "WSA-K")] <- 2
cohort.pfocal$lw[which(cohort.pfocal$ID == "K-SLA")] <- 2
cohort.pfocal$lw[which(cohort.pfocal$ID == "OK-RS")] <- 2
cohort.pfocal$lw[which(cohort.pfocal$ID == "SK-RG")] <- 2
cohort.pfocal$lw[which(cohort.pfocal$ID == "BK-FS")] <- 2
cohort.pfocal$lw[which(cohort.pfocal$ID == "K-RSW")] <- 2
cohort.pfocal$lw[which(cohort.pfocal$ID == "K-SBF")] <- 2
cohort.pfocal$lw[which(cohort.pfocal$ID == "SR-PK")] <- 2
cohort.pfocal$lw[which(cohort.pfocal$ID == "BK-LS")] <- 2
cohort.pfocal$lw[which(cohort.pfocal$ID == "K-GSW")] <- 2
cohort.pfocal$lw[which(cohort.pfocal$ID == "WSF-K")] <- 2
cohort.pfocal$lw[which(cohort.pfocal$ID == "LK-SG")] <- 2
cohort.pfocal$lw[which(cohort.pfocal$ID == "BK-AS")] <- 2
cohort.pfocal$lw[which(cohort.pfocal$ID == "WK-LS")] <- 2
cohort.pfocal$lw[which(cohort.pfocal$ID == "F-BPS")] <- 2

# set colors for individuals (lines) of interest (top 10 contributors to 2022 cohort) # deprecated
#cohort.pfocal$color <- "gray30" # use for top 10
#cohort.pfocal$color <- "black" # use for top 3
#cohort.pfocal$color[which(cohort.pfocal$ID == "RLS-K")] <- "red"
#cohort.pfocal$color[which(cohort.pfocal$ID == "WSA-K")] <- "purple"
#cohort.pfocal$color[which(cohort.pfocal$ID == "K-SLA")] <- "steelblue1" # use for top 3
#cohort.pfocal$color[which(cohort.pfocal$ID == "K-SLA")] <- "cyan" # use for top 10
# uncomment individuals below to denote top 10 contributors
#cohort.pfocal$color[which(cohort.pfocal$ID == "OK-RS")] <- "orange"
#cohort.pfocal$color[which(cohort.pfocal$ID == "BK-FS")] <- "royalblue1"
#cohort.pfocal$color[which(cohort.pfocal$ID == "SK-RG")] <- "magenta"
#cohort.pfocal$color[which(cohort.pfocal$ID == "SR-PK")] <- "red4"
#cohort.pfocal$color[which(cohort.pfocal$ID == "K-RSW")] <- "turquoise3"
#cohort.pfocal$color[which(cohort.pfocal$ID == "K-SBF")] <- "palevioletred1"
#cohort.pfocal$color[which(cohort.pfocal$ID == "BK-LS")] <- "blue"

# set line width # deprecated
#cohort.pfocal$lw = 1
#cohort.pfocal$lw[which(cohort.pfocal$ID == "RLS-K")] <- 2
#cohort.pfocal$lw[which(cohort.pfocal$ID == "WSA-K")] <- 2
#cohort.pfocal$lw[which(cohort.pfocal$ID == "K-SLA")] <- 2
# uncomment individuals below to denote top 10 contributors
#cohort.pfocal$lw[which(cohort.pfocal$ID == "OK-RS")] <- 2
#cohort.pfocal$lw[which(cohort.pfocal$ID == "BK-FS")] <- 2
#cohort.pfocal$lw[which(cohort.pfocal$ID == "SK-RG")] <- 2
#cohort.pfocal$lw[which(cohort.pfocal$ID == "SR-PK")] <- 2
#cohort.pfocal$lw[which(cohort.pfocal$ID == "K-RSW")] <- 2
#cohort.pfocal$lw[which(cohort.pfocal$ID == "K-SBF")] <- 2
#cohort.pfocal$lw[which(cohort.pfocal$ID == "BK-LS")] <- 2

# set line type according to resident vs translocated
cohort.pfocal$ltype <- unname(sapply(id,function(x,df){df$Biological_Origin_Status}[which(df$COLOR_ID == x)],df=meta))
cohort.pfocal$ltype[which(cohort.pfocal$ltype == "T" | cohort.pfocal$ltype == "Donor_Population")] <- 1
cohort.pfocal$ltype[which(cohort.pfocal$ltype == "IE" | cohort.pfocal$ltype == "LR")] <- 2
cohort.pfocal$ltype <- as.numeric(cohort.pfocal$ltype)

# plot proportion of focal ancestor contributions over time

#pdf(file='/home/tyler/Dropbox/research/jay/mosaic/pedigree/results/lr_temporal/T_IE_20230512_LR_contributions.pdf', width=16, height=7) #deprecated
#png(file='/home/tyler/Dropbox/research/jay/mosaic/figures/T_IE_cohort_contribution_pfocal.png',width=16, height=7, units='in', res=300)
#png(file='/home/tyler/Dropbox/research/jay/mosaic/figures/T_IE_cohort_contribution_pfocal_v2.png',width=16, height=7, units='in', res=300)
png(file='/home/tyler/Dropbox/research/jay/mosaic/figures/T_IE_cohort_contribution_pfocal_v3.png',width=16, height=7, units='in', res=300)
x11(width=16,height=7)
par(mgp = c(2.75,1,0))
plot(1, type="n", xlim=c(time.periods[1],time.periods[length(time.periods)]), ylim=c(0,max(cohort.pfocal[,tidx],na.rm=TRUE)+0.0),
xlab="Year", ylab="Proportion ancestor contribution to cohort", main="",xaxt='n', cex.axis=1.3, cex.lab=1.5)
axis(side=1,at=time.periods,labels=time.periods,cex=1.5,cex.axis=1.3)

for (i in 1:nrow(cohort.pfocal)) {
	# draw lines
	lines(x=time.periods, y=cohort.pfocal[i,tidx],col=alpha(cohort.pfocal$color[i],0.6), lty=cohort.pfocal$ltype[i], lwd=cohort.pfocal$lw[i])
}

# plot mean line
#lines(x=time.periods, y=sapply(tidx,function(x,df){mean(df[,x],na.rm=TRUE)},df=cohort.pfocal), lty=6, col="black", lwd=2) # THIS MEAN SHOULD EXCLUDE 0/NA

# add legend
#legend('topright',c("Translocated","Resident","Mean"),lty=c(1,2,6),bty='n',cex=1.3,seg.len=2.9,lwd=1.7)
legend('topright',c("Translocated","Resident"),lty=c(1,2),bty='n',cex=1.3,seg.len=2.9,lwd=1.7)

# dev.off()

# proportion with respect to maximum ancestor pop contribution (Hunter normalization) plot

# get ID of top contributors to 2022 cohort
id.sort.hunter <- cohort.pmax$ID[order(-cohort.pmax$cohort.2022)] # individuals ordered by contribution in 2022
cohort.pmax$rank.2022 <- match(cohort.pmax$ID,id.sort.hunter)

#> id.sort.hunter[1:10]
# [1] "BK-LS" "RLS-K" "OK-RS" "K-RSW" "WSA-K" "K-SLA" "BK-AS" "BK-FS" "SK-RG"
#[10] "WK-LS"

# set colors for individuals (lines) of interest (top 10 contributors to 2022 cohort)
cohort.pmax$color <- "gray30"
cohort.pmax$color[which(cohort.pmax$ID == "BK-LS")] <- "blue"
cohort.pmax$color[which(cohort.pmax$ID == "RLS-K")] <- "red"
cohort.pmax$color[which(cohort.pmax$ID == "OK-RS")] <- "orange"
cohort.pmax$color[which(cohort.pmax$ID == "K-RSW")] <- "turquoise3"
cohort.pmax$color[which(cohort.pmax$ID == "WSA-K")] <- "purple"
cohort.pmax$color[which(cohort.pmax$ID == "K-SLA")] <- "cyan"
cohort.pmax$color[which(cohort.pmax$ID == "BK-AS")] <- "yellow3"
cohort.pmax$color[which(cohort.pmax$ID == "BK-FS")] <- "royalblue1"
cohort.pmax$color[which(cohort.pmax$ID == "SK-RG")] <- "magenta"
cohort.pmax$color[which(cohort.pmax$ID == "WK-LS")] <- "salmon2"

# set line width
cohort.pmax$lw = 1
cohort.pmax$lw[which(cohort.pmax$ID == "BK-LS")] <- 2
cohort.pmax$lw[which(cohort.pmax$ID == "RLS-K")] <- 2
cohort.pmax$lw[which(cohort.pmax$ID == "OK-RS")] <- 2
cohort.pmax$lw[which(cohort.pmax$ID == "K-RSW")] <- 2
cohort.pmax$lw[which(cohort.pmax$ID == "WSA-K")] <- 2
cohort.pmax$lw[which(cohort.pmax$ID == "K-SLA")] <- 2
cohort.pmax$lw[which(cohort.pmax$ID == "BK-AS")] <- 2
cohort.pmax$lw[which(cohort.pmax$ID == "BK-FS")] <- 2
cohort.pmax$lw[which(cohort.pmax$ID == "SK-RG")] <- 2
cohort.pmax$lw[which(cohort.pmax$ID == "WK-LS")] <- 2

# set line type according to resident vs translocated
cohort.pmax$ltype <- unname(sapply(id,function(x,df){df$Biological_Origin_Status}[which(df$COLOR_ID == x)],df=meta))
cohort.pmax$ltype[which(cohort.pmax$ltype == "T" | cohort.pmax$ltype == "Donor_Population")] <- 1
cohort.pmax$ltype[which(cohort.pmax$ltype == "IE" | cohort.pmax$ltype == "LR")] <- 2
cohort.pmax$ltype <- as.numeric(cohort.pmax$ltype)

# plot proportion of focal ancestor contributions over time

png(file='/home/tyler/Dropbox/research/jay/mosaic/figures/T_IE_cohort_contribution_pmax.png',width=16, height=7, units='in', res=300)
x11(width=16,height=7)
par(mgp = c(2.75,1,0))
plot(1, type="n", xlim=c(time.periods[1],time.periods[length(time.periods)]), ylim=c(0,max(cohort.pmax[,tidx],na.rm=TRUE)+0.08),
xlab="Year", ylab="Proportion ancestor contribution relative to pop max", main="",xaxt='n', cex.axis=1.3, cex.lab=1.5)
axis(side=1,at=time.periods,labels=time.periods,cex=1.5,cex.axis=1.3)

for (i in 1:nrow(cohort.pmax)) {
	# draw lines
	lines(x=time.periods, y=cohort.pmax[i,tidx],col=alpha(cohort.pmax$color[i],0.6), lty=cohort.pmax$ltype[i], lwd=cohort.pmax$lw[i])
}
# plot mean line
lines(x=time.periods, y=sapply(tidx,function(x,df){mean(df[,x],na.rm=TRUE)},df=cohort.pmax), lty=6, col="black", lwd=2) # THIS MEAN SHOULD EXCLUDE 0/NA

# add legend

# legend configuration 1
# legend(x=2019.5, y=0.9,c("Translocated","Resident","Mean"),lty=c(1,2,6),bty='n',cex=1.3,lwd=1.7,seg.len=2.9)

# legend configuration 2
legend(x=2004, y=1.15,"Translocated",lty=1,bty='n',cex=1.3, lwd=1.7, seg.len=2.9)
legend(x=2008, y=1.15,"Resident",lty=2,bty='n',cex=1.3, lwd=1.7, seg.len=2.9)
legend(x=2011.4, y=1.15,"Mean",lty=6,bty='n',cex=1.3, lwd=1.7, seg.len=2.9)

#dev.off()

--- end R code for T and IE temporal contributions to cohort ---

--- begin R code for T, IE, and I temporal contributions to cohort ---

library(scales) # for alpha colors

meta <- read.table("/home/tyler/Dropbox/research/jay/mosaic/metadata/jayid_map_20230512.txt",head=TRUE,sep="\t")
fdir='/home/tyler/Dropbox/research/jay/mosaic/pedigree/results/lr_temporal/'
ped <- read.table('/home/tyler/Dropbox/research/jay/mosaic/pedigree/mosaic_ped_20230512.tsv', head=TRUE, na.strings='*')

cohort.n <- NULL # data frame of number of expected genomic copies
cohort.pfocal <- NULL # data frame of contributions normalized by focal ancestors
cohort.pmax <- NULL # data frame of contribution normalized by max cohort pop contribution

# read in pedstat files for time points 2004-2022
time.periods = 2004:2022
tidx <- 2:(length(time.periods)+1) # these are the contribution columns in matrix
id <- NULL
for (t in time.periods) {
	df <- read.table(paste0(fdir,'T_IE_I_20230512_to_',t,'_LR_contribution.pedstat1'),head=TRUE)
	if (is.null(id)) id <- df[,1]
	cohort.n <- cbind(cohort.n, df[,2])
	cohort.pfocal <- cbind(cohort.pfocal, df[,3])
	cohort.pmax <- cbind(cohort.pmax, df[,4])
}

# mask values of individuals if they weren't born
ped.sub <- ped[which(ped$ID %in% id),c(1,5)]
ped.sub <- ped.sub[match(id,ped.sub$ID),]
for (i in 1:length(time.periods)) {
	t = time.periods[i]
	idx <- which(ped.sub$COHORT > t)
	if (length(idx) > 0) {
		cohort.n[idx,i] <- NA
		cohort.pfocal[idx,i] <- NA
		cohort.pmax[idx,i] <- NA	
	}
}

cohort.n <- cbind(data.frame(ID=id),as.data.frame(cohort.n)) # add sample names
colnames(cohort.n) <- c("ID",paste0("cohort.",time.periods))

cohort.pfocal <- cbind(data.frame(ID=id),as.data.frame(cohort.pfocal)) # add sample names
colnames(cohort.pfocal) <- c("ID",paste0("cohort.",time.periods))

cohort.pmax <- cbind(data.frame(ID=id),as.data.frame(cohort.pmax)) # add sample names
colnames(cohort.pmax) <- c("ID",paste0("cohort.",time.periods))

# proportion with respect to focal ancestors plot

# get ID of top contributors to 2022 cohort
id.sort <- cohort.pfocal$ID[order(-cohort.pfocal$cohort.2022)] # individuals ordered by contribution in 2022
cohort.pfocal$rank.2022 <- match(cohort.pfocal$ID,id.sort)

# set colors for individuals (lines) of interest (top 10 contributors to 2022 cohort)
cohort.pfocal$color <- "gray30"
cohort.pfocal$color[which(cohort.pfocal$ID == "RLS-K")] <- "red"
cohort.pfocal$color[which(cohort.pfocal$ID == "WSA-K")] <- "purple"
cohort.pfocal$color[which(cohort.pfocal$ID == "K-SLA")] <- "cyan"
cohort.pfocal$color[which(cohort.pfocal$ID == "PF-SH")] <- "darkcyan"
cohort.pfocal$color[which(cohort.pfocal$ID == "PK-SG")] <- "cornflowerblue"
cohort.pfocal$color[which(cohort.pfocal$ID == "OK-RS")] <- "orange"
cohort.pfocal$color[which(cohort.pfocal$ID == "BK-FS")] <- "royalblue1"
cohort.pfocal$color[which(cohort.pfocal$ID == "SK-RG")] <- "magenta"
cohort.pfocal$color[which(cohort.pfocal$ID == "GF-SG")] <- "royalblue4"
cohort.pfocal$color[which(cohort.pfocal$ID == "SR-PK")] <- "red4"


# set line type according to resident vs translocated
cohort.pfocal$ltype <- unname(sapply(id,function(x,df){df$Biological_Origin_Status}[which(df$COLOR_ID == x)],df=meta))
cohort.pfocal$ltype[which(cohort.pfocal$ltype == "T" | cohort.pfocal$ltype == "Donor_Population")] <- 1
cohort.pfocal$ltype[which(cohort.pfocal$ltype == "IE" | cohort.pfocal$ltype == "LR")] <- 2
cohort.pfocal$ltype[which(cohort.pfocal$ltype == "I")] <- 3
cohort.pfocal$ltype <- as.numeric(cohort.pfocal$ltype)

# set line width
cohort.pfocal$lw = 1
cohort.pfocal$lw[which(cohort.pfocal$ltype == 3)] <- 1.8 # need to increase size of dots for visibility
isize=2.8
cohort.pfocal$lw[which(cohort.pfocal$ID == "RLS-K")] <- 1.8
cohort.pfocal$lw[which(cohort.pfocal$ID == "WSA-K")] <- 1.8
cohort.pfocal$lw[which(cohort.pfocal$ID == "K-SLA")] <- 1.8
cohort.pfocal$lw[which(cohort.pfocal$ID == "PF-SH")] <- isize # immigrant
cohort.pfocal$lw[which(cohort.pfocal$ID == "PK-SG")] <- isize # immigrant
cohort.pfocal$lw[which(cohort.pfocal$ID == "OK-RS")] <- 1.8
cohort.pfocal$lw[which(cohort.pfocal$ID == "BK-FS")] <- 1.8
cohort.pfocal$lw[which(cohort.pfocal$ID == "SK-RG")] <- 1.8
cohort.pfocal$lw[which(cohort.pfocal$ID == "GF-SG")] <- isize # immigrant
cohort.pfocal$lw[which(cohort.pfocal$ID == "SR-PK")] <- 1.8

# plot proportion of focal ancestor contributions over time

#pdf(file='/home/tyler/Dropbox/research/jay/mosaic/pedigree/results/lr_temporal/T_IE_I_20230512_LR_cohort_contributions.pdf', width=16, height=7)
x11(width=16,height=7)
par(mgp = c(2.75,1,0))
plot(1, type="n", xlim=c(time.periods[1],time.periods[length(time.periods)]), ylim=c(0,max(cohort.pfocal[,tidx],na.rm=TRUE)+0.05),
xlab="Year", ylab="Proportion ancestor contribution to cohort", main="",xaxt='n', cex.axis=1.3, cex.lab=1.5)
axis(side=1,at=time.periods,labels=time.periods,cex=1.5,cex.axis=1.3)

for (i in 1:nrow(cohort.pfocal)) {
	# draw lines
	lines(x=time.periods, y=cohort.pfocal[i,tidx],col=alpha(cohort.pfocal$color[i],0.6), lty=cohort.pfocal$ltype[i], lwd=cohort.pfocal$lw[i])
}
# plot mean line
lines(x=time.periods, y=sapply(tidx,function(x,df){mean(df[,x],na.rm=TRUE)},df=cohort.pfocal), lty=6, col="black", lwd=1.8)

# add legend
legend('topright',c("Translocated","Resident","Immigrant","Mean"),lty=c(1,2,3,6),bty='n',cex=1.2)

# proportion with respect to maximum ancestor pop contribution (Hunter normalization) plot

# get ID of top contributors to 2022 cohort
id.sort.hunter <- cohort.pmax$ID[order(-cohort.pmax$cohort.2022)] # individuals ordered by contribution in 2022
cohort.pmax$rank.2022 <- match(cohort.pmax$ID,id.sort.hunter)

# set colors for individuals (lines) of interest (top 10 contributors to 2022 cohort)
cohort.pmax$color <- "gray30"
cohort.pmax$color[which(cohort.pmax$ID == "RLS-K")] <- "red"
cohort.pmax$color[which(cohort.pmax$ID == "WSA-K")] <- "purple"
cohort.pmax$color[which(cohort.pmax$ID == "OK-RS")] <- "orange"
cohort.pmax$color[which(cohort.pmax$ID == "K-SLA")] <- "cyan"
cohort.pmax$color[which(cohort.pmax$ID == "BK-FS")] <- "royalblue1"
cohort.pmax$color[which(cohort.pmax$ID == "SK-RG")] <- "magenta"
cohort.pmax$color[which(cohort.pmax$ID == "BK-LS")] <- "blue"
cohort.pmax$color[which(cohort.pmax$ID == "SR-PK")] <- "red4"
cohort.pmax$color[which(cohort.pmax$ID == "WK-LS")] <- "salmon2"
cohort.pmax$color[which(cohort.pmax$ID == "K-RSW")] <- "turquoise3"

# set line type according to resident vs translocated
cohort.pmax$ltype <- unname(sapply(id,function(x,df){df$Biological_Origin_Status}[which(df$COLOR_ID == x)],df=meta))
cohort.pmax$ltype[which(cohort.pmax$ltype == "T" | cohort.pmax$ltype == "Donor_Population")] <- 1
cohort.pmax$ltype[which(cohort.pmax$ltype == "IE" | cohort.pmax$ltype == "LR")] <- 2
cohort.pmax$ltype[which(cohort.pmax$ltype == "I")] <- 3
cohort.pmax$ltype <- as.numeric(cohort.pmax$ltype)

# set line width
cohort.pmax$lw = 1
cohort.pmax$lw[which(cohort.pmax$ltype == 3)] <- 1.8 # need to increase size of dots for visibility
cohort.pmax$lw[which(cohort.pmax$ID == "RLS-K")] <- 1.8
cohort.pmax$lw[which(cohort.pmax$ID == "WSA-K")] <- 1.8
cohort.pmax$lw[which(cohort.pmax$ID == "OK-RS")] <- 1.8
cohort.pmax$lw[which(cohort.pmax$ID == "K-SLA")] <- 1.8
cohort.pmax$lw[which(cohort.pmax$ID == "BK-FS")] <- 1.8
cohort.pmax$lw[which(cohort.pmax$ID == "SK-RG")] <- 1.8
cohort.pmax$lw[which(cohort.pmax$ID == "BK-LS")] <- 1.8
cohort.pmax$lw[which(cohort.pmax$ID == "SR-PK")] <- 1.8
cohort.pmax$lw[which(cohort.pmax$ID == "WK-LS")] <- 1.8
cohort.pmax$lw[which(cohort.pmax$ID == "K-RSW")] <- 1.8

# plot proportion of focal ancestor contributions over time

x11(width=16,height=7)
par(mgp = c(2.75,1,0))
plot(1, type="n", xlim=c(time.periods[1],time.periods[length(time.periods)]), ylim=c(0,max(cohort.pmax[,tidx],na.rm=TRUE)+0.05),
xlab="Year", ylab="Proportion ancestor contribution relative to pop max", main="",xaxt='n', cex.axis=1.3, cex.lab=1.5)
axis(side=1,at=time.periods,labels=time.periods,cex=1.5,cex.axis=1.3)

for (i in 1:nrow(cohort.pmax)) {
	# draw lines
	lines(x=time.periods, y=cohort.pmax[i,tidx],col=alpha(cohort.pmax$color[i],0.6), lty=cohort.pmax$ltype[i], lwd=cohort.pmax$lw[i])
}
# plot mean line
lines(x=time.periods, y=sapply(tidx,function(x,df){mean(df[,x],na.rm=TRUE)},df=cohort.pmax), lty=6, col="black", lwd=1.8)

# add legend
legend('topright',c("Translocated","Resident","Immigrant","Mean"),lty=c(1,2,3,6),bty='n',cex=1.2)

--- end R code for T, IE, and I temporal contributions to cohort ---

### COMPARE PEDIGREE VS GENOMIC-BASED CONTRIBUTIONS

workdir='/home/tyler/Dropbox/research/jay/mosaic/pedigree/contribution'

--- begin R code for comparing contributions ---

#gendat <- read.table('/home/tyler/Dropbox/research/jay/mosaic/popgen/relatedness/skew/T_E_I_M4_to_contemporary_contributions_c0.0243058.skewstat3',head=TRUE)
#ped1 <- read.table('/home/tyler/Dropbox/research/jay/mosaic/pedigree/results/sequenced_contemporary/T_IE_I_20230512_to_seq_contemporary.pedstat1',head=TRUE)
ped1 <- read.table('/home/tyler/Dropbox/research/jay/mosaic/pedigree/results/sequenced_contemporary/T_IE_20230512_to_seq_contemporary.pedstat1',head=TRUE)
gendat <- read.table('/home/tyler/Dropbox/research/jay/mosaic/popgen/relatedness/skew/CR_T_IE_to_C_contributions_c0.0243058.skewstat3',head=TRUE)
genmeta <- read.table('~/Dropbox/research/jay/mosaic/metadata/M4_sequenced_FSJsamples_metadata.txt',head=TRUE)
jayid <- read.csv('/home/tyler/Dropbox/research/jay/mosaic/metadata/jayid_map_20230512.txt',head=TRUE,na.strings = "*",sep="\t")
jayid$COLOR_ID <- toupper(jayid$COLOR_ID)

# translate color band, federal, and lab IDs
ped1$FED_ID <- unname(sapply(ped1$ID,function(x,df){ifelse(length(grep("UNBAND",x))>0,NA,df$FEDERAL_ID[which(df$COLOR_ID == x)])},df=jayid))
gendat$FED_ID = unname(sapply(gendat$ID,function(x,df){df$FEDERAL_ID[which(df$COLOR_ID == x)]},df=jayid))
ped1$LAB_ID = unname(sapply(ped1$ID,function(x,df){df$LAB_ID[which(df$COLOR_ID == x)]},df=jayid))

# assign ranks based on contribution (equal values will have equal rank)
gendat.sort <- gendat[order(-gendat$Swtr),] # sort by Swtr
swtr.unique <- unique(gendat.sort$Swtr)
gendat.sort$swtr.rank = NA
for (i in 1:length(swtr.unique)) {gendat.sort$swtr.rank[which(gendat.sort$Swtr == swtr.unique[i])] = i}

ped1.sort <- ped1[order(-ped1$P_ANC_FOCAL),]
p_focal.unique = unique(ped1.sort$P_ANC_FOCAL)
ped1.sort$ped.rank = NA
for (i in 1:length(p_focal.unique)) {ped1.sort$ped.rank[which(ped1.sort$P_ANC_FOCAL == p_focal.unique[i])] = i}

ped1.sort$gen.rank = unname(sapply(ped1.sort$ID,function(x,df){ifelse(is.na(x),NA,df$swtr.rank[which(df$ID == x)])},df=gendat.sort))
ped1.sort$Swtr = unname(sapply(ped1.sort$ID,function(x,df){ifelse(is.na(x),NA,df$Swtr[which(df$ID == x)])},df=gendat.sort))

# add M4 samples that were not in pedigree analysis - not necessary for core region only (T and IE) analysis
#m4_labid <- gendat.sort$ID[grep("M4_", gendat.sort$ID)]
#m4_missing <- NULL
#for (id in m4_labid) {
#	colid <- jayid$COLOR_ID[which(jayid$LAB_ID == id)]
#	fedid <- jayid$FEDERAL_ID[which(jayid$LAB_ID == id)]
#	idx = which(gendat.sort$ID == id)
#	if (fedid %in% ped1.sort$FED_ID == FALSE) {
#		m4_missing <- rbind(m4_missing, m4_missing <- data.frame(ID = colid, N_GENOME_COPIES = NA, P_ANC_FOCAL = NA, P_ANC_MAX = NA, FED_ID = fedid, LAB_ID = id,
#		   ped.rank = NA, gen.rank = gendat.sort$swtr.rank[idx], Swtr = gendat.sort$Swtr[idx]))
#	}
#}

#ped1.sort <- rbind(ped1.sort, m4_missing)

# subset of ancestors in pedigree and genetic analysis
share <- ped1.sort[which(!is.na(ped1.sort$ped.rank) & !is.na(ped1.sort$gen.rank)),]

# test for correlation between K statistic and the the number of genomic copies for individuals common to both datasets
> cor.test(x=share$Swtr, y=share$N_GENOME_COPIES, method="kendall")
#
#	Kendall's rank correlation tau
#
#data:  share$Swtr and share$N_GENOME_COPIES
#z = 3.3456, p-value = 0.000821
#alternative hypothesis: true tau is not equal to 0
#sample estimates:
#      tau 
#0.4194696 
#
#Warning message:
#In cor.test.default(x = share$Swtr, y = share$N_GENOME_COPIES, method = "kendall") :
#  Cannot compute exact p-value with ties

# line plot

library(scales)

# set point colors according to biological origin (grey indicates no contribution)

rescol = "cyan3"
transcol = "darkorange2"
ped1.sort$biotype_col = unname(sapply(ped1.sort$ID,function(x,df){df$Biological_Origin_Status[which(df$COLOR_ID==x)]},df=jayid))
ped1.sort$biotype_col <- replace(ped1.sort$biotype_col, which(ped1.sort$biotype_col == "IE" | ped1.sort$biotype_col == "LR"),rescol)
ped1.sort$biotype_col <- replace(ped1.sort$biotype_col, which(ped1.sort$biotype_col == "T"),transcol)

ped.cutoff = (ped1.sort$ped.rank[which(ped1.sort$N_GENOME_COPIES == 0)])[1] # pedigree individuals at this rank or above did not contribute
gen.cutoff = ped1.sort$gen.rank[which(ped1.sort$Swtr == 0)][1] # individuals at this rank or above did not make contribution based K-statistic

pedcol.bg <- alpha(ped1.sort$biotype_col,0.65)
#pedcol.bg[which(is.na(ped1.sort$gen.rank))] <- alpha("grey40",0) # makes totally tranparent (i.e. no colored background)
pedcol.bg[which(ped1.sort$ped.rank >= ped.cutoff)] <- alpha("grey40",0)

pedcol <- alpha(ped1.sort$biotype_col,0.65)
pedcol[which(ped1.sort$ped.rank >= ped.cutoff)] <- alpha("grey40",0.65)

gencol.bg <- alpha(ped1.sort$biotype_col,0.65)
#gencol.bg[which(is.na(ped1.sort$ped.rank))] <- alpha("grey40",0) # makes totally tranparent (i.e. no colored background)
gencol.bg[which(ped1.sort$gen.rank >= gen.cutoff)] <- alpha("grey40",0)

gencol <- alpha(ped1.sort$biotype_col,0.65)
gencol[which(ped1.sort$gen.rank >= gen.cutoff)] <- alpha("grey40",0.65)

# set point sizes according to contribution
ped.scale <- ped1.sort$P_ANC_FOCAL/max(ped1.sort$P_ANC_FOCAL)
ped.scale[which(ped.scale == 0)] <- min(ped.scale[which(ped.scale > 0)])

gen.scale <- ped1.sort$Swtr/max(ped1.sort$Swtr,na.rm=TRUE)
gen.scale[which(gen.scale == 0)] <- min(gen.scale[which(gen.scale > 0)])

# use x-axis jitter to show individuals with tied ranks
xa = 0.3
xb = 0.8

# jitter for pedigree ranks
xa.jitter <- rep(xa,nrow(ped1.sort))
urank.ped <- unique(ped1.sort$ped.rank)
urank.ped.naidx <- which(is.na(urank.ped))
if (length(urank.ped.naidx) > 0) urank.ped <- urank.ped[-urank.ped.naidx]
for (i in urank.ped) {
        n = 1                                     
        xshift = 0 
        for (idx in which(ped1.sort$ped.rank == i)) {
                if (n %% 2) {
                        xa.jitter[idx] = xa + xshift
                } else {
                        xa.jitter[idx] = xa - xshift
                        xshift = xshift + 0.005
                }
                n = n+1
        }
}

# jitter for genetic ranks
xb.jitter <- rep(xb,nrow(ped1.sort))
urank.gen <- unique(ped1.sort$gen.rank)
urank.gen.naidx <- which(is.na(urank.gen))
if (length(urank.gen.naidx) > 0) urank.gen <- urank.gen[-urank.gen.naidx]
for (i in urank.gen) {
        n = 1
        xshift = 0
        for (idx in which(ped1.sort$gen.rank == i)) {
                if (n %% 2) {
                        xb.jitter[idx] = xb + xshift
                } else {
                        xb.jitter[idx] = xb - xshift
                        xshift = xshift + 0.005
                }
                n = n+1
        }
}


# make canvas and plot
#pdf(file='/home/tyler/Dropbox/research/jay/mosaic/pedigree/results/sequenced_contemporary/pedigree_vs_genetic_skew_rank.pdf') #deprecated
#png(file='/home/tyler/Dropbox/research/jay/mosaic/figures/ped_vs_genetic_skew_comparison.png',width=6, height=7, units='in', res=300)

x11(width=6,height=7)
maxrank = max(ped1.sort$ped.rank, ped1.sort$gen.rank, na.rm=TRUE)
y.marks = c(1,seq(from=5,to=2*round(maxrank/2),by=5))
plot(1,type="n", xlab="", ylab="Contribution rank", ylim=c(maxrank, -1), xlim=c(0,1),xaxt='n', yaxt='n', cex.lab=1.3) # blank canvas
axis(side=1,at=c(xa,xb),labels=c("Pedigree","Genetic"),cex.axis=1.3) # x-axis
axis(side=2,at=y.marks,labels=y.marks,cex.axis=1.3) # y-axis

# add points

point.width=1
points(x=xa.jitter,y=ped1.sort$ped.rank, pch=21, col=pedcol, bg=pedcol.bg, lwd=point.width, cex=3.5*ped.scale)
points(x=xb.jitter,y=ped1.sort$gen.rank, pch=21, col=gencol, bg=gencol.bg, lwd=point.width, cex=3.5*gen.scale)
for (i in 1:nrow(share)) {
	lcol = "black"
	lwidth = 1.3
	if (share$ped.rank[i] >= ped.cutoff) {
		# mask lines from pedigree individuals that did not contribute
		lcol = alpha("grey20",0.3)
		lwidth = 1
	}
	lines(x=c(xa,xb),y=c(share$ped.rank[i],share$gen.rank[i]), col=lcol, lwd=lwidth)
}

# add annotations
text(x=xa,y=-1.2,paste0("n=",length(which(!is.na(ped1.sort$ped.rank)))),cex=1.2)
text(x=xb,y=-1.2,paste0("n=",length(which(!is.na(ped1.sort$gen.rank)))),cex=1.2)
legend('bottomleft',c("Resident","Translocated", "No contribution"),pch=21,col=c(rescol,transcol,alpha("grey40",0.65)),pt.bg=c(rescol,transcol,alpha("grey40",0)),bty='n', cex=1, pt.cex=1.3)

#dev.off()

# print top ten contributors based on pedigree
#ped1.sort$ID[order(ped1.sort$ped.rank)][1:10]
# [1] "RLS-K" "WSA-K" "OK-RS" "K-SLA" "K-RSW" "SK-RG" "BK-FS" "SR-PK" "F-BPS"
#[10] "BK-LS"


# print top ten contributors based on genetic (k-statistic) analysis
#> ped1.sort$ID[order(ped1.sort$gen.rank)][1:10]
# [1] "WSA-K" "K-RSW" "GK-YS" "SR-PK" "K-SBF" "K-SLA" "SK-WB" "K-SAG" "RK-YS"
#[10] "BK-FS"

--- end R code for comparing contributions ---

--- begin R code for comparing temporal contributions by ancestral type (translocated or resident) ---

meta <- read.table("/home/tyler/Dropbox/research/jay/mosaic/metadata/jayid_map_20230512.txt",head=TRUE,sep="\t")
popdir='/home/tyler/Dropbox/research/jay/mosaic/pedigree/results/pop_temporal/'
lrdir='/home/tyler/Dropbox/research/jay/mosaic/pedigree/results/lr_temporal/'
ped <- read.table('/home/tyler/Dropbox/research/jay/mosaic/pedigree/mosaic_ped_20230512.tsv', head=TRUE, na.strings='*')

pop.n <- NULL # data frame of number of expected genomic copies in population
cohort.n <- NULL # data frame of number of expecteed genomic copies

# read in pedstat files for time points 2002-2022
time.periods = 2002:2022
tidx <- 2:(length(time.periods)+1) # these are the contribution columns in matrix
id <- NULL
n.anc = 76
for (t in time.periods) {
	fname.pop = paste0(popdir,'T_IE_20230512_',t,'_pop_contribution.pedstat1')
	if (file.exists(fname.pop)) {
		df <- read.table(fname.pop,head=TRUE)
		if (is.null(id)) id <- df[,1]
		pop.n <- cbind(pop.n, df[,2])
	} else pop.n <- cbind(pop.n,rep(NA,n.anc))

	fname.lr = paste0(lrdir,'T_IE_20230512_to_',t,'_LR_contribution.pedstat1')
	if (file.exists(fname.lr)) {
		df <- read.table(fname.lr,head=TRUE)
		if (is.null(id)) id <- df[,1]
		cohort.n <- cbind(cohort.n, df[,2])
	} else cohort.n <- cbind(cohort.n,rep(NA,n.anc))
}

# mask values of individuals if they weren't born
ped.sub <- ped[which(ped$ID %in% id),c(1,5)]
ped.sub <- ped.sub[match(id,ped.sub$ID),]
for (i in 1:length(time.periods)) {
	t = time.periods[i]
	idx <- which(ped.sub$COHORT > t)
	if (length(idx) > 0) {
		pop.n[idx,i] <- NA
		cohort.n[idx,i] <- NA
	}
}


# collect biological origin info
meta.sub <- meta[which(meta$COLOR_ID %in% id),]
meta.sub <- meta.sub[match(id, meta.sub$COLOR_ID),]
biotype <- replace(meta.sub$Biological_Origin_Status, which(meta.sub$Biological_Origin_Status == "Donor_Population"), "T")
biotype <- replace(biotype, which(biotype == "IE" | biotype == "LR"), "R")

# add annotations
pop.n <- cbind(data.frame(ID=id, BIOTYPE=biotype),as.data.frame(pop.n)) # add sample names
colnames(pop.n) <- c("ID","BIOTYPE",paste0("cohort.",time.periods))

cohort.n <- cbind(data.frame(ID=id, BIOTYPE=biotype),as.data.frame(cohort.n)) # add sample names
colnames(cohort.n) <- c("ID","BIOTYPE",paste0("cohort.",time.periods))

# make biotype data.frame of proportions
r.idx = which(biotype=="R")
t.idx = which(biotype=="T")
pop.p <- NULL # dataframe of contribution by Resident vs translocated to population
cohort.p <- NULL # dataframe of contribution by Resident vs translocated to cohort

for (i in 3:ncol(pop.n)) {
	total.copies = sum(pop.n[,i],na.rm=TRUE)
	res.copies = sum(pop.n[r.idx,i],na.rm=TRUE)
	trans.copies = sum(pop.n[t.idx,i],na.rm=TRUE)
	if (total.copies > 0) {
		res.p = res.copies/total.copies
		trans.p = trans.copies/total.copies
	} else {
		res.p = NA
		trans.p = NA	
	}
	pop.p <- rbind(pop.p, data.frame(YEAR=time.periods[i-2], RESIDENT=res.p, TRANSLOCATED=trans.p))

	total.copies.cohort = sum(cohort.n[,i],na.rm=TRUE)
	res.copies.cohort = sum(cohort.n[r.idx,i],na.rm=TRUE)
	trans.copies.cohort = sum(cohort.n[t.idx,i],na.rm=TRUE)
	if (total.copies.cohort > 0) {
		res.p.cohort = res.copies.cohort/total.copies.cohort
		trans.p.cohort = trans.copies.cohort/total.copies.cohort
	} else {
		res.p.cohort = NA
		trans.p.cohort = NA	
	}
	cohort.p <- rbind(cohort.p, data.frame(YEAR=time.periods[i-2], RESIDENT=res.p.cohort, TRANSLOCATED=trans.p.cohort))
}

# plot proportions over time

#pdf(file='/home/tyler/Dropbox/research/jay/mosaic/pedigree/results/figures/pedigree_biotype_temporal_contributions.pdf', width=16, height=7)
#png(file='/home/tyler/Dropbox/research/jay/mosaic/pedigree/results/figures/pedigree_biotype_temporal_contributions.png', width=16, height=7, units='in', res=300)
x11(width=16,height=7)
par(mgp = c(2.75,1,0))
plot(1, type="n", xlim=c(time.periods[1],time.periods[length(time.periods)]), ylim=c(0,1),
xlab="Year", ylab="Expected genetic contribution proportion", main="",xaxt='n', cex.axis=1.3, cex.lab=1.5)
axis(side=1,at=time.periods,labels=time.periods,cex=1.5,cex.axis=1.3)

lines(x=pop.p$YEAR, y=pop.p$RESIDENT, col="plum3", lwd=3, lty=1) # resident contribution to population
lines(x=pop.p$YEAR, y=pop.p$TRANSLOCATED, col="black", lwd=3, lty=1) # translocated contribution to population
lines(x=cohort.p$YEAR, y=cohort.p$RESIDENT, col="plum3", lwd=3, lty=2) # resident contribution to cohort
lines(x=cohort.p$YEAR, y=cohort.p$TRANSLOCATED, col="black", lwd=3, lty=2) # translocated contribution to cohort

# add legend

legend(x=2003,y=1.05, "Resident to population", col="plum3", lty=1, lwd=3, bty='n', cex=1.1)
legend(x=2007.5,y=1.05, "Resident to cohort", col="plum3", lty=2, lwd=3, bty='n', cex=1.1)
legend(x=2011.5,y=1.05, "Translocated to population", col="black", lty=1, lwd=3, bty='n', cex=1.1)
legend(x=2016.5,y=1.05, "Translocated to cohort", col="black", lty=2, lwd=3, bty='n', cex=1.1)

#dev.off()

--- end R code for comparing temporal contributions by ancestral type (translocated or resident) ---

--- begin R code for comparing temporal contributions by ancestral type (translocated, resident, immigrant) ---

meta <- read.table("/home/tyler/Dropbox/research/jay/mosaic/metadata/jayid_map_20230512.txt",head=TRUE,sep="\t")
popdir='/home/tyler/Dropbox/research/jay/mosaic/pedigree/results/pop_temporal/'
lrdir='/home/tyler/Dropbox/research/jay/mosaic/pedigree/results/lr_temporal/'
ped <- read.table('/home/tyler/Dropbox/research/jay/mosaic/pedigree/mosaic_ped_20230512.tsv', head=TRUE, na.strings='*')

pop.n <- NULL # data frame of number of expected genomic copies in population
cohort.n <- NULL # data frame of number of expecteed genomic copies

# read in pedstat files for time points 2002-2022
time.periods = 2002:2022
tidx <- 2:(length(time.periods)+1) # these are the contribution columns in matrix
id <- NULL
n.anc = 131
for (t in time.periods) {
	fname.pop = paste0(popdir,'T_IE_I_20230512_',t,'_pop_contribution.pedstat1')
	if (file.exists(fname.pop)) {
		df <- read.table(fname.pop,head=TRUE)
		if (is.null(id)) id <- df[,1]
		pop.n <- cbind(pop.n, df[,2])
	} else pop.n <- cbind(pop.n,rep(NA,n.anc))

	fname.lr = paste0(lrdir,'T_IE_I_20230512_to_',t,'_LR_contribution.pedstat1')
	if (file.exists(fname.lr)) {
		df <- read.table(fname.lr,head=TRUE)
		if (is.null(id)) id <- df[,1]
		cohort.n <- cbind(cohort.n, df[,2])
	} else cohort.n <- cbind(cohort.n,rep(NA,n.anc))
}

# mask values of individuals if they weren't born
ped.sub <- ped[which(ped$ID %in% id),c(1,5)]
ped.sub <- ped.sub[match(id,ped.sub$ID),]
for (i in 1:length(time.periods)) {
	t = time.periods[i]
	idx <- which(ped.sub$COHORT > t)
	if (length(idx) > 0) {
		pop.n[idx,i] <- NA
		cohort.n[idx,i] <- NA
	}
}


# collect biological origin info
meta.sub <- meta[which(meta$COLOR_ID %in% id),]
meta.sub <- meta.sub[match(id, meta.sub$COLOR_ID),]
biotype <- replace(meta.sub$Biological_Origin_Status, which(meta.sub$Biological_Origin_Status == "Donor_Population"), "T")
biotype <- replace(biotype, which(biotype == "IE" | biotype == "LR"), "R")

# add annotations
pop.n <- cbind(data.frame(ID=id, BIOTYPE=biotype),as.data.frame(pop.n)) # add sample names
colnames(pop.n) <- c("ID","BIOTYPE",paste0("cohort.",time.periods))

cohort.n <- cbind(data.frame(ID=id, BIOTYPE=biotype),as.data.frame(cohort.n)) # add sample names
colnames(cohort.n) <- c("ID","BIOTYPE",paste0("cohort.",time.periods))

# make biotype data.frame of proportions
r.idx = which(biotype=="R")
t.idx = which(biotype=="T")
i.idx = which(biotype=="I")
pop.p <- NULL # dataframe of contribution by Resident vs translocated vs immigrant to population
cohort.p <- NULL # dataframe of contribution by Resident vs translocated vs immigrant to cohort

for (i in 3:ncol(pop.n)) {
	total.copies = sum(pop.n[,i],na.rm=TRUE)
	res.copies = sum(pop.n[r.idx,i],na.rm=TRUE)
	trans.copies = sum(pop.n[t.idx,i],na.rm=TRUE)
	immi.copies = sum(pop.n[i.idx,i],na.rm=TRUE)
	if (total.copies > 0) {
		res.p = res.copies/total.copies
		trans.p = trans.copies/total.copies
		immi.p = immi.copies/total.copies
	} else {
		res.p = NA
		trans.p = NA
		immi.p = NA
	}
	pop.p <- rbind(pop.p, data.frame(YEAR=time.periods[i-2], RESIDENT=res.p, TRANSLOCATED=trans.p, IMMIGRANT=immi.p))

	total.copies.cohort = sum(cohort.n[,i],na.rm=TRUE)
	res.copies.cohort = sum(cohort.n[r.idx,i],na.rm=TRUE)
	trans.copies.cohort = sum(cohort.n[t.idx,i],na.rm=TRUE)
	immi.copies.cohort = sum(cohort.n[i.idx,i],na.rm=TRUE)
	if (total.copies.cohort > 0) {
		res.p.cohort = res.copies.cohort/total.copies.cohort
		trans.p.cohort = trans.copies.cohort/total.copies.cohort
		immi.p.cohort = immi.copies.cohort/total.copies.cohort
	} else {
		res.p.cohort = NA
		trans.p.cohort = NA
		immi.p.cohort = NA
	}
	cohort.p <- rbind(cohort.p, data.frame(YEAR=time.periods[i-2], RESIDENT=res.p.cohort, TRANSLOCATED=trans.p.cohort, IMMIGRANT=immi.p.cohort))
}

# plot proportions over time

#pdf(file='/home/tyler/Dropbox/research/jay/mosaic/pedigree/results/figures/pedigree_biotype_temporal_contributions_T_IE_I.pdf', width=16, height=7)
#png(file='/home/tyler/Dropbox/research/jay/mosaic/pedigree/results/figures/pedigree_biotype_temporal_contributions_T_IE_I.png', width=16, height=7, units='in', res=300)
x11(width=16,height=7)
par(mgp = c(2.75,1,0))
plot(1, type="n", xlim=c(time.periods[1],time.periods[length(time.periods)]), ylim=c(0,1),
xlab="Year", ylab="Expected genetic contribution proportion", main="",xaxt='n', cex.axis=1.3, cex.lab=1.5)
axis(side=1,at=time.periods,labels=time.periods,cex=1.5,cex.axis=1.3)

lines(x=pop.p$YEAR, y=pop.p$RESIDENT, col="plum3", lwd=3, lty=1) # resident contribution to population
lines(x=pop.p$YEAR, y=pop.p$TRANSLOCATED, col="black", lwd=3, lty=1) # translocated contribution to population
lines(x=pop.p$YEAR, y=pop.p$IMMIGRANT, col="paleturquoise3", lwd=3, lty=1) # immigrant contribution to population
lines(x=cohort.p$YEAR, y=cohort.p$RESIDENT, col="plum3", lwd=3, lty=2) # resident contribution to cohort
lines(x=cohort.p$YEAR, y=cohort.p$TRANSLOCATED, col="black", lwd=3, lty=2) # translocated contribution to cohort
lines(x=cohort.p$YEAR, y=cohort.p$IMMIGRANT, col="paleturquoise3", lwd=3, lty=2) # immigrant contribution to cohort

# add legend

legend(x=2014.5,y=1.05, "Resident to population", col="plum3", lty=1, lwd=3, bty='n', cex=1.1)
legend(x=2019,y=1.05, "Resident to cohort", col="plum3", lty=2, lwd=3, bty='n', cex=1.1)
legend(x=2014.5,y=1, "Translocated to population", col="black", lty=1, lwd=3, bty='n', cex=1.1)
legend(x=2019,y=1, "Translocated to cohort", col="black", lty=2, lwd=3, bty='n', cex=1.1)
legend(x=2014.5,y=0.95, "Immigrant to population", col="paleturquoise3", lty=1, lwd=3, bty='n', cex=1.1)
legend(x=2019,y=0.95, "Immigrant to cohort", col="paleturquoise3", lty=2, lwd=3, bty='n', cex=1.1)

#dev.off()

--- end R code for comparing temporal contributions by ancestral type (translocated, resident, immigrant) ---

--- begin R code for number of T and IE contributing to each cohort and demographic expansion ---

library(scales)
library(TeachingDemos) # for shadowtext
library(shape) # for arrows

meta <- read.table("/home/tyler/Dropbox/research/jay/mosaic/metadata/jayid_map_20230512.txt",head=TRUE,sep="\t")
popdir='/home/tyler/Dropbox/research/jay/mosaic/pedigree/results/pop_temporal/'
lrdir='/home/tyler/Dropbox/research/jay/mosaic/pedigree/results/lr_temporal/'
ped <- read.table('/home/tyler/Dropbox/research/jay/mosaic/pedigree/cr_ped_20230512.tsv', head=TRUE, na.strings='*')
census <- read.csv('/home/tyler/Dropbox/research/jay/mosaic/metadata/20230512_metadata/Longform_Data_05122023.tsv', head=TRUE, sep="\t")
trans_data <- read.table('/home/tyler/Dropbox/research/jay/mosaic/metadata/Translocated_Jay_Individual_Statistics.tsv',head=TRUE,sep="\t")

pop.n <- NULL # data frame of number of expected genomic copies in population
cohort.n <- NULL # data frame of number of expecteed genomic copies contributed to cohort
cohort.n.adj <- NULL # data frame of number of expected genomic copies contributed to cohort minus self-contribution (due to LR ancestors)

# read in pedstat files for time points 2002-2022
time.periods = 2002:2022
tidx <- 2:(length(time.periods)+1) # these are the contribution columns in matrix
id <- NULL
n.anc = 74
for (t in time.periods) {
	fname.pop = paste0(popdir,'T_IE_20230512_',t,'_pop_contribution.pedstat1')
	if (file.exists(fname.pop)) {
		df <- read.table(fname.pop,head=TRUE)
		if (is.null(id)) id <- df[,1]
		pop.n <- cbind(pop.n, df[,2])
	} else pop.n <- cbind(pop.n,rep(NA,n.anc))

	fname.lr = paste0(lrdir,'T_IE_20230512_to_',t,'_LR_contribution.pedstat1')
	if (file.exists(fname.lr)) {
		df <- read.table(fname.lr,head=TRUE)
		if (is.null(id)) id <- df[,1]
		cohort.n <- cbind(cohort.n, df[,2])
		# mask self contribution
		vals <- df[,2]
		for (i in 1:length(vals)) {
			ind.id = df[i,1]
			pedidx = which(ped$ID == ind.id)
			if (length(pedidx) > 0) {
				if (ped$COHORT[pedidx] == t) vals[i] = vals[i]-1 # substract one genomic copy			
			}
		}
		cohort.n.adj = cbind(cohort.n.adj, vals)
	} else {
		cohort.n <- cbind(cohort.n,rep(NA,n.anc))
		cohort.n.adj <- cbind(cohort.n.adj,rep(NA,n.anc))
	}
}

# mask values of individuals if they weren't born
ped.sub <- ped[which(ped$ID %in% id),c(1,5)]
ped.sub <- ped.sub[match(id,ped.sub$ID),]
for (i in 1:length(time.periods)) {
	t = time.periods[i]
	idx <- which(ped.sub$COHORT > t)
	if (length(idx) > 0) {
		pop.n[idx,i] <- NA
		cohort.n[idx,i] <- NA
		cohort.n.adj[idx,i] <- NA
	}
}

# add annotations
pop.n <- cbind(data.frame(ID=id),as.data.frame(pop.n)) # add sample names
colnames(pop.n) <- c("ID",paste0("cohort.",time.periods))

cohort.n <- cbind(data.frame(ID=id),as.data.frame(cohort.n)) # add sample names
colnames(cohort.n) <- c("ID",paste0("cohort.",time.periods))

cohort.n.adj <- cbind(data.frame(ID=id),as.data.frame(cohort.n.adj)) # add sample names
colnames(cohort.n.adj) <- c("ID",paste0("cohort.",time.periods))

# find Resident and translocated indices
meta.sub <- meta[meta$COLOR_ID %in% cohort.n$ID,]
meta.sub <- meta.sub[match(cohort.n$ID,meta.sub$COLOR_ID),]

tidx <- which(meta.sub$Biological_Origin_Status == "T")
ridx <- which(meta.sub$Biological_Origin_Status == "IE" | meta.sub$Biological_Origin_Status == "LR")

# counts contributors to cohorts

n.contributors <- NULL
for (j in 4:ncol(cohort.n)) {
	anc.n <- length(which(!is.na(cohort.n[,j]) & cohort.n[,j] > 0))
	trans.n <- length(which(!is.na(cohort.n[tidx,j]) & cohort.n[tidx,j] > 0))
	res.n <- length(which(!is.na(cohort.n[ridx,j]) & cohort.n[ridx,j] > 0))
	n.contributors <- rbind(n.contributors, data.frame(YEAR=time.periods[j-1], N_CONTRIBUTORS = anc.n, N_RES = res.n, N_TRANS = trans.n))
}

#> n.contributors # This is the the number of ancestral lineages present among cohorts born each year
#   YEAR N_CONTRIBUTORS N_RES N_TRANS
#1  2004             15    14       1
#2  2005              2     1       1
#3  2006              2     1       1
#4  2007              4     2       2
#5  2008              9     4       5
#6  2009              9     3       6
#7  2010             16     4      12
#8  2011             22     3      19
#9  2012             18     3      15
#10 2013             23     4      19
#11 2014              9     3       6
#12 2015             11     3       8
#13 2016             24     3      21
#14 2017             23     3      20
#15 2018             21     3      18
#16 2019             22     3      19
#17 2020             23     3      20
#18 2021             25     3      22
#19 2022             24     3      21

n.contributors.adj <- NULL
for (j in 4:ncol(cohort.n.adj)) {
	anc.n <- length(which(!is.na(cohort.n.adj[,j]) & cohort.n.adj[,j] > 0))
	trans.n <- length(which(!is.na(cohort.n.adj[tidx,j]) & cohort.n.adj[tidx,j] > 0))
	res.n <- length(which(!is.na(cohort.n.adj[ridx,j]) & cohort.n.adj[ridx,j] > 0))
	n.contributors.adj <- rbind(n.contributors.adj, data.frame(YEAR=time.periods[j-1], N_CONTRIBUTORS = anc.n, N_RES = res.n, N_TRANS = trans.n))
}


# count ancestral lineages present in the population

n.pop.lineages <- NULL
for (j in 2:ncol(pop.n)) {
	anc.n <- length(which(!is.na(pop.n[,j]) & pop.n[,j] > 0))
	trans.n <- length(which(!is.na(pop.n[tidx,j]) & pop.n[tidx,j] > 0))
	res.n <- length(which(!is.na(pop.n[ridx,j]) & pop.n[ridx,j] > 0))
	n.pop.lineages <- rbind(n.pop.lineages, data.frame(YEAR=time.periods[j-1], N_CONTRIBUTORS = anc.n, N_RES = res.n, N_TRANS = trans.n))
}

#> n.pop.lineages
#   YEAR N_CONTRIBUTORS N_RES N_TRANS
#1  2002              4     4       0
#2  2003             20    13       7
#3  2004             29    21       8
#4  2005             20    11       9
#5  2006             11     6       5
#6  2007             14     6       8
#7  2008             27     7      20
#8  2009             28     4      24
#9  2010             35     4      31
#10 2011             32     4      28
#11 2012             32     4      28
#12 2013             30     4      26
#13 2014             30     4      26
#14 2015             29     4      25
#15 2016             29     4      25
#16 2017             26     3      23
#17 2018             25     3      22
#18 2019             25     3      22
#19 2020             25     3      22
#20 2021             25     3      22
#21 2022             25     3      22


# translocations through time

trans.df <- NULL
for (t in sort(unique(trans_data$Year_Translocated))) {
	n = length(which(trans_data$Year_Translocated == t))
	site1.n <- length(which(trans_data$Year_Translocated == t & trans_data$Donor_Patch == "SITE 1"))
	site12.n <- length(which(trans_data$Year_Translocated == t & trans_data$Donor_Patch == "SITE 12"))
	site13.n <- length(which(trans_data$Year_Translocated == t & trans_data$Donor_Patch == "SITE 13"))
	site18.n <- length(which(trans_data$Year_Translocated == t & trans_data$Donor_Patch == "SITE 18"))
	tex.n <- length(which(trans_data$Year_Translocated == t & trans_data$Donor_Patch == "TEXACO"))
	trans.df <- rbind(trans.df, data.frame(YEAR=t, N_MOVED=n, SITE1_N = site1.n, SITE12_N = site12.n, SITE13_N = site13.n, SITE18_N = site18.n, TEXACO_N = tex.n))
}

#> trans.df
#  YEAR N_MOVED SITE1_N SITE12_N SITE13_N SITE18_N TEXACO_N
#1 2003       7       1        1        4        1        0
#2 2004       6       2        2        2        0        0
#3 2005       4       2        2        0        0        0
#4 2007       3       0        0        0        3        0
#5 2008      15       1        0       14        0        0
#6 2009       6       0        0        6        0        0
#7 2010      10       0        0        0        0       10

# population census size through time

# format census data

census.sub <- census[which(census$PROPERTY == "MW" | census$PROPERTY == "COKER" | census$PROPERTY == "DUETTE PRESERVE"),] # restrict census to Mosaic Wellfield, Duette Preserve, and the Coker Tract
census.sub <- census.sub[which(census.sub$Present == 1),] # remove individuals not seen
census.sub$COLOR_ID <- toupper(census.sub$COLOR_ID)
#census.sub <- census.sub[-grep("UNBAND",census.sub$COLOR_ID),] # exclude unbanded individuals

popsize <- NULL
for (t in sort(unique(census.sub$CENSUS_YEAR))) {
	n = length(unique(census.sub$COLOR_ID[which(census.sub$CENSUS_YEAR == t)]))
	popsize <- rbind(popsize, data.frame(YEAR=t, CENSUS_N = n))
}

#> popsize
#   YEAR CENSUS_N
#1  2002        4
#2  2003       20
#3  2004       33
#4  2005       20
#5  2006       14
#6  2007       18
#7  2008       32
#8  2009       41
#9  2010       56
#10 2011       82
#11 2012       89
#12 2013       79
#13 2014       70
#14 2015       69
#15 2016       75
#16 2017      103
#17 2018      129
#18 2019      143
#19 2020      137
#20 2021      144
#21 2022      134


# plot census data

# limit data to years 2003+ for plotting
time.periods2 <- time.periods[2:length(time.periods)]
popsize.sub <- popsize[which(popsize$YEAR > 2002),]

#pdf(file='/home/tyler/Dropbox/research/jay/mosaic/pedigree/results/figures/temporal_census_size.pdf', width=16, height=7) # deprecated
#png(file='/home/tyler/Dropbox/research/jay/mosaic/pedigree/results/figures/temporal_census_size.png', width=16, height=7, units='in', res=300) # deprecated
#png(file='/home/tyler/Dropbox/research/jay/mosaic/figures/temporal_census_size.png', width=16, height=7, units='in', res=300) # counts self-contribution
#pdf(file='/home/tyler/Dropbox/research/jay/mosaic/figures/temporal_census_size.pdf', width=16, height=7) # counts self-contribution
#png(file='/home/tyler/Dropbox/research/jay/mosaic/figures/temporal_census_size_adjusted.png', width=16, height=7, units='in', res=300) # does not count self-contribution
#pdf(file='/home/tyler/Dropbox/research/jay/mosaic/figures/temporal_census_size_adjusted.pdf', width=16, height=7) # does not count self-contribution
#png(file='/home/tyler/Dropbox/research/jay/mosaic/figures/temporal_census_size_adjusted_2003_2022.png', width=16, height=7, units='in', res=300) # does not count self-contribution
x11(width=16,height=7)
par(mgp = c(2.75,1,0))
#plot(1, type="n", xlim=c(time.periods[1],time.periods[length(time.periods)]), ylim=c(0,max(popsize$CENSUS_N)+5),xlab="Year", ylab="Number individuals", main="",xaxt='n', cex.axis=1.3, cex.lab=1.5)
plot(1, type="n", xlim=c(time.periods2[1]-0.5,time.periods2[length(time.periods2)]), ylim=c(0,max(popsize.sub$CENSUS_N)+5),xlab="Year", ylab="Number individuals", 
main="",xaxt='n', cex.axis=1.3, cex.lab=1.5, xaxt='n')
#axis(side=1,at=time.periods,labels=time.periods,cex=1.5,cex.axis=1.3)
axis(side=1,at=time.periods2,labels=time.periods2,cex=1.5,cex.axis=1.3)
axis(side=2,at=seq(from=0,to=150,by=25),labels=seq(from=0,to=150,by=25),cex=1.5,cex.axis=1.3)

#lines(x=popsize$YEAR, y=popsize$CENSUS_N, lwd=2)
#points(x=popsize$YEAR, y=popsize$CENSUS_N, pch=21, bg=alpha("black",0.5), col="black", cex=1.7, lwd=2)
lines(x=popsize.sub$YEAR, y=popsize.sub$CENSUS_N, lwd=2)
points(x=popsize.sub$YEAR, y=popsize.sub$CENSUS_N, pch=21, bg=alpha("black",0.5), col="black", cex=1.7, lwd=2)

# add arrows for translocations
for (t in trans.df$YEAR) {
	#idx = which(popsize$YEAR == t)
	#y = popsize$CENSUS_N[idx]
	idx = which(popsize.sub$YEAR == t)
	y = popsize.sub$CENSUS_N[idx]
	n = trans.df$N_MOVED[which(trans.df$YEAR == t)]
	Arrows(x0=t, x1=t, y0=y+35, y1=y+10, col="black", lwd=2, arr.type="triangle", arr.width=0.25)
	text(x=t, y=y+42, labels=n, cex=1.5)
}

#rect(xleft=2001.6, ybottom=42, xright=2003.6, ytop=48.5, col="white", border=NA)
#text(x=2002.29, y=52, labels="Number", cex=1.3)
#text(x=2002.6, y=46, labels="translocated", cex=1.3)

rect(xleft=2002.6, ybottom=38, xright=2003.6, ytop=50, col="white", border=NA)
text(x=2002.8, y=47, labels="Number", cex=1.3)
text(x=2002.8, y=41, labels="translocated", cex=1.3)

# add number of unadjusted Residents contributing to cohorts
#res.offset= -0.75
#lines(x=n.contributors$YEAR, y=n.contributors$N_RES, col=alpha("palevioletred3",0.6), lwd=2, lty=5)
#text(x=n.contributors$YEAR, y=n.contributors$N_RES+res.offset, labels=n.contributors$N_RES, col="palevioletred3", cex=1.5, font=2) # use font=2 for bold

# add number unadjusted Translocaed contributing to cohort
#trans.offset = 0.75
#lines(x=n.contributors$YEAR, y=n.contributors$N_TRANS, col=alpha("royalblue",0.6), lwd=2, lty=5)
#text(x=n.contributors$YEAR, y=n.contributors$N_TRANS+trans.offset, labels=n.contributors$N_TRANS, col="royalblue",cex=1.5, font=2) # use font=2 for bold

# add number of adjusted Residents contributing to cohorts (discounts self-contribution)
res.offset= -0.75
lines(x=n.contributors.adj$YEAR, y=n.contributors.adj$N_RES, col=alpha("palevioletred3",0.6), lwd=2, lty=5)
text(x=n.contributors.adj$YEAR, y=n.contributors.adj$N_RES+res.offset, labels=n.contributors.adj$N_RES, col="palevioletred3", cex=1.5, font=2) # use font=2 for bold

# add number adjusted Translocaed contributing to cohort (discounts self contribution)
trans.offset = 0.75
lines(x=n.contributors.adj$YEAR, y=n.contributors.adj$N_TRANS, col=alpha("royalblue",0.6), lwd=2, lty=5)
text(x=n.contributors.adj$YEAR, y=n.contributors.adj$N_TRANS+trans.offset, labels=n.contributors.adj$N_TRANS, col="royalblue",cex=1.5, font=2) # use font=2 for bold

# add legend
#grid(nx=110, ny=50, lty=2) # for aligning things
#legend(x=2001.2,y=157, legend="Population size", lty=1, lwd=2, col="black", bty='n', cex=1.3)
#points(x=2001.76, y=149, pch=21, bg=alpha("black",0.5), col="black", cex=1.7, lwd=2)
#legend(x=2005.2,y=157, legend="Resident contributors", lty=5, lwd=2, col="palevioletred3", bty='n', cex=1.3)
#legend(x=2010.15,y=157, legend="Translocated contributors", lty=5, lwd=2, col="royalblue", bty='n', cex=1.3)

legend(x=2002,y=157, legend="Population size", lty=1, lwd=2, col="black", bty='n', cex=1.3)
points(x=2002.56, y=149, pch=21, bg=alpha("black",0.5), col="black", cex=1.7, lwd=2)
legend(x=2006,y=157, legend="Resident contributors", lty=5, lwd=2, col="palevioletred3", bty='n', cex=1.3)
legend(x=2010.95,y=157, legend="Translocated contributors", lty=5, lwd=2, col="royalblue", bty='n', cex=1.3)

#dev.off()

--- end R code for number of T and IE contributing to each cohort and demographic expansion ---

--- begin R code for 2022 population contribution stats ---

x2022 <- read.table('/home/tyler/Dropbox/research/jay/mosaic/pedigree/results/pop_temporal/T_IE_20230512_2022_pop_contribution.pedstat1',head=TRUE)

mean(x2022$P_ANC_FOCAL)
#[1] 0.0131579 # average relative ancestral contribution

length(which(x2022$P_ANC_FOCAL > mean(x2022$P_ANC_FOCAL)))
[1] 22 # number of ancestors contributinig more than the average relative contribution 

length(which(x2022$P_ANC_FOCAL > 2*mean(x2022$P_ANC_FOCAL)))
[1] 11 # number of ancestors providing more than twice the average contribution
 
mean(x2022$N_GENOME_COPIES)
[1] 1.565867 # expected number of genomic copies per ancestor in the 2022 cohort (average number of expected genomic copies) 

x2022$N_GENOME_COPIES[which(x2022$ID == "RLS-K")]/mean(x2022$N_GENOME_COPIES)
[1] 11.18588 # contribution of RLK-K relative to the average ancestral contribution

x2022$N_GENOME_COPIES[which(x2022$ID == "WSA-K")]/mean(x2022$N_GENOME_COPIES)
[1] 8.12253 # contribution of WSA-K relative to the average ancestal contribution

length(which(x2022$N_GENOME_COPIES > 5*mean(x2022$N_GENOME_COPIES)))
[1] 4 # number of ancestors providing more than 5x the average ancestral contribution

x2022$N_GENOME_COPIES[which(x2022$ID == "K-SLA")]
[1] 10.4531 # number expected genomic copies provided by K-SLA

x2022$N_GENOME_COPIES[which(x2022$ID == "K-SLA")]/mean(x2022$N_GENOME_COPIES)
[1] 6.6756 # contribution of SLA-K relative to the average ancestral contribution

x2022$N_GENOME_COPIES[which(x2022$ID == "OK-RS")]/mean(x2022$N_GENOME_COPIES)
[1] 5.807487 # contribution of OK-RS relative to the average ancestral contribution

--- end R code for 2022 population contribution stats ---

--- begin R code for relatedness between breeding pairs ---

library(scales)

ped <- read.table('/home/tyler/Dropbox/research/jay/mosaic/pedigree/mosaic_ped_20230512.tsv', head=TRUE, na.strings='*')
nesting <- read.table('/home/tyler/Dropbox/research/jay/mosaic/metadata/20230512_metadata/CUMULATIVE_NESTING_DATA_FINAL_05122023.tsv',head=TRUE,sep="\t")
rmat.ped <- as.matrix(read.table('/home/tyler/Dropbox/research/jay/mosaic/pedigree/mosaic_ped_20230512_relatedness_matrix.txt',head=TRUE))
rmat.gen <- as.matrix(read.table('/home/tyler/Dropbox/research/jay/mosaic/popgen/relatedness/fsj_mosaic_biallelic_snps_main_autosomes_qc_relatedness_matrix_relateStats_input.txt', head=TRUE))
jayid <- read.table('/home/tyler/Dropbox/research/jay/mosaic/metadata/jayid_map_20230512.txt', head=TRUE, sep="\t")

# format nesting data
nesting$Property <- toupper(nesting$Property)
nesting$Breeding_Male <- toupper(nesting$Breeding_Male)
nesting$Breeding_Female <- toupper(nesting$Breeding_Female)
exidx <- c(grep(paste(c("NONE","UNBAND","UNBD","UNB","NOBAND","UNKNOWN"),collapse="|"), nesting$Breeding_Male), grep(paste(c("NONE","UNBAND","UNBD","UNB","NOBAND","UNKNOWN"),collapse="|"), nesting$Breeding_Female))
nest.sub <- nesting[-exidx,]
nest.sub <- nest.sub[-which(nest.sub$ERROR_FLAG == 1),]
nest.sub <- nest.sub[which(nest.sub$Property == "MW" | nest.sub$Property == "COKER" | nest.sub$Property == "DUETTE"),]
nest.sub$Number_Fledged[which(nest.sub$Number_Fledged == "FAILED" | nest.sub$Number_Fledged == "ABANDONED")] <- 0
nest.sub$Number_Fledged[which(nest.sub$Number_Fledged == "UNKNOWN")] <- NA
nest.sub$Number_Fledged <- as.numeric(nest.sub$Number_Fledged)

# format pedigree relatedness matrix
colnames(rmat.ped) <- gsub(".","-",colnames(rmat.ped), fixed=TRUE)
rownames(rmat.ped) <- colnames(rmat.ped)

# format genetic relatedness matrix
colnames(rmat.gen) <- unname(sapply(colnames(rmat.gen),function(x,df){id = df$COLOR_ID[which(df$LAB_ID == x)]; ifelse(id == "*", x, id)},df=jayid))
rownames(rmat.gen) <- colnames(rmat.gen)

# make dataframe of relatedness between pairs and the number of offspring fledged each year

breeder.r <- NULL

for (i in 1:nrow(nest.sub)) {
	male <- nest.sub$Breeding_Male[i]
	female <- nest.sub$Breeding_Female[i]
	year <- nest.sub$YEAR[i]
	nfledge <- nest.sub$Number_Fledged[i]
	idx <- which(breeder.r$FATHER == male & breeder.r$MOTHER == female & breeder.r$YEAR == year)
	if (length(idx) > 0) {
		# pair attempt for current year has already been logged
		if (nfledge > 0) {
			if (is.na(breeder.r$NUM_FLEDGE[idx])) breeder.r$NUM_FLEDGE[idx] = nfledge else breeder.r$NUM_FLEDGE[idx] = breeder.r$NUM_FLEDGE[idx] + nfledge
 
		}
	} else {
		# first recorded attempt for pair in current year
		# check if parent information exists for pair
		father.idx <- which(ped$ID == male)
		mother.idx <- which(ped$ID == female)
		if (length(father.idx) == 0 || length(mother.idx) == 0) next
		ff <- ped$SIRE_ID[father.idx]
		fm <- ped$DAM_ID[father.idx]
		mf <- ped$SIRE_ID[mother.idx]
		mm <- ped$DAM_ID[mother.idx]
		r = NA
		if (is.na(ff) || is.na(fm) || is.na(mf) || is.na(mm)) {
			# parental information for breeding pair is missing, so will use genetic relatedness
			idx.f = which(rownames(rmat.gen) == male)
			idx.m = which(colnames(rmat.gen) == female)
			if (length(idx.f) > 0 && length(idx.m) > 0) r = rmat.gen[idx.f,idx.m]
		} else {
			idx.f = which(rownames(rmat.ped) == male)
			idx.m = which(rownames(rmat.ped) == female)
			if (length(idx.f) > 0 && length(idx.m) > 0) r = rmat.ped[idx.f,idx.m]		
		}
		# record pair
		breeder.r <- rbind(breeder.r, data.frame(YEAR=year, MALE=male, FEMALE=female, RELATEDNESS=r, NUM_FLEDGE=nfledge))
	}
}

# subset of breeders that fledge offspring
breeder.r.fledge <- breeder.r[which(!is.na(breeder.r$NUM_FLEDGE) & breeder.r$NUM_FLEDGE > 0),]

# data.frame of relatedness stats by year
breeder.stats <- NULL
for (t in sort(unique(breeder.r$YEAR))) {
	breeder.sub <- breeder.r[which(breeder.r$YEAR == t),]
	all_breeders = nrow(breeder.sub)
	avg_r_all = mean(breeder.sub$RELATEDNESS,na.rm=TRUE)
	var_r_all = var(breeder.sub$RELATEDNESS,na.rm=TRUE)
	breeders.sub.fledge <- breeder.sub[which(!is.na(breeder.sub$NUM_FLEDGE) & breeder.sub$NUM_FLEDGE > 0),]
	n_fledgers = nrow(breeders.sub.fledge)
	avg_r_fledge = mean(breeders.sub.fledge$RELATEDNESS, na.rm=TRUE)
	var_r_fledge = var(breeders.sub.fledge$RELATEDNESS, na.rm=TRUE)
	breeder.stats <- rbind(breeder.stats, data.frame(YEAR=t, N_PAIRS=all_breeders, AVG_R_ALL = avg_r_all, VAR_R_ALL = var_r_all, N_FLEDGING_PAIRS=n_fledgers, AVG_R_FLEDGE = avg_r_fledge, VAR_R_FLEDGE = var_r_fledge))
}

# plot

time.periods=sort(unique(breeder.r.fledge$YEAR))

nf <- NULL # number of fledging pairs in each time period
for (t in time.periods) {
	n = length(which(breeder.r$YEAR == t & !is.na(breeder.r$RELATEDNESS) & !is.na(breeder.r$NUM_FLEDGE) & breeder.r$NUM_FLEDGE > 0))
	nf <- c(nf,n)
}

set.seed(5329875)
#png(file='/home/tyler/Dropbox/research/jay/mosaic/pedigree/results/figures/temporal_fledging_pair_relatedness.png', width=17, height=7, units='in', res=300)
x11(width=17,height=7)
par(mgp = c(2.75,1,0))
plot(1, type="n", xlim=c(min(time.periods),max(time.periods)), ylim=c(0,max(breeder.r.fledge$RELATEDNESS,na.rm=TRUE)),xlab="", ylab="Breeding pair relatedness", main="",xaxt='n', cex.axis=1.3, cex.lab=1.5)
title(xlab="Year and number of pairs that fledged offspring", line=3.5, cex.lab=1.5)
axis(side=1,at=time.periods,labels=paste(time.periods,"\nn = ",nf,sep=""),cex=1.5,cex.axis=1.3, padj=0.5)
abline(v=time.periods, col="gray85", lty=2)
abline(h=seq(from=0,to=signif(max(breeder.r.fledge$RELATEDNESS,na.rm=TRUE),1),by=0.1), col="gray90", lty=2)
points(x=jitter(breeder.r.fledge$YEAR,0.5),y=breeder.r.fledge$RELATEDNESS, pch=21, bg=alpha("grey20",0.4), col="black", lwd=1.1, cex=1.7)

# add trend line
linear.fit <- lm(breeder.r.fledge$RELATEDNESS~breeder.r.fledge$YEAR)
abline(linear.fit, lwd=1.3,col=alpha("black",0.8))
text(x=2007,y=0.12,labels=bquote(beta == .(signif(linear.fit$coefficients[2],1))),cex=1.3)

#dev.off()

--- end R code for relatedness between breeding pairs ---
