#############################################################################################
# This document contains code for analyzing data in the Linderoth et al. study              #
# titled "translocations spur population growth but exacerbate inbreeding in an imperiled   #
# species".                                                                                 #
#                                                                                           #
# Author contact: lindero1@msu.edu                                                          #
#############################################################################################

Bash code ran interactively (for launching jobs, etc.) are prefixed with '$'.

## ---------- UNIVERSAL R FUNCTIONS ---------- ##

pointcodes <- function(df = NULL) {
  site_code <- replace(as.character(df$site),which(df$site == "Wellfield"), "119") # W
  site_code <- replace(site_code, which(site_code == "SITE_1"), "0") # open square
  site_code <- replace(site_code,which(site_code == "SITE_13"), "1") # open circle
  site_code <- replace(site_code,which(site_code == "SITE_12"), "2") # open upwards triangle
  site_code <- replace(site_code,which(site_code == "SITE_18"), "5") # open diamond
  site_code <- replace(site_code,which(site_code == "TEXACO"), "6") # open downward triangle
  site_code <- replace(site_code,which(site_code == "Golden_Aster_Scrub"), "3") # plus
  site_code <- replace(site_code,which(site_code == "Brigman"), "4") # cross
  site_code <- replace(site_code,which(site_code == "Duette_headwaters"), "8") # asterisk
  site_code <- replace(site_code,which(site_code == "Sun_City"), "35") # pound
  site_code <- replace(site_code,which(site_code == "W.Balm"), "38") # ampersand
  site_code <- replace(site_code,which(site_code == "missing"), "36") # dollar
  return(as.numeric(site_code))
}

pointletters <- function(df = NULL) {
  site_code <- replace(as.character(df$site),which(df$site == "Wellfield"), "W")
  site_code <- replace(site_code, which(site_code == "SITE_1"), "1")
  site_code <- replace(site_code,which(site_code == "SITE_13"), "3")
  site_code <- replace(site_code,which(site_code == "SITE_12"), "2")
  site_code <- replace(site_code,which(site_code == "SITE_18"), "8")
  site_code <- replace(site_code,which(site_code == "TEXACO"), "X")
  site_code <- replace(site_code,which(site_code == "Golden_Aster_Scrub"), "G")
  site_code <- replace(site_code,which(site_code == "Brigman"), "B")
  site_code <- replace(site_code,which(site_code == "Duette_headwaters"), "D")
  site_code <- replace(site_code,which(site_code == "Sun_City"), "S")
  site_code <- replace(site_code,which(site_code == "W.Balm"), "A")
  #site_code <- replace(site_code,which(site_code == "missing"), "M")
  site_code <- replace(site_code,which(site_code == "missing"), "U") # unbanded birds have missing locations
  return(site_code)
}

popletters <- function(df = NULL) {
  pop_code <- replace(as.character(df$pop),which(df$pop == "Resident"), "R")
  pop_code <- replace(pop_code,which(pop_code == "Contemporary"), "C")
  pop_code <- replace(pop_code, which(pop_code == "SITE_1"), "1")
  pop_code <- replace(pop_code,which(pop_code == "SITE_13"), "3")
  pop_code <- replace(pop_code,which(pop_code == "SITE_12"), "2")
  pop_code <- replace(pop_code,which(pop_code == "SITE_18"), "8")
  pop_code <- replace(pop_code,which(pop_code == "TEXACO"), "X")
  pop_code <- replace(pop_code,which(pop_code == "Golden_Aster_Scrub"), "G")
  pop_code <- replace(pop_code,which(pop_code == "Brigman"), "B")
  pop_code <- replace(pop_code,which(pop_code == "Duette_headwaters"), "D")
  pop_code <- replace(pop_code,which(pop_code == "Sun_City"), "S")
  pop_code <- replace(pop_code,which(pop_code == "W.Balm"), "A")
  return(pop_code)
}

popnames <- function(df = NULL) {
  pop_names <- replace(as.character(df$pop),which(df$pop == "Resident"), "Resident")
  pop_names <- replace(pop_names,which(pop_names == "Contemporary"), "Contemporary")
  pop_names <- replace(pop_names, which(pop_names == "SITE_1"), "Site 1")
  pop_names <- replace(pop_names,which(pop_names == "SITE_13"), "Site 13")
  pop_names <- replace(pop_names,which(pop_names == "SITE_12"), "Site 12")
  pop_names <- replace(pop_names,which(pop_names == "SITE_18"), "Site 18")
  pop_names <- replace(pop_names,which(pop_names == "TEXACO"), "Texaco")
  pop_names <- replace(pop_names,which(pop_names == "Golden_Aster_Scrub"), "Golden Aster Scrub")
  pop_names <- replace(pop_names,which(pop_names == "Brigman"), "Brigman")
  pop_names <- replace(pop_names,which(pop_names == "Duette_headwaters"), "Duette headwaters")
  pop_names <- replace(pop_names,which(pop_names == "Sun_City"), "Sun City")
  pop_names <- replace(pop_names,which(pop_names == "W.Balm"), "W. Balm")
  return(pop_names)
}


pntcol <- function(x = NULL) {
  if (length(grep("scales",(.packages()))) == 0) library(scales)
  color = NULL
  if (class(x) == "data.frame") {
    color = as.character(x$type)
  } else if (class(x) == "character") {
    color = x
  } else {
    stop("Invalid input type")
  }
  #color <- replace(color,which(color == "C"),"red")
  color <- replace(color,which(color == "C"),"violet")
  #color <- replace(color,which(color == "E"),"lightseagreen")
  color <- replace(color,which(color == "E"),"slateblue4")
  #color <- replace(color,which(color == "I"),"gold4")
  color <- replace(color,which(color == "I"),"tomato")
  #color <- replace(color,which(color == "M4"),"purple")
  color <- replace(color,which(color == "M4"),"royalblue1")	
  #color <- replace(color,which(color == "T"),"navy")
  color <- replace(color,which(color == "T"),"seagreen")
  return(color)
}

sitecol <- function(x = NULL) {
  #if (length(grep("scales",(.packages()))) == 0) library(scales)
  type.loc = paste0(x$type,"_",x$site)
  color = type.loc
  color <- replace(color, which(color == "C_Wellfield"), "violet")
  color <- replace(color, which(color == "E_Wellfield"), "slateblue4")
  color <- replace(color, which(color == "T_SITE_1"), "limegreen")
  #color <- replace(color, which(color == "T_SITE_13"), "yellow2")
  color <- replace(color, which(color == "T_SITE_13"), "gold2")
  #color <- replace(color, which(color == "T_SITE_12"), "magenta3")
  color <- replace(color, which(color == "T_SITE_12"), "maroon4")
  color <- replace(color, which(color == "T_SITE_18"), "dodgerblue1")
  color <- replace(color, which(color == "T_TEXACO"), "darkslategrey")
  color <- replace(color, which(color == "I_missing" | color == "U_missing"), "tomato")
  color <- replace(color, which(color == "M4_Duette_headwaters"), "black")
  color <- replace(color, which(color == "M4_Brigman"), "sienna")
  color <- replace(color, which(color == "M4_Golden_Aster_Scrub"), "olivedrab")
  color <- replace(color, which(color == "M4_W.Balm"), "red3")
  color <- replace(color, which(color == "M4_Sun_City"), "purple1")
}

popcolor <- function(x = NULL) {
  #if (length(grep("scales",(.packages()))) == 0) library(scales)
  color = x$pop
  color <- replace(color, which(color == "Contemporary"), "violet")
  color <- replace(color, which(color == "Resident"), "slateblue4")
  color <- replace(color, which(color == "SITE_1"), "limegreen")
  color <- replace(color, which(color == "SITE_13"), "gold2")
  color <- replace(color, which(color == "SITE_12"), "maroon4")
  color <- replace(color, which(color == "SITE_18"), "dodgerblue1")
  color <- replace(color, which(color == "TEXACO"), "darkslategrey")
  color <- replace(color, which(color == "Duette_headwaters"), "tomato")
  color <- replace(color, which(color == "Brigman"), "sienna")
  color <- replace(color, which(color == "Golden_Aster_Scrub"), "olivedrab")
  color <- replace(color, which(color == "W.Balm"), "red3")
  color <- replace(color, which(color == "Sun_City"), "purple1")
}

biopoint <- function(x = NULL) {
	ptcode = replace(x,which(x == "Contemporary" | x == "Resident"),"21")
	ptcode = replace(ptcode,which(ptcode == "SITE_1" | ptcode == "SITE_12" | ptcode == "SITE_13" | ptcode == "SITE_18" | ptcode == "TEXACO"), "24")
	ptcode = replace(ptcode,which(ptcode == "Golden_Aster_Scrub" | ptcode == "Brigman" | ptcode == "W.Balm" | ptcode == "Duette_headwaters" | ptcode == "Sun_City"), "22")
	return(as.numeric(ptcode))
}

h_boxplot2 <- function(x=NULL, n=NULL, lev=grplevels, ylabel="Heterozygosity", pntlab=NULL, seed=10287, color=NULL, ylimits=NULL, idlabels=NULL) {
	if (length(grep("TeachingDemos",(.packages()))) == 0) library(TeachingDemos) # for shadowtext()
	nlevel = length(lev)

	par(mar=c(5,5,2,2))
	boxplot(x[,n] ~ group, data=x, outline=FALSE, names=c(rep("",nlevel)), xlab="", ylab=ylabel, main="", col="gray80", cex.axis=1.5, cex.lab=1.5, lwd=2, ylim=ylimits)
	mtext(c(lev[1:3],paste("Other","M4",sep="\n")), 1,at=1:nlevel, padj=1, cex=1.5)

	# add points
	for (i in lev) {
		idx = which(as.character(x$group) == i)
		set.seed(seed)
		xjitter = jitter(rep(which(lev == i),length(idx)), amount=0.2)
		ptcol = NULL
		for (j in 1:length(idx)) {
			if (is.null(color)) ptcol = alpha("maroon",0.5) else ptcol = alpha(color[idx[j]],0.5)
			if (is.null(pntlab) || is.na(pntlab[idx[j]])) {
				if (!is.null(idlabels)) {
				  text(y=x[idx[j],n], x=xjitter[j],idlabels[idx[j]],cex=0.5,col="red")
				} else {
				  points(y=x[idx[j],n], x=xjitter[j], pch=1, cex=1.2)
				  points(y=x[idx[j],n], x=xjitter[j], pch=16, cex=1.2, col=ptcol)
				}
			} else if (class(pntlab) == "numeric") {
				points(y=x[idx[j],n], x=xjitter[j], pch=pntlab[idx[j]], col="black", bg=alpha(color[idx[j]],0.65),lwd=1.3,cex=1.5)
			}  else if (class(pntlab) == "character") {
				shadowtext(y=x[idx[j],n], x=xjitter[j], labels=pntlab[idx[j]], col=color[idx[j]], bg=alpha("black",0.5), r=0.07, cex=1.2)	
			} else stop("Unknown argument to pntlab")
		}
	}

}


## ---------- RAW FASTQ QUALITY CONTROL ---------- ##

## Assess quality of raw fastq files

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/fastq/raw_data/qc/fastqc_array.sh
implements:

--- start bash code ---

EXEC='fastqc'
ADAPTERFILE='/mnt/research/Fitz_Lab/projects/mosaic/raw_data/qc/novogene_adapter_file.txt'
FQLIST='/mnt/research/Fitz_Lab/projects/mosaic/raw_data/raw_fastq_list.txt'
FQFILE=$(sed -n "${SLURM_ARRAY_TASK_ID}p" "$FQLIST")
OUTDIR='/mnt/research/Fitz_Lab/projects/mosaic/raw_data/qc'

CMD="$EXEC -o $OUTDIR -f fastq -a $ADAPTERFILE $FQFILE"

printf "\n%s\n\n" "$CMD"

eval $CMD

--- end bash code ---

## Perfrom quality control of raw reads

# Collate each samples reads that were produced across multiple lanes

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/fastq/process_reads/cat_runs/cat_fastq_array.sh
implements:

--- start bash code ---

EXEC='/mnt/research/Fitz_Lab/projects/mosaic/processed_reads/cat_runs/catFastq.sh'
DIRLIST='/mnt/research/Fitz_Lab/projects/mosaic/processed_reads/cat_runs/fastq_dirs.txt'
FQDIR=$(sed -n "${SLURM_ARRAY_TASK_ID}p" "$DIRLIST")

CMD="$EXEC $FQDIR /mnt/gs18/scratch/users/lindero1/mosaic/cat_reads"

printf "\n%s\n\n" "$CMD"

eval $CMD

--- end bash code ---


# Remove duplicate reads

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/fastq/process_reads/deduplicate/deduplicate_reads_array.sh
implements:

--- start bash code ---

EXEC='hts_SuperDeduper'
FQLIST='/mnt/research/Fitz_Lab/projects/mosaic/processed_reads/deduplicate/fastq_prefixes.txt'
FQPREFIX=$(sed -n "${SLURM_ARRAY_TASK_ID}p" "$FQLIST")
FQFWD="${FQPREFIX}_1.fq.gz"
FQREV="${FQPREFIX}_2.fq.gz"
LIBPREFIX=$(echo $FQPREFIX | perl -e '$line = <>; print $1 if $line =~ /([^\/]+)$/')
OUTPREFIX="/mnt/gs18/scratch/users/lindero1/mosaic/deduplicated_reads/${LIBPREFIX}"
LOGFILE="/mnt/research/Fitz_Lab/projects/mosaic/processed_reads/deduplicate/logs/${LIBPREFIX}_stats.log"

CMD="$EXEC -L $LOGFILE -1 $FQFWD -2 $FQREV -f $OUTPREFIX -s 12 -l 10 -q 30 -a 5"

printf "\n%s\n\n" "$CMD"

eval $CMD

--- end bash code ---


# Trim adapters and remove excessively short reads after trimming

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/fastq/process_reads/adapter_trim/rmv_adapters_array.sh
implements:

--- start bash code ---

EXEC='cutadapt'
FQLIST='/mnt/research/Fitz_Lab/projects/mosaic/mosiac_samples.txt'
FQDIR='/mnt/gs18/scratch/users/lindero1/mosaic/deduplicated_reads'
FQPREFIX=$(sed -n "${SLURM_ARRAY_TASK_ID}p" "$FQLIST")
FQFWD="${FQDIR}/${FQPREFIX}_R1.fastq.gz"
FQREV="${FQDIR}/${FQPREFIX}_R2.fastq.gz"
OUTDIR="/mnt/gs18/scratch/users/lindero1/mosaic/adapter_trim"
OUTFWD="${OUTDIR}/${FQPREFIX}_R1.fastq.gz"
OUTREV="${OUTDIR}/${FQPREFIX}_R2.fastq.gz"

CMD="$EXEC -a AGATCGGAAGAGCACACGTCTGAACTCCAGTCA -A AGATCGGAAGAGCGTCGTGTAGGGAAAGAGTGT --overlap 3 --trim-n --minimum-length 70 -o $OUTFWD -p $OUTREV $FQFWD $FQREV"

printf "\n%s\n\n" "$CMD"

eval $CMD

--- end bash code ---


# Merge overlapping read pairs

$ /mnt/research/Fitz_Lab/projects/mosaic/fastq/process_reads/merge/merge_reads_array.sh
implements:

--- start bash code ---

EXEC='pear'
FQLIST='/mnt/research/Fitz_Lab/projects/mosaic/mosiac_samples.txt'
FQDIR='/mnt/gs18/scratch/users/lindero1/mosaic/adapter_trim'
FQPREFIX=$(sed -n "${SLURM_ARRAY_TASK_ID}p" "$FQLIST")
FQFWD="${FQDIR}/${FQPREFIX}_R1.fastq.gz"
FQREV="${FQDIR}/${FQPREFIX}_R2.fastq.gz"
OUTPREFIX="/mnt/gs18/scratch/users/lindero1/mosaic/merged_reads/${FQPREFIX}"

CMD="$EXEC -f $FQFWD -r $FQREV -o $OUTPREFIX -p 0.001 -v 10 -m 299 -n 70 -g 1 -s 2 -k"

printf "\n%s\n\n" "$CMD"

eval $CMD

--- end bash code ---

## Evaulate the effectiveness of quality control by comparing quality metrics of raw fastqs (after merging reads from multiple lanes for a sample)
## to those of cleaned fastqs

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/fastq/process_reads/clean_eval/eval_array.sh
implements:

--- start bash code ---

EXEC='/mnt/research/Fitz_Lab/projects/mosaic/fastq/process_reads/clean_eval/evalLibs.pl'
FQLIST='/mnt/research/Fitz_Lab/projects/mosaic/mosiac_samples.txt'
CLEAN_FQDIR='/mnt/research/Fitz_Lab/projects/mosaic/fastq/clean_reads'
RAW_FQDIR='/mnt/gs18/scratch/users/lindero1/mosaic/cat_reads'
FQPREFIX=$(sed -n "${SLURM_ARRAY_TASK_ID}p" "$FQLIST")
RAW_FQFWD="${RAW_FQDIR}/${FQPREFIX}_1.fq.gz"
RAW_FQREV="${RAW_FQDIR}/${FQPREFIX}_2.fq.gz"
CLEAN_FQFWD="${CLEAN_FQDIR}/${FQPREFIX}_R1.fastq.gz"
CLEAN_FQREV="${CLEAN_FQDIR}/${FQPREFIX}_R2.fastq.gz"
OUTFILE="/mnt/research/Fitz_Lab/projects/mosaic/fastq/process_reads/clean_eval/clean/${FQPREFIX}_eval.txt"

CMD="$EXEC --raw $RAW_FQFWD $RAW_FQREV --clean $CLEAN_FQFWD $CLEAN_FQREV --library $FQPREFIX > $OUTFILE"

printf "\n%s\n\n" "$CMD"

eval $CMD

--- end bash code ---

## Split reads for individuals back into respective lanes so that lane information for read groups can be tracked when mapping

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/fastq/process_reads/split_reads_array.sh
implements:

--- start bash code ---

EXEC='/mnt/research/Fitz_Lab/projects/mosaic/fastq/process_reads/splitFastqLanes.pl'
FQLIST='/mnt/research/Fitz_Lab/projects/mosaic/mosiac_samples.txt'
FQDIR='/mnt/research/Fitz_Lab/projects/mosaic/fastq/clean_reads'
OUTDIR='/mnt/gs18/scratch/users/lindero1/mosaic/split_reads'
FQPREFIX=$(sed -n "${SLURM_ARRAY_TASK_ID}p" "$FQLIST")

CMD="$EXEC $FQPREFIX $FQDIR $OUTDIR"
printf "\n%s\n" "$CMD"
eval $CMD

--- end bash code ---

## ---------- MAP READS TO REFERENCE GENOME ---------- ##

## Map clean reads to the FSJ V3 reference genome

This step also marks residual duplicate reads.

$ /mnt/research/Fitz_Lab/projects/mosaic/map/map_reads_array.sh
implements:

--- start bash code ---

EXEC='/mnt/research/Fitz_Lab/projects/mosaic/map/map_reads.sh'
REF='/mnt/research/Fitz_Lab/ref/bird/FSJ_V3/FSJ.V3.fa'
FQLIST='/mnt/research/Fitz_Lab/projects/mosaic/mosiac_ids.txt'
FQDIR='/mnt/gs18/scratch/users/lindero1/mosaic/split_reads'
OUTDIR='/mnt/gs18/scratch/users/lindero1/mosaic/map'
SAMPID=$(sed -n "${SLURM_ARRAY_TASK_ID}p" "$FQLIST")
NTHREAD=9

CMD="$EXEC $REF $SAMPID $FQDIR $OUTDIR $NTHREAD"
printf "\n%s\n" "$CMD"
eval $CMD

--- end bash code ---

# Trim residual overlapping portions of read pairs using mapping information (retain data from highest quality read)

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/map/clip_overlaps_array.sh
implements:

--- start bash code ---

EXEC='bam clipOverlap'
FQLIST='/mnt/research/Fitz_Lab/projects/mosaic/mosiac_ids.txt'
SAMPID=$(sed -n "${SLURM_ARRAY_TASK_ID}p" "$FQLIST")
INBAM="/mnt/gs18/scratch/users/lindero1/mosaic/map/${SAMPID}_untrimmed.bam"
OUTBAM="/mnt/research/Fitz_Lab/projects/mosaic/map/bam/${SAMPID}.bam"

CMD="$EXEC --in $INBAM --out $OUTBAM --stats --excludeFlags 0x20C --params --poolSize 1000000000 --noPhoneHome"
printf "\n%s\n" "$CMD"
eval $CMD

CMD2="samtools index $OUTBAM"
printf "\n%s\n" "$CMD2"
eval $CMD2

--- end bash code ---

## ---------- EVALUATE COVERAGE ---------- ##

# Calculate coverage statistics for each individual for the entire genome

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/map/coverage/coverage_array.sh

--- start bash code ---

EXEC='samtools coverage'
FQLIST='/mnt/research/Fitz_Lab/projects/mosaic/mosiac_ids.txt'
SAMPID=$(sed -n "${SLURM_ARRAY_TASK_ID}p" "$FQLIST")
BAM="/mnt/research/Fitz_Lab/projects/mosaic/map/bam/${SAMPID}.bam"
OUTFILE="/mnt/research/Fitz_Lab/projects/mosaic/map/coverage/${SAMPID}_coverage.txt"

CMD="$EXEC --ff UNMAP,SECONDARY,QCFAIL,DUP -d 0 $BAM > $OUTFILE"
printf "\n%s\n" "$CMD"
eval $CMD

--- end bash code ---

# Calculate the average autosomal depth for each indivdiual

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/map/main_chr_depth/depth_array.sh
implements:

--- start bash code ---

FQLIST='/mnt/research/Fitz_Lab/projects/mosaic/mosiac_ids.txt'
SAMPID=$(sed -n "${SLURM_ARRAY_TASK_ID}p" "$FQLIST")
BAM="/mnt/research/Fitz_Lab/projects/mosaic/map/bam/${SAMPID}.bam"
OUTFILE="/mnt/research/Fitz_Lab/projects/mosaic/map/main_chr_depth/${SAMPID}_depth.txt"
BED='/mnt/research/Fitz_Lab/ref/bird/FSJ_V3/FSJ_V3_main_chr.bed'

CMD="samtools depth -b $BED $BAM | cut -f3 | perl -ne '(\$sum, \$n) = (0,1); \$sum+=\$_; while(<>){\$sum+=\$_; \$n++};\$avg = sprintf(\"%.3f\", \$sum/\$n); print \"NSITES\tAVG_DEPTH\n\$n\t\$avg\n\"' > $OUTFILE"
printf "\n%s\n" "$CMD"
eval $CMD

--- end bash code ---

# Calculate Z chromosome to autosome depth ratio for each individual with zchr_depth_ratio.R in order 
# to assign sex to unsexed individuals.

zchr_depth_ratio.R implements

--- start R code ---

homolog_file = '/mnt/research/Fitz_Lab/ref/bird/FSJ_V3/FSJV3_convert.short.txt'
homolog = read.table(homolog_file,head=TRUE)
autosome = homolog$FSJV3_SCAFFOLD[which(homolog$ZEBRA_FINCH_CHR != "Z")]
zchr = homolog$FSJV3_SCAFFOLD[which(homolog$ZEBRA_FINCH_CHR == "Z")]

samples = read.table('/mnt/research/Fitz_Lab/projects/mosaic/mosiac_ids.txt',head=FALSE)

df = NULL
for (i in 1:nrow(samples)) {
        id = samples$V1[i]
        coverage = read.table(paste0('/mnt/research/Fitz_Lab/projects/mosaic/map/coverage/',id,'_coverage.txt'),head=FALSE)
        autoset = coverage[which(coverage$V1 %in% autosome),]
        zset = coverage[which(coverage$V1 %in% zchr),]
        len_total = sum(autoset$V3)
        autocov = sum(autoset$V7 * autoset$V3/len_total) # chromosome length weighted average
        zcov = zcov = zset$V7
        dratio = zcov/autocov # ratio of Z chr coverage to autosome coverage
        df = rbind(df, data.frame(SAMPLE = id, AUTOSOME_DEPTH = autocov, Z_DEPTH = zcov, DEPTH_RATIO = dratio))
}

# assign sex based on coverage ratio

df$NGS_SEX = NA
df$NGS_SEX[which(df$DEPTH_RATIO < 0.6)] = "Female"
df$NGS_SEX[which(is.na(df$NGS_SEX) == TRUE)] = "Male"

# write output
# write.table(df,file='/mnt/research/Fitz_Lab/projects/mosaic/map/coverage/ngs_sex_assignment.txt',col.names=TRUE,row.names=FALSE,sep="\t",quote=FALSE)

--- end R code ---

## ---------- GENETIC VARIANT CALLING ---------- ##

## Identify genetic variants and produce an all-sites VCF (accounts for sex of individual)

$ /mnt/research/Fitz_Lab/projects/mosaic/variants/call/call_variants_array.sh
implements:

--- start bash code ---

REF='/mnt/research/Fitz_Lab/ref/bird/FSJ_V3/FSJ.V3.fa'
BAMS='/mnt/research/Fitz_Lab/projects/mosaic/map/mosaic_bam_list.txt'
SCAFFLIST="/mnt/research/Fitz_Lab/projects/mosaic/variants/call/scaffold_sets/regions_${SLURM_ARRAY_TASK_ID}.rf"
PLOIDY_FILE='/mnt/research/Fitz_Lab/projects/mosaic/variants/call/mosaic_ploidy.txt'
SAMP_FILE='/mnt/research/Fitz_Lab/projects/mosaic/variants/call/mosaic_sample_sex.txt'
OUTBCF="/mnt/gs18/scratch/users/lindero1/mosaic/vcf/call/fsj_mosaic_${SLURM_ARRAY_TASK_ID}.bcf.gz"

CMD="bcftools mpileup \
-f $REF \
-b $BAMS \
-R $SCAFFLIST \
-C 0 \
-d 10000 \
-L 10000 \
-q 20 \
-Q 13 \
--ns UNMAP,SECONDARY,QCFAIL,DUP \
-a FORMAT/AD,FORMAT/DP,FORMAT/QS,FORMAT/SP,FORMAT/SCR,INFO/AD,INFO/SCR \
-p \
-O u \
| bcftools call \
--ploidy-file $PLOIDY_FILE \
-S $SAMP_FILE \
-a PV4,GQ,GP \
-m \
-P 0.003 \
-O u \
| bcftools +fill-tags \
-O b \
-o $OUTBCF \
-- -t 'AF,ExcHet,NS'"

printf "\n%s\n\n" "$CMD"

eval $CMD

wait

tabix -p bcf $OUTBCF

--- end bash code ---

# normalize variants

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/variants/norm/norm_variants_array.sh
implements:

--- start bash code ---

REF='/mnt/research/Fitz_Lab/ref/bird/FSJ_V3/FSJ.V3.fa'
INBCF="/mnt/gs18/scratch/users/lindero1/mosaic/vcf/call/fsj_mosaic_${SLURM_ARRAY_TASK_ID}.bcf.gz"
OUTBCF="/mnt/gs18/scratch/users/lindero1/mosaic/vcf/norm/fsj_mosaic_norm_${SLURM_ARRAY_TASK_ID}.bcf.gz"

CMD="bcftools norm -f $REF -O b -o $OUTBCF $INBCF"

printf "\n%s\n\n" "$CMD"

eval $CMD

wait

tabix -p bcf $OUTBCF

--- end bash code ---

## Annotate VCF including populating the FILTER and INFO fields with quality-related annotations

# Generate accessability masks

Merge BAMs in order to calculate mapping and sequencing quality information across all individuals

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/variants/masks/merge_bams.sh
implements:

--- start bash code ---

REF='/mnt/research/Fitz_Lab/ref/bird/FSJ_V3/FSJ.V3.fa'
BAMS='/mnt/research/Fitz_Lab/projects/mosaic/map/mosaic_bam_list.txt'
OUTFILE='/mnt/gs18/scratch/users/lindero1/mosaic/mask/mosaic_fsj_all.bam'

CMD="samtools merge -O BAM --reference $REF -b $BAMS -o $OUTFILE -@ 20"

printf "\n%s\n\n" "$CMD"

eval $CMD

wait

samtools index -@ 20 "$OUTFILE"

--- end bash code ---

Calculate mapping and sequencing quality information

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/variants/masks/bamstats_array.sh
implements:

--- start bash code ---

EXEC='/mnt/research/Fitz_Lab/projects/mosaic/variants/masks/bamstats'
SCAFLIST='/mnt/research/Fitz_Lab/ref/bird/FSJ_V3/FSJ_V3_scaffolds.txt'
SCAF=$(sed -n "${SLURM_ARRAY_TASK_ID}p" "$SCAFLIST")
REF='/mnt/research/Fitz_Lab/ref/bird/FSJ_V3/FSJ.V3.fa'
BAM='/mnt/gs18/scratch/users/lindero1/mosaic/mask/mosaic_fsj_all.bam'
OUTFILE="/mnt/research/Fitz_Lab/projects/mosaic/variants/masks/bam_stats/fsj_mosaic_allind_${SCAF}.bamstats"

CMD="$EXEC -A -d 8700000 -f $REF -q 0 -Q 0 -r $SCAF --ff UNMAP,SECONDARY,QCFAIL,DUP -s -aa $BAM > $OUTFILE"

printf "\n%s\n\n" "$CMD"

eval $CMD

--- end bash code ---

Summarize BAM statistics

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/variants/masks/bamstats_main_summary_array.sh
implements:

--- start bash code ---

EXEC='/mnt/research/Fitz_Lab/projects/mosaic/variants/masks/qualSummaryStats.R'
STATLIST="/mnt/gs18/scratch/users/lindero1/mosaic/mask/fsj_v3_autosome_bamstat_${SLURM_ARRAY_TASK_ID}.list"
if [ $SLURM_ARRAY_TASK_ID -eq 4 ]; then STATLIST='/mnt/gs18/scratch/users/lindero1/mosaic/mask/fsj_v3_z_bamstat.list'; fi
OUTFILE="/mnt/gs18/scratch/users/lindero1/mosaic/mask/bam_stats/fsj_mosaic_allind_bamstat_summary_${SLURM_ARRAY_TASK_ID}.txt"

CMD="$EXEC $STATLIST $OUTFILE 3 4 5 6 7 8 9"

printf "\n%s\n\n" "$CMD"

eval $CMD

--- end bash code ---


Make accessability mask bed files based on BAM statistics

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/variants/masks/bed_mask_array.sh
implements:

--- start bash code ---

EXEC='/mnt/research/Fitz_Lab/projects/mosaic/variants/masks/bedmask.pl'
SCAFLIST='/mnt/research/Fitz_Lab/ref/bird/FSJ_V3/FSJ_V3_scaffolds.txt'
SCAF=$(sed -n "${SLURM_ARRAY_TASK_ID}p" "$SCAFLIST")
BAMSTATS="/mnt/research/Fitz_Lab/projects/mosaic/variants/masks/bam_stats/fsj_mosaic_allind_${SCAF}.bamstats"
OUTPREFIX="/mnt/research/Fitz_Lab/projects/mosaic/variants/masks/bed/fsj_mosaic_mask_${SCAF}"

CMD="$EXEC --mindepth 523 --maxdepth 741 --minmq 35 --maxmq0 0.1 --minbq 20 --maxbq0 0.003 $BAMSTATS $OUTPREFIX"

if [ "$SCAF" = 'Chromosome24' ]
then
        CMD="$EXEC --mindepth 386 --maxdepth 681 --minmq 35 --maxmq0 0.1 --minbq 20 --maxbq0 0.003 $BAMSTATS $OUTPREFIX"
fi

printf "\n%s\n\n" "$CMD"

eval $CMD

--- end bash code ---


Calculate quality information based on VCF. This will be quality based on reads that were actually used for genotype calling, i.e. 
that passed minimum base and mapping quality cutoffs when calling variants with bcftools.

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/variants/masks/vcfstats_array.sh
implements:

--- start bash code ---

BCF="/mnt/gs18/scratch/users/lindero1/mosaic/vcf/norm/fsj_mosaic_norm_${SLURM_ARRAY_TASK_ID}.bcf.gz"
OUTFILE="/mnt/gs18/scratch/users/lindero1/mosaic/mask/vcf_stats/fsj_mosaic_${SLURM_ARRAY_TASK_ID}.vcfstats"

CMD="(printf '%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\n' 'CHR' 'POS' 'DP' 'NS' 'QUAL' 'MQ' 'RPBZ' 'MQBZ' 'BQBZ' 'FS' 'ExcHet' 'PV4_STRAND' 'PV4_BASEQ' 'PV4_MAPQ' 'PV4_POS' && bcftools query -f '%CHROM\t%POS\t%INFO/DP\t%INFO/NS\t%QUAL\t%MQ\t%INFO/RPBZ\t%INFO/MQBZ\t%INFO/BQBZ\t%INFO/FS\t%INFO/ExcHet\t%INFO/PV4{0}\t%INFO/PV4{1}\t%INFO/PV4{2}\t%INFO/PV4{3}\n' $BCF) > $OUTFILE"

printf "\n%s\n\n" "$CMD"

eval $CMD

--- end bash code ---


Summarize VCF quality information

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/variants/masks/vcfstats_main_summary_array.sh
implements:

--- start bash code ---

EXEC='/mnt/research/Fitz_Lab/projects/mosaic/variants/masks/qualSummaryStats.R'
CHRLIST='/mnt/research/Fitz_Lab/ref/bird/FSJ_V3/FSJ_V3_main_autosomes.txt'
CHR=$(sed -n "${SLURM_ARRAY_TASK_ID}p" "$CHRLIST")
STATLIST="/mnt/research/Fitz_Lab/projects/mosaic/variants/masks/tmp/fsj_mosaic_vcfstats_${SLURM_ARRAY_TASK_ID}.list"
echo "/mnt/research/Fitz_Lab/projects/mosaic/variants/masks/vcf_stats/fsj_mosaic_${CHR}.vcfstats" > "$STATLIST"
OUTFILE="/mnt/research/Fitz_Lab/projects/mosaic/variants/masks/vcf_stats/fsj_mosaic_allind_vcfstats_summary_${CHR}.txt"

CMD="$EXEC $STATLIST $OUTFILE 3 4 5 6 7 8 9 10 11 12 13 14 15"

printf "\n%s\n\n" "$CMD"

eval $CMD

--- end bash code ---

Annotate all-sites VCF using BAM stats accessability mask and VCF quality cutoffs

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/variants/masks/annotate_array.sh
implements:

--- start bash code ---

EXEC='/mnt/research/Fitz_Lab/projects/mosaic/variants/masks/insertAnnotations.pl'
BCF="/mnt/gs18/scratch/users/lindero1/mosaic/vcf/norm/fsj_mosaic_norm_${SLURM_ARRAY_TASK_ID}.bcf.gz"
BEDFILE='/mnt/research/Fitz_Lab/projects/mosaic/variants/masks/bed/fsj_mosaic_mask_genome_fail.bed'
GRPFILE='/mnt/research/Fitz_Lab/projects/mosaic/variants/masks/fsj_mosaic_group_file.txt'
OUTFILE="/mnt/gs18/scratch/users/lindero1/mosaic/vcf/annotate/fsj_mosaic_annotated_${SLURM_ARRAY_TASK_ID}.vcf.gz"

CMD="bcftools view --no-version $BCF | $EXEC --dpbounds 474,790 --hetbound 0.06 --bed $BEDFILE --overwrite --genorep $GRPFILE | bgzip > $OUTFILE"

if [ "$SLURM_ARRAY_TASK_ID" = 7 ]
then
        CMD="bcftools view --no-version $BCF | $EXEC --dpbounds 336,560 --hetbound 0.06 --bed $BEDFILE --overwrite --genorep $GRPFILE | bgzip > $OUTFILE"
fi

printf "\n%s\n\n" "$CMD"
eval $CMD
wait
tabix -p vcf $OUTFILE

--- end bash code ---


Concatenate annotated VCFs to produce a single, final, release-ready, all-sites VCF

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/variants/masks/merge_vcfs.sh
implements:

--- start bash code ---

VCFLIST='/mnt/gs18/scratch/users/lindero1/mosaic/vcf/annotate/fsj_mosaic_vcf.list'
OUTFILE='/mnt/research/Fitz_Lab/projects/mosaic/variants/vcf/all_sites/fsj_mosaic_allsites_genome.vcf.gz'

CMD="bcftools concat -f $VCFLIST -O z -o $OUTFILE --threads 20"

printf "\n%s\n\n" "$CMD"

eval $CMD
wait
tabix -p vcf "$OUTFILE"

--- end bash code ---

Produce accompanying position file for the entire genome of sites that pass missing data and quality cutoffs

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/variants/scripts/extract_allsites_qc_pos.sh
implements:

--- start bash code ---

VCF='/mnt/research/Fitz_Lab/projects/mosaic/variants/vcf/all_sites/fsj_mosaic_allsites_genome.vcf.gz'
OUTPOS='/mnt/research/Fitz_Lab/projects/mosaic/variants/vcf/all_sites/fsj_mosaic_allsites_genome_qc.pos'

bcftools view -H -f "PASS" -i 'N_PASS(GT[0-27]!="mis" & FMT/DP > 2) > 24 && N_PASS(GT[28-38]!="mis" & FMT/DP > 2) > 9 && N_PASS(GT[39-44]!="mis" & FMT/DP > 2) > 4 && N_PASS(GT[45-57]!="mis" & FMT/DP > 2) > 11 && N_PASS(GT[58-86]!="mis" & FMT/DP > 2) > 25' "$VCF" | perl -ne  '@tok = split(/\s+/,$_); if ($tok[7] =~ /REPGQ=(\d+),(\d+),(\d+),(\d+),(\d+)/) {print "$tok[0]\t$tok[1]\n" if ($1 > 24 && $2 > 9 && $3 > 4 && $4 > 11 && $5 > 25);} else {print "$tok[0]\t$tok[1]\n";}' | uniq > "$OUTPOS"

--- end bash code ---

Produce accompanying position file for scaffolds that are homologous to zebra finch autosomes (refered to as "main autosomes") and 
which pass missing data and quality cutoffs

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/variants/scripts/extract_allsites_main_autosome_qc_pos.sh
implements:

--- start bash code ---

VCF='/mnt/research/Fitz_Lab/projects/mosaic/variants/vcf/all_sites/fsj_mosaic_allsites_genome.vcf.gz'
OUTPOS='/mnt/research/Fitz_Lab/projects/mosaic/variants/vcf/all_sites/fsj_mosaic_allsites_main_autosomes_qc.pos'
REGFILE='/mnt/research/Fitz_Lab/ref/bird/FSJ_V3/fsj_v3_main_autosomes.rf'

bcftools view -H -R "$REGFILE" -f "PASS" -i 'N_PASS(GT[0-27]!="mis" & FMT/DP > 2) > 24 && N_PASS(GT[28-38]!="mis" & FMT/DP > 2) > 9 && N_PASS(GT[39-44]!="mis" & FMT/DP > 2) > 4 && N_PASS(GT[45-57]!="mis" & FMT/DP > 2) > 11 && N_PASS(GT[58-86]!="mis" & FMT/DP > 2) > 25' "$VCF" | perl -ne  '@tok = split(/\s+/,$_); if ($tok[7] =~ /REPGQ=(\d+),(\d+),(\d+),(\d+),(\d+)/) {print "$tok[0]\t$tok[1]\n" if ($1 > 24 && $2 > 9 && $3 > 4 && $4 > 11 && $5 > 25);} else {print "$tok[0]\t$tok[1]\n";}' | uniq > "$OUTPOS"

--- end bash code ---

## Produce a sites-only allsites VCF (no individual genotype information)

$ bcftools view -G -O z /mnt/research/Fitz_Lab/projects/mosaic/variants/vcf/all_sites/fsj_mosaic_allsites_genome.vcf.gz > /mnt/research/Fitz_Lab/projects/mosaic/variants/vcf/all_sites/fsj_mosaic_allsites_genome_sitesonly.vcf.gz

## Extract all-variants VCF subset

Extract variable sites from all-sites VCF

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/variants/scripts/extract_variants.sh
implements:

--- start bash code ---

EXEC='/mnt/research/Fitz_Lab/projects/mosaic/variants/scripts/extractVariants.pl'
VCF='/mnt/research/Fitz_Lab/projects/mosaic/variants/vcf/all_sites/fsj_mosaic_allsites_genome.vcf.gz'
OUTVCF='/mnt/research/Fitz_Lab/projects/mosaic/variants/vcf/all_variants/fsj_mosaic_variants_genome.vcf.gz'

$EXEC $VCF | bgzip > $OUTVCF

tabix -p vcf $OUTVCF

--- end bash code ---

## Extract biallelic SNP VCF subset

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/variants/scripts/extract_snps.sh
implements:

--- start bash code ---

EXEC='/mnt/research/Fitz_Lab/projects/mosaic/variants/vcf/scripts/extractBiallelicSnps.pl'
VCF='/mnt/research/Fitz_Lab/projects/mosaic/variants/vcf/all_sites/fsj_mosaic_allsites_genome.vcf.gz'
OUTVCF='/mnt/research/Fitz_Lab/projects/mosaic/variants/vcf/biallelic_snps/fsj_mosaic_biallelic_snps_genome.vcf.gz'

$EXEC --minmaf 0 $VCF | bgzip > $OUTVCF

tabix -p vcf $OUTVCF

--- end bash code ---

Produce accompanying position file of genome-wide biallelic SNPs that pass missing data and quality cutoffs

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/variants/scripts/extract_snps_qc_pos.sh
implements:

--- start bash code ---

VCF='/mnt/research/Fitz_Lab/projects/mosaic/variants/vcf/biallelic_snps/fsj_mosaic_biallelic_snps_genome.vcf.gz'
OUTPOS='/mnt/research/Fitz_Lab/projects/mosaic/variants/vcf/biallelic_snps/fsj_mosaic_biallelic_snps_genome_qc.pos'

bcftools view -H -f "PASS" -i 'N_PASS(GT[0-27]!="mis" & FMT/DP > 2) > 24 && N_PASS(GT[28-38]!="mis" & FMT/DP > 2) > 9 && N_PASS(GT[39-44]!="mis" & FMT/DP > 2) > 4 && N_PASS(GT[45-57]!="mis" & FMT/DP > 2) > 11 && N_PASS(GT[58-86]!="mis" & FMT/DP > 2) > 25' "$VCF" | perl -ne  '@tok = split(/\s+/,$_); if ($tok[7] =~ /REPGQ=(\d+),(\d+),(\d+),(\d+),(\d+)/) {print "$tok[0]\t$tok[1]\n" if ($1 > 24 && $2 > 9 && $3 > 4 && $4 > 11 && $5 > 25);} else {print "$tok[0]\t$tok[1]\n";}' | uniq > "$OUTPOS"

--- end bash code ---

Producing accompanying position file of biallelic SNPs on main autosomes that pass missing data and quality cutoffs

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/variants/scripts/extract_snps_main_autosome_qc_pos.sh
implements:

--- start bash code ---

VCF='/mnt/research/Fitz_Lab/projects/mosaic/variants/vcf/biallelic_snps/fsj_mosaic_biallelic_snps_genome.vcf.gz'
OUTPOS='/mnt/research/Fitz_Lab/projects/mosaic/variants/vcf/biallelic_snps/fsj_mosaic_biallelic_snps_main_autosomes_qc.pos'
REGFILE='/mnt/research/Fitz_Lab/ref/bird/FSJ_V3/fsj_v3_main_autosomes.rf'

bcftools view -H -R "$REGFILE" -f "PASS" -i 'N_PASS(GT[0-27]!="mis" & FMT/DP > 2) > 24 && N_PASS(GT[28-38]!="mis" & FMT/DP > 2) > 9 && N_PASS(GT[39-44]!="mis" & FMT/DP > 2) > 4 && N_PASS(GT[45-57]!="mis" & FMT/DP > 2) > 11 && N_PASS(GT[58-86]!="mis" & FMT/DP > 2) > 25' "$VCF" | perl -ne  '@tok = split(/\s+/,$_); if ($tok[7] =~ /REPGQ=(\d+),(\d+),(\d+),(\d+),(\d+)/) {print "$tok[0]\t$tok[1]\n" if ($1 > 24 && $2 > 9 && $3 > 4 && $4 > 11 && $5 > 25);} else {print "$tok[0]\t$tok[1]\n";}' | uniq > "$OUTPOS"

--- end bash code ---

Extract VCF subset of quality-controlled biallelic SNPs on main autosomes

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/variants/scripts/extract_qc_snps.sh
implements

--- start bash code ---

VCF='/mnt/research/Fitz_Lab/projects/mosaic/variants/vcf/biallelic_snps/fsj_mosaic_biallelic_snps_genome.vcf.gz'
POSFILE='/mnt/research/Fitz_Lab/projects/mosaic/variants/vcf/biallelic_snps/fsj_mosaic_biallelic_snps_main_autosomes_qc.pos'
OUTVCF='/mnt/research/Fitz_Lab/projects/mosaic/variants/vcf/biallelic_snps/fsj_mosaic_biallelic_snps_main_autosomes_qc.vcf.gz'

CMD="bcftools view -T $POSFILE -O z -o $OUTVCF $VCF"

printf "\n%s\n\n" "$CMD"

eval $CMD

tabix -p vcf $OUTVCF

--- end bash code ---


## ---------- RELATEDNESS ESTIMATED FROM GENOMIC DATA ---------- ##

Estimate relatedness among all sequenced individuals.

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/popgen/relatedness/relatedness_qc_snps.sh
implements:

--- start bash code ---

VCF='/mnt/research/Fitz_Lab/projects/mosaic/variants/vcf/biallelic_snps/fsj_mosaic_biallelic_snps_main_autosomes_qc.vcf.gz'
OUTFILE='fsj_mosaic_biallelic_snps_main_autosomes_qc_relatedness.txt'

CMD="ngsRelate -h $VCF -O $OUTFILE -p 20 -l 0.02 -T PL -A AF"

printf "\n%s\n\n" "$CMD"

eval $CMD

--- end bash code ---

## Subset individuals such that all pairwise relatedness within each group is <= 0.4, which should exclude any first degree relatives.
## These subsets are maximally large, while ensuring that r <= 0.4.
## These are the subsets used for estimating average heterozygosity and estimating allele frequencies for inbreeding inferences.

Groups (Unrelated := r < 0.4) and subset sample sizes:
-Unrelated Contemporary CR group (n = 28)
-Unrelated Resident CR group (n = 14)
-Site 13 group (n = 10)
-Unrelated Historic metapopulation group (n = 39)
-Unrelated CR founders (Resident + translocated, n = 29)
-donor sites (includes translocated individuals) (n = 16)

Extract relatedness submatrices that include only the individuals within each group

--- start R code ---

rmat <- as.matrix(read.table('/mnt/research/Fitz_Lab/projects/mosaic/popgen/relatedness/fsj_mosaic_biallelic_snps_main_autosomes_qc_relatedness_matrix.txt',head=TRUE,row.names=1))
colnames(rmat) <- gsub('\\..+$', '', colnames(rmat), perl=TRUE) # remove location info
meta <- read.table('/mnt/research/Fitz_Lab/projects/mosaic/M4_sequenced_FSJsamples_metadata.txt',head=TRUE,sep="\t")

# collect IDs of individuals in each group
c.id <- meta$LAB_ID[which(meta$pop == "Contemporary")]
r.id <- meta$LAB_ID[which(meta$pop == "Resident")]
s13.id <- meta$LAB_ID[which(meta$pop == "SITE_13")]
histmeta.id <- meta$LAB_ID[which(meta$year_sampled < 2021)]

# note: exclude RSW-K from CR founders in case I use them as a reference pop for the Contemporary CR individuals at some point
crfounders.id <- meta$LAB_ID[which((meta$pop == "Resident" | meta$pop == "SITE_1" | meta$pop == "SITE_12" | meta$pop == "SITE_13" | meta$pop == "SITE_18" | meta$pop == "TEXACO") & meta$LAB_ID != "T_072")]

# note: include RSW-K from the donor site group because they are relevant for estimating the allele frequencies in this metapopulation subset
donor.id <- meta$LAB_ID[which(meta$pop == "SITE_1" | meta$pop == "SITE_12" | meta$pop == "SITE_13" | meta$pop == "SITE_18" | meta$pop == "TEXACO")]

# commenting out translocated subset below because all donor site individuals are a better way to estimate allele frequencies for the translocated group 
#trans.id <': trans.id <- meta$LAB_ID[which((meta$pop == "SITE_1" | meta$pop == "SITE_12" | meta$pop == "SITE_13" | meta$pop == "SITE_18" | meta$pop == "TEXACO") & meta$LAB_ID != "T_072")]

# extract relatedness matrix subsets
c.rmat <- rmat[which(colnames(rmat) %in% c.id == TRUE), which(colnames(rmat) %in% c.id == TRUE)]
r.rmat <- rmat[which(colnames(rmat) %in% r.id == TRUE), which(colnames(rmat) %in% r.id == TRUE)]
s13.rmat <- rmat[which(colnames(rmat) %in% s13.id == TRUE), which(colnames(rmat) %in% s13.id == TRUE)]
histmeta.rmat <- rmat[which(colnames(rmat) %in% histmeta.id == TRUE), which(colnames(rmat) %in% histmeta.id == TRUE)]
crfounders.rmat <- rmat[which(colnames(rmat) %in% crfounders.id == TRUE), which(colnames(rmat) %in% crfounders.id == TRUE)]
donor.rmat <- rmat[which(colnames(rmat) %in% donor.id == TRUE), which(colnames(rmat) %in% donor.id == TRUE)]

# output relatedness matrices subsets
#write.table(c.rmat, file='/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/contemporary_cr_relatedness_matrix.txt', col.names=TRUE, row.names=FALSE, quote=FALSE, sep="\t")
#write.table(r.rmat, file='/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/resident_cr_relatedness_matrix.txt', col.names=TRUE, row.names=FALSE, quote=FALSE, sep="\t")
#write.table(s13.rmat, file='/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/site13_relatedness_matrix.txt', col.names=TRUE, row.names=FALSE, quote=FALSE, sep="\t")
#write.table(histmeta.rmat, file='/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/historic_metapop_relatedness_matrix.txt', col.names=TRUE, row.names=FALSE, quote=FALSE, sep="\t")
#write.table(crfounders.rmat, file='/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/cr_founders_relatedness_matrix.txt', col.names=TRUE, row.names=FALSE, quote=FALSE, sep="\t")
#write.table(donor.rmat, file='/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/donor_pops_relatedness_matrix.txt', col.names=TRUE, row.names=FALSE, quote=FALSE, sep="\t")

# output the original relatedness matrix of all samples, entirely unchanged except for removing the row names and simplifying the IDs (remove population labels)
#write.table(rmat, file='/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/fsj_mosaic_biallelic_snps_main_autosomes_qc_relatedness_matrix_fmt.txt', col.names=TRUE, row.names=FALSE, quote=FALSE, sep="\t")

--- end R code ---

Take random subsets of individuals such that the max pairwise r within each group is <= 0.4

--- start bash code ---

$ /mnt/research/Fitz_Lab/projects/mosaic/popgen/relatedness/scripts/subsetUnrelated.R contemporary_cr_relatedness_matrix.txt 0.4 836241 > contemporary_cr_relatedness_maxr0.4_ids.txt
$ /mnt/research/Fitz_Lab/projects/mosaic/popgen/relatedness/scripts/subsetUnrelated.R resident_cr_relatedness_matrix.txt 0.4 836241 > resident_cr_relatedness_maxr0.4_ids.txt
$ /mnt/research/Fitz_Lab/projects/mosaic/popgen/relatedness/scripts/subsetUnrelated.R site13_relatedness_matrix.txt 0.4 836241 > site13_relatedness_maxr0.4_ids.txt
$ /mnt/research/Fitz_Lab/projects/mosaic/popgen/relatedness/scripts/subsetUnrelated.R historic_metapop_relatedness_matrix.txt 0.4 836241 > historic_metapop_relatedness_maxr0.4_ids.txt
$ /mnt/research/Fitz_Lab/projects/mosaic/popgen/relatedness/scripts/subsetUnrelated.R cr_founders_relatedness_matrix.txt 0.4 836241 > cr_founders_relatedness_maxr0.4_ids.txt
$ /mnt/research/Fitz_Lab/projects/mosaic/popgen/relatedness/scripts/subsetUnrelated.R donor_pops_relatedness_matrix.txt 0.4 836241 > donor_pops_relatedness_maxr0.4_ids.txt
$ /mnt/research/Fitz_Lab/projects/mosaic/popgen/relatedness/scripts/subsetUnrelated.R fsj_mosaic_biallelic_snps_main_autosomes_qc_relatedness_matrix_fmt.txt 0.4 836241 > fsj_mosaic_biallelic_snps_main_autosomes_qc_relatedness_maxr0.4_ids.txt

--- end bash code ---

## Take random subsets of individuals so that all within-group pairwise relatedness is <= 0.01
## Consider these subsets of unrelated individuals.

--- begin R code ---

sample_unrelated <- function(pop, relate.matrix, maxr=0.01, niter=100) {

        grp.idx <- grep(pop,colnames(relate.matrix))
        urelate = NULL

        for (i in 1:niter) {
                submat = relate.matrix[grp.idx,grp.idx]
                while (max(submat,na.rm=TRUE) > maxr) {
                        id = colnames(submat)
                        ind.pairs <- combn(id, m=2)
                        idx.perm <- sample(1:ncol(ind.pairs),size=ncol(ind.pairs))
                        reset = 0
                        for (i in idx.perm) {
                                ind.vec = ind.pairs[,i]
                                a.idx = which(id == ind.vec[1])
                                b.idx = which(id == ind.vec[2])
                                r = relate.matrix[a.idx, b.idx]
                                if (r > maxr) {
                                        a.relatives = length(which(submat[a.idx,] > maxr))
                                        b.relatives = length(which(submat[b.idx,] > maxr))
                                        discard.idx = ifelse(a.relatives > b.relatives, a.idx, b.idx)
                                        submat <- submat[-discard.idx, -discard.idx]
                                        reset = 1
                                        break
                                }
                                if (reset == 1) break
                        }
                }
                if (is.null(urelate) == TRUE || ncol(submat) > ncol(urelate)) urelate = submat
        }

        return(colnames(urelate))
}

rmat <- as.matrix(read.table('/home/tyler/Dropbox/research/jay/mosaic/popgen/relatedness/fsj_mosaic_biallelic_snps_main_autosomes_qc_relatedness_matrix.txt',head=TRUE,row.names=1))
rmat <- rmat[-which(colnames(rmat) == "T_072.Site_1"),-which(colnames(rmat) == "T_072.Site_1")] # exclude RSW-K because this individual was not translocated

set.seed(324986)
contemp.unrelated <- sample_unrelated(pop="Contemporary", relate.matrix=rmat, maxr=0.01, niter=1000) # unrelated contemporary CR subset
res.unrelated <- sample_unrelated(pop="Resident", relate.matrix=rmat, maxr=0.01, niter=1000) # unrelated resident CR subset
trans.unrelated <- sample_unrelated(pop="Site|Texaco", relate.matrix=rmat, maxr=0.01, niter=1000) # unrelated translocated subset

contemp.unrelated.df  <- data.frame(ID=gsub("\\.Contemporary","",contemp.unrelated))
res.unrelated.df  <- data.frame(ID=gsub("\\.Resident","",res.unrelated))
trans.unrelated.df <- data.frame(ID=gsub("\\.Site.+|\\.Texaco","",trans.unrelated))

# write subset lists of individuals for which all r <= 0.01
#write.table(contemp.unrelated.df, file='/home/tyler/Dropbox/research/jay/mosaic/popgen/unrelated_subsample/contemporary_unrelated_samples.txt',col.names=FALSE,row.names=FALSE,quote=FALSE)
#write.table(res.unrelated.df, file='/home/tyler/Dropbox/research/jay/mosaic/popgen/unrelated_subsample/resident_unrelated_samples.txt',col.names=FALSE,row.names=FALSE,quote=FALSE)
#write.table(trans.unrelated.df, file='/home/tyler/Dropbox/research/jay/mosaic/popgen/unrelated_subsample/translocated_unrelated_samples.txt',col.names=FALSE,row.names=FALSE,quote=FALSE)

--- end R code ---

Unrelated (r <= 0.01) sample sizes:
contemporary CR, n = 6
resident CR, n = 6
translocated, n = 8

## ---------- SITE FREQUENCY SPECTRUM ---------- ##

# Folded SFS calculated from all sites (best SFS estimate, used for estimating genetic diversity)

Estimate per site allele frequency likelihoods for all quality controlled sites

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/popgen/sfs/main_autosome_grp_sfs_array2.sh
implements:

--- start bash code ---

GRP_ARR=('resident' 'C' 'T' 'M4')
FSJGRP="${GRP_ARR[$SLURM_ARRAY_TASK_ID]}"
BAMLIST="/mnt/research/Fitz_Lab/projects/mosaic/map/mosaic_${FSJGRP}_bam_list.txt"
OUTPREFIX="/mnt/research/Fitz_Lab/projects/mosaic/popgen/sfs/fsj_mosaic_allsites_main_autosomes_qc_${FSJGRP}"
REGFILE='/mnt/research/Fitz_Lab/ref/bird/FSJ_V3/FSJ_V3_main_autosomes.txt'
SITESFILE='/mnt/research/Fitz_Lab/projects/mosaic/variants/vcf/all_sites/fsj_mosaic_allsites_main_autosomes_qc.pos'
REF='/mnt/research/Fitz_Lab/ref/bird/FSJ_V3/FSJ.V3.fa'

CMD="angsd -bam $BAMLIST -out $OUTPREFIX -GL 1 -doSaf 1 -anc $REF -minQ 20 -minMapQ 20 -rf $REGFILE -sites $SITESFILE -P 4"

printf "\n%s\n\n" "$CMD"

eval $CMD

--- end bash code ---

Estimate folded SFS

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/popgen/sfs/main_autosome_grp_realsfs_fold_array2.sh
implements:

--- start bash code ---

GRP_ARR=('resident' 'C' 'T' 'M4')
FSJGRP="${GRP_ARR[$SLURM_ARRAY_TASK_ID]}"
SAFIDX="/mnt/research/Fitz_Lab/projects/mosaic/popgen/sfs/fsj_mosaic_allsites_main_autosomes_qc_${FSJGRP}.saf.idx"
OUTSFS="/mnt/research/Fitz_Lab/projects/mosaic/popgen/sfs/fsj_mosaic_allsites_main_autosomes_qc_${FSJGRP}.fold.sfs"

CMD="realSFS $SAFIDX -fold 1 -P 20 > $OUTSFS"

printf "\n%s\n\n" "$CMD"

eval $CMD

--- end bash code ---

# Folded SFS calculated using all sites for subsets of individuals for which all pairwise relatedness is <= 0.01

Estimate allele frequency likelihoods for subset of unrelated individuals at all quality-controlled sites

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/popgen/sfs/main_autosome_unrelated_grp_array.sh
implements:

--- start bash code ---

GRP_ARR=('contemporary' 'resident' 'translocated')
FSJGRP="${GRP_ARR[$SLURM_ARRAY_TASK_ID]}"
BAMLIST="/mnt/research/Fitz_Lab/projects/mosaic/map/unrelated/${FSJGRP}_unrelated_bam_list.txt"
OUTPREFIX="/mnt/research/Fitz_Lab/projects/mosaic/popgen/sfs/fsj_mosaic_allsites_main_autosomes_qc_${FSJGRP}_unrelated"
FFILE="/mnt/research/Fitz_Lab/projects/mosaic/popgen/fstats/unrelated/${FSJGRP}_unrelated_samples_F.txt"
REGFILE='/mnt/research/Fitz_Lab/ref/bird/FSJ_V3/FSJ_V3_main_autosomes.txt'
SITESFILE='/mnt/research/Fitz_Lab/projects/mosaic/variants/vcf/all_sites/fsj_mosaic_allsites_main_autosomes_qc.pos'
REF='/mnt/research/Fitz_Lab/ref/bird/FSJ_V3/FSJ.V3.fa'

CMD="angsd -bam $BAMLIST -out $OUTPREFIX -GL 1 -doSaf 2 -indF $FFILE -anc $REF -doMaf 1 -doMajorMinor 1 -minQ 20 -minMapQ 20 -rf $REGFILE -sites $SITESFILE -P 4"

printf "\n%s\n\n" "$CMD"

eval $CMD

--- end bash code ---

Note: GitHub version of /mnt/research/Fitz_Lab/projects/mosaic/popgen/sfs/main_autosome_unrelated_grp_array.sh 
is called main_autosome_unrelated_grp_sfs_array.sh.

Estimate the SFS for subsets of unrelated individuals based on all quality-controlled sites

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/popgen/sfs/main_autosome_unrelated_grp_realsfs_fold_array.sh

--- start bash code ---

GRP_ARR=('contemporary' 'resident' 'translocated')
FSJGRP="${GRP_ARR[$SLURM_ARRAY_TASK_ID]}"
SAFIDX="/mnt/research/Fitz_Lab/projects/mosaic/popgen/sfs/fsj_mosaic_allsites_main_autosomes_qc_${FSJGRP}_unrelated.saf.idx"
OUTSFS="/mnt/research/Fitz_Lab/projects/mosaic/popgen/sfs/fsj_mosaic_allsites_main_autosomes_qc_${FSJGRP}_unrelated.fold.sfs"

CMD="realSFS $SAFIDX -fold 1 -P 16 > $OUTSFS"

printf "\n%s\n\n" "$CMD"

eval $CMD

--- end bash code ---

# R functions for visualizing SFS

--- start R code ---

# plot SFS
plotsfs <- function(x = NULL, outfile = NULL, grp = NULL, fold = 0) {
        if (!is.null(outfile)) pdf(file=outfile) else x11()
        par(mfrow=c(2,2))
        for (i in 1:length(x)) {
                if (fold == 0) {
                        barplot(x[[i]][-c(1,length(x[[i]]))], main = grp[i], ylab="Number sites", xlab="Derived AF", names.arg=1:(length(x[[i]])-2))
                } else if (fold == 1) {
                        barplot(x[[i]][-1], main = grp[i], ylab="Number sites", xlab="MAF", names.arg=1:(length(x[[i]])-1))
                } else {
                        stop("fold argument must be 0 or 1")
                }
                if (is.null(outfile) && i %% 4 == 0) {
                        x11()
                        par(mfrow=c(2,2))
                }
        }
        if (!is.null(outfile)) invisible(dev.off())
}

neutral.sfs <- function(n) {
	# makes expected neutral SFS
        # n: diploid sample size
        sfs.vec <- rep(NA,n)
        for (i in 1:((2*n)-1)) {
                sfs.vec[i] = 1/i
        }
        sfs.vec <- sfs.vec/sum(sfs.vec)
        return(sfs.vec)
}

foldsfs <- function(x) {
	# folds the SFS
        n = length(x)+1
        fold.sfs <- NULL
        for (i in 1:(n/2-1)) {
                fold.sfs <- c(fold.sfs, x[i]+x[n-i])
        }
        fold.sfs <- c(fold.sfs, x[n/2])

        return(fold.sfs)
}

# Examples for reading in SFS data for use the with function above

# define groups and sample sizes
sfsdir='./sfs/'
jaygrp = c('C','E','T','M4','I','all')
dipn = c(28, 11, 29, 13, 6, 87)
sfs.fold <- list()
sfs.ufold <- list()
bisnp.fold <- list()
bisnp.ufold <- list()

# read in SFS data
for (i in 1:length(jaygrp)) {
        grp <- jaygrp[i]
        n <- dipn[i]
        sfs.fold[[i]] <- scan(paste0(sfsdir,"fsj_mosaic_allsites_main_autosomes_qc_",grp,".fold.sfs"))
        sfs.fold[[i]] <- sfs.fold[[i]][1:(n+1)]
        sfs.ufold[[i]] <- scan(paste0(sfsdir,"fsj_mosaic_allsites_main_autosomes_qc_",grp,".unfold.sfs"))
        bisnp.fold[[i]] <- scan(paste0(sfsdir,"fsj_mosaic_biallelic_snps_main_autosomes_qc_",grp,".fold.sfs"))
        bisnp.fold[[i]] <- bisnp.fold[[i]][1:(n+1)]
        bisnp.ufold[[i]] <- scan(paste0(sfsdir,"fsj_mosaic_biallelic_snps_main_autosomes_qc_",grp,".unfold.sfs"))
}

# plot each group (includes Contemporary CR population, 'C', plot)
plotsfs(x=sfs.fold, outfile='fsj_mosaic_allsites_main_autosomes_qc_fold.pdf', grp=jaygrp, fold=1)
plotsfs(x=sfs.ufold, outfile='fsj_mosaic_allsites_main_autosomes_qc_unfold.pdf', grp=jaygrp, fold=0)
plotsfs(x=bisnp.fold, outfile='fsj_mosaic_biallelic_snps_main_autosomes_qc_fold.pdf', grp=jaygrp, fold=1)
plotsfs(x=bisnp.ufold, outfile='fsj_mosaic_biallelic_snps_main_autosomes_qc_ufold.pdf', grp=jaygrp, fold=0)

# Resident CR plot
res <- scan('./sfs/fsj_mosaic_allsites_main_autosomes_qc_resident.fold.sfs')
res.fold <- res[2:((length(res)-1)/2)]

# expected resident SFS
res.exp <- neutral.sfs(n=16)
res.exp.fold <- foldsfs(res.exp)
res.exp.fold.counts <- sum(res.fold) * res.exp.fold

barplot(res.exp.fold.counts, xlab="Minor allele frequency", names.arg = 1:length(res.exp.fold.counts), ylab="Number sites",cex.lab=1.3, cex.axis=1.3)

--- end R code ---

## ---------- FST ---------- ##

FST were calculated using variable sites only

# Estimate unfolded joint SFS to serve as joint allele frequency prior for SNPs

Estimate allele frequency likelihoods for quality-controlled SNPs
Note: the 'translocated' group for FST estimation includes RSW-K (T_072, no translocated) and so really represents the pooled donor sites

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/popgen/sfs/main_autosome_snps_grp_sfs_array2.sh
implements:

--- start bash code ---

GRP_ARR=('resident' 'translocated' 'C')
FSJGRP="${GRP_ARR[$SLURM_ARRAY_TASK_ID]}"
BAMLIST="/mnt/research/Fitz_Lab/projects/mosaic/map/mosaic_${FSJGRP}_bam_list.txt"
OUTPREFIX="/mnt/research/Fitz_Lab/projects/mosaic/popgen/sfs/fsj_mosaic_biallelic_snps_main_autosomes_qc_${FSJGRP}"
REGFILE='/mnt/research/Fitz_Lab/ref/bird/FSJ_V3/FSJ_V3_main_autosomes.txt'
SITESFILE='/mnt/research/Fitz_Lab/projects/mosaic/variants/vcf/biallelic_snps/fsj_mosaic_biallelic_snps_main_autosomes_qc.pos'
REF='/mnt/research/Fitz_Lab/ref/bird/FSJ_V3/FSJ.V3.fa'

CMD="angsd -bam $BAMLIST -out $OUTPREFIX -GL 1 -doSaf 1 -anc $REF -minQ 20 -minMapQ 20 -rf $REGFILE -sites $SITESFILE -P 4"

printf "\n%s\n\n" "$CMD"

eval $CMD

--- end bash code ---


Estimate unfolded 2D-SFS

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/popgen/sfs/main_autosome_snps_2dsfs_array2.sh
implements:

--- start bash code ---

CMP=('resident:C' 'resident:translocated' 'translocated:C')
POP1=$(echo "${CMP[$SLURM_ARRAY_TASK_ID]}" | cut -f1 -d':')
POP2=$(echo "${CMP[$SLURM_ARRAY_TASK_ID]}" | cut -f2 -d':')
SAFIDX1="/mnt/research/Fitz_Lab/projects/mosaic/popgen/sfs/fsj_mosaic_biallelic_snps_main_autosomes_qc_${POP1}.saf.idx"
SAFIDX2="/mnt/research/Fitz_Lab/projects/mosaic/popgen/sfs/fsj_mosaic_biallelic_snps_main_autosomes_qc_${POP2}.saf.idx"
OUTSFS="/mnt/research/Fitz_Lab/projects/mosaic/popgen/sfs/fsj_mosaic_biallelic_snps_main_autosomes_qc_${POP1}_vs_${POP2}.unfold.2dsfs"

CMD="realSFS $SAFIDX1 $SAFIDX2 -P 20 > $OUTSFS"

printf "\n%s\n\n" "$CMD"

eval $CMD

--- end bash code ---

# Estimate pairwise FST for {resident CR vs contemporary CR} and {resident vs pooled donor sites}

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/popgen/fstats/main_autosome_snps_2dsfs_array2.sh
implements:

--- start bash code ---

CMP=('resident:C' 'resident:translocated' 'translocated:C')
POP1=$(echo "${CMP[$SLURM_ARRAY_TASK_ID]}" | cut -f1 -d':')
POP2=$(echo "${CMP[$SLURM_ARRAY_TASK_ID]}" | cut -f2 -d':')
SAFIDX1="/mnt/research/Fitz_Lab/projects/mosaic/popgen/sfs/fsj_mosaic_biallelic_snps_main_autosomes_qc_${POP1}.saf.idx"
SAFIDX2="/mnt/research/Fitz_Lab/projects/mosaic/popgen/sfs/fsj_mosaic_biallelic_snps_main_autosomes_qc_${POP2}.saf.idx"
SFSPRIOR="/mnt/research/Fitz_Lab/projects/mosaic/popgen/sfs/fsj_mosaic_biallelic_snps_main_autosomes_qc_${POP1}_vs_${POP2}.unfold.2dsfs"
OUTFILE="/mnt/research/Fitz_Lab/projects/mosaic/popgen/fstats/fsj_mosaic_biallelic_snps_main_autosomes_qc_${POP1}_vs_${POP2}"

CMD="realSFS fst index $SAFIDX1 $SAFIDX2 -sfs $SFSPRIOR -fstout $OUTFILE"

printf "\n%s\n\n" "$CMD"

eval $CMD

--- end bash code ---

## ---------- GENETIC DIVERSITY ---------- ##

## Heterozygosity

Estimate heterozygosity from each individual's site frequency spectrum.

# Estimate allele frequency (0, 1, or 2 minor alleles) likelihoods at each site

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/popgen/theta/heterozygosity/heterozygosity_array.sh
implements:

--- start bash code ---

BAMLIST='/mnt/research/Fitz_Lab/projects/mosaic/map/mosaic_bam_list.txt'
BAMFILE=$(sed -n "${SLURM_ARRAY_TASK_ID}p" "$BAMLIST")
SAMPLIST='/mnt/research/Fitz_Lab/projects/mosaic/mosiac_ids.txt'
SAMP=$(sed -n "${SLURM_ARRAY_TASK_ID}p" "$SAMPLIST")
REF='/mnt/research/Fitz_Lab/ref/bird/FSJ_V3/FSJ.V3.fa'
REGFILE='/mnt/research/Fitz_Lab/ref/bird/FSJ_V3/FSJ_V3_main_autosomes.txt'
SITESFILE='/mnt/research/Fitz_Lab/projects/mosaic/variants/vcf/all_sites/fsj_mosaic_allsites_main_autosomes_qc.pos'
OUTPREFIX="/mnt/research/Fitz_Lab/projects/mosaic/popgen/theta/heterozygosity/fsj_mosaic_allsites_main_autosomes_qc_${SAMP}"

SAFCMD="angsd -i $BAMFILE -out $OUTPREFIX -GL 1 -doSaf 1 -anc $REF -minQ 20 -minMapQ 20 -rf $REGFILE -sites $SITESFILE"

printf "\n%s\n\n" "$SAFCMD"

eval $SAFCMD

--- end bash code ---

# Estimate SFS for individuals

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/popgen/theta/heterozygosity/heterozygosity_realsfs_array.sh
implements:

--- start bash code ---

SAMPLIST='/mnt/research/Fitz_Lab/projects/mosaic/mosiac_ids.txt'
SAMP=$(sed -n "${SLURM_ARRAY_TASK_ID}p" "$SAMPLIST")
SAFIDX="/mnt/research/Fitz_Lab/projects/mosaic/popgen/theta/heterozygosity/fsj_mosaic_allsites_main_autosomes_qc_${SAMP}.saf.idx"
SFS="/mnt/research/Fitz_Lab/projects/mosaic/popgen/theta/heterozygosity/fsj_mosaic_allsites_main_autosomes_qc_${SAMP}.fold.sfs"

CMD="realSFS $SAFIDX -fold 1 -P 12 > $SFS"

printf "\n%s\n\n" "$CMD"

eval $CMD

--- end bash code ---

Collect SFS for all samples into a single file

--- begin bash code ---

$ for i in {1..87}; do SAMP=$(sed -n "${i}p" /mnt/research/Fitz_Lab/projects/mosaic/mosiac_ids.txt); sfs=$((printf "%s " "$SAMP" && head -n1 fsj_mosaic_allsites_main_autosomes_qc_${SAMP}.fold.sfs) | tr ' ' \\t | cut -f1-3); echo "$sfs" >> fsj_mosaic_allsites_main_autosomes_qc_all.fold.sfs; done

--- end bash code ---

# Calculate H from individual SFS and visualize H distrubutions with boxplots

--- start R code ---

library(scales) # for alpha

# read in metapop data
meta <- read.table('/home/tyler/Dropbox/research/jay/mosaic/metadata/M4_sequenced_FSJsamples_metadata.txt',head=TRUE,sep="\t")
meta$popletter <- popletters(meta)
meta$popcol <- popcolor(meta)

groups <- meta$pop
grplevels <- c("Contemporary", "Resident", "Translocated", "M4")

groups <- replace(groups, which(groups == "Golden_Aster_Scrub" | groups == "Brigman" | groups == "W.Balm" | 
groups == "Duette_headwaters" | groups == "Sun_City"), "M4")

groups <- replace(groups, which(groups == "SITE_1" | groups == "SITE_12" | groups == "SITE_13" | 
groups == "SITE_18" | groups == "TEXACO"), "Translocated")

allsites <- read.table('/home/tyler/Dropbox/research/jay/mosaic/popgen/theta/fsj_mosaic_allsites_main_autosomes_qc_all.fold.sfs',head=FALSE) # H all sites

## calculate H
allsites$H <- sapply(1:nrow(allsites), function(x,df){df[x,3]/sum(df[x,2:3])},df=allsites)
allsites$group = factor(groups,levels=grplevels)

# omit T_072 (RSW-K) from plots and statistical tests because this site 1 bird was not translocated and migrated to LMSP, which is outside of the Core
allsites <- allsites[-which(allsites$V1 == "T_072"),]
meta <- meta[-which(meta$LAB_ID == "T_072"),]

## H boxplots

# set point type
pointcode <- meta$popletter
pointcode <- replace(pointcode, which(pointcode == "C" | pointcode == "R"),NA)
allsites$biopoint = biopoint(meta$pop)
snps$biopoint = biopoint(meta$pop)

#png(file='/home/tyler/Dropbox/research/jay/mosaic/figures/H_distribution.png',width=7, height=7,units='in', res=300)
h_boxplot2(x=allsites, n=4, lev=grplevels, ylabel="Heterozygosity per site", pntlab=allsites$biopoint, seed=10287, color=meta$popcol, ylimits=NULL)
dev.off()

#png(file='/home/tyler/Dropbox/research/jay/mosaic/figures/H_distribution_text.png',width=7, height=7,units='in', res=300)
h_boxplot2(x=allsites, n=4, lev=grplevels, ylabel="Heterozygosity per site", pntlab=NULL, seed=10287, color=meta$popcol, ylimits=NULL, idlabels=allsites$V1)
dev.off()

## write H results
allsites$pop <- meta$pop
colnames(allsites) <- c("SAMPLE", "N_HOMO_SITES", "N_HET_SITES", "H", "CLASS", "POPULATION")
#write.table(allsites,file='/home/tyler/Dropbox/research/jay/mosaic/popgen/theta/fsj_mosaic_allsites_main_autosomes_qc_all.fold.sfs.het2',col.names=TRUE,row.names=FALSE,quote=FALSE,sep="\t")

## summarize heterozygosity and test for differences between groups with first degree relatives excluded, specifically no pairwise r > 0.4

contemp.unrelate <- read.table('/home/tyler/Dropbox/research/jay/mosaic/popgen/roh/inputs/contemporary_cr_relatedness_maxr0.4_ids.txt', head=FALSE)$V1 # this is all contemporary individuals because all pairwise relatedness was < 0.4
res.unrelate <- read.table('/home/tyler/Dropbox/research/jay/mosaic/popgen/roh/inputs/resident_cr_relatedness_maxr0.4_ids.txt', head=FALSE)$V1
donor.unrelate <- read.table('/home/tyler/Dropbox/research/jay/mosaic/popgen/roh/inputs/donor_pops_relatedness_maxr0.4_ids.txt', head=FALSE)$V1
histmeta.unrelate <- read.table('/home/tyler/Dropbox/research/jay/mosaic/popgen/roh/inputs/historic_metapop_relatedness_maxr0.4_ids.txt', head=FALSE)$V1

# Group H summary stats (individuals comprising groups are subsets such that all pairwise r <= 0.4).

# Contemporary (all pairwise r <= 0.4)
mean(allsites$H[which(allsites$CLASS == "Contemporary" & allsites$SAMPLE %in% contemp.unrelate == TRUE)])
#[1] 0.0002010206
sd(allsites$H[which(allsites$CLASS == "Contemporary" & allsites$SAMPLE %in% contemp.unrelate == TRUE)])
#[1] 1.846997e-05
range(allsites$H[which(allsites$CLASS == "Contemporary" & allsites$SAMPLE %in% contemp.unrelate == TRUE)])
#[1] 0.0001593255 0.0002332972

# Resident (all pairwise r <= 0.4)
mean(allsites$H[which(allsites$CLASS == "Resident" & allsites$SAMPLE %in% res.unrelate == TRUE)])
#[1] 0.0002306068
sd(allsites$H[which(allsites$CLASS == "Resident" & allsites$SAMPLE %in% res.unrelate == TRUE)])
#[1] 2.077982e-05
range(allsites$H[which(allsites$CLASS == "Resident" & allsites$SAMPLE %in% res.unrelate == TRUE)])
#[1] 0.0001854781 0.0002576843

# Translocated (all pairwise r <= 0.4)
mean(allsites$H[which(allsites$CLASS == "Translocated" & allsites$SAMPLE %in% donor.unrelate == TRUE)])
#[1] 0.0002138821
sd(allsites$H[which(allsites$CLASS == "Translocated" & allsites$SAMPLE %in% donor.unrelate == TRUE)])
#[1] 3.394935e-05
range(allsites$H[which(allsites$CLASS == "Translocated" & allsites$SAMPLE %in% donor.unrelate == TRUE)])
#[1] 0.0001607426 0.0002839456

# Other M4
mean(allsites$H[which(allsites$CLASS == "M4" & allsites$SAMPLE %in% histmeta.unrelate == TRUE)])
#[1] 0.0002429067
sd(allsites$H[which(allsites$CLASS == "M4" & allsites$SAMPLE %in% histmeta.unrelate == TRUE)])
#[1] 3.167934e-05
range(allsites$H[which(allsites$CLASS == "M4" & allsites$SAMPLE %in% histmeta.unrelate == TRUE)])
#[1] 0.0001966109 0.0003019788

# H for samples (for which all pairwise r <= 0.4) is normally distributed

shapiro.test(allsites$H[which(allsites$CLASS == "Contemporary" & allsites$SAMPLE %in% contemp.unrelate == TRUE)])
#
#	Shapiro-Wilk normality test
#
#data:  allsites$H[which(allsites$group == "Contemporary" & allsites$SAMPLE %in% contemp.unrelate == TRUE)]
#W = 0.96952, p-value = 0.5679

shapiro.test(allsites$H[which(allsites$CLASS == "Resident" & allsites$SAMPLE %in% res.unrelate == TRUE)])
#
#	Shapiro-Wilk normality test
#
#data:  allsites$H[which(allsites$group == "Resident" & allsites$SAMPLE %in% res.unrelate == TRUE)]
#W = 0.95371, p-value = 0.6196

shapiro.test(allsites$H[which(allsites$CLASS == "Translocated" & allsites$SAMPLE %in% donor.unrelate == TRUE)])
#
#	Shapiro-Wilk normality test
#
#data:  allsites$H[which(allsites$group == "Translocated" & allsites$SAMPLE %in% donor.unrelate == TRUE)]
#W = 0.97319, p-value = 0.9022

shapiro.test(allsites$H[which(allsites$CLASS == "M4" & allsites$SAMPLE %in% histmeta.unrelate == TRUE)])
#
#	Shapiro-Wilk normality test
#
#data:  allsites$H[which(allsites$group == "M4" & allsites$SAMPLE %in% histmeta.unrelate == TRUE)]
#W = 0.96109, p-value = 0.8096

# Test for differences in mean H between groups after having removed relatedness > 0.4

# Contemporary CR vs Resident CR
t.test(x=allsites$H[which(allsites$CLASS == "Contemporary" & allsites$SAMPLE %in% contemp.unrelate == TRUE)], y=allsites$H[which(allsites$CLASS == "Resident" & allsites$SAMPLE %in% res.unrelate == TRUE)], alternative="two.sided")
#
#	Welch Two Sample t-test
#
#data:  allsites$H[which(allsites$CLASS == "Contemporary" & allsites$SAMPLE %in% contemp.unrelate == TRUE)] and allsites$H[which(allsites$CLASS == "Resident" & allsites$SAMPLE %in% res.unrelate == TRUE)]
#t = -4.5105, df = 23.531, p-value = 0.0001503
#alternative hypothesis: true difference in means is not equal to 0
#95 percent confidence interval:
# -4.313854e-05 -1.603385e-05
#sample estimates:
#   mean of x    mean of y 
#0.0002010206 0.0002306068

# Contemporary CR vs translocated
t.test(x=allsites$H[which(allsites$CLASS == "Contemporary" & allsites$SAMPLE %in% contemp.unrelate == TRUE)], y=allsites$H[which(allsites$CLASS == "Translocated" & allsites$SAMPLE %in% donor.unrelate == TRUE)], alternative="two.sided")
#
#	Welch Two Sample t-test
#
#data:  allsites$H[which(allsites$CLASS == "Contemporary" & allsites$SAMPLE %in% contemp.unrelate == TRUE)] and allsites$H[which(allsites$CLASS == "Translocated" & allsites$SAMPLE %in% donor.unrelate == TRUE)]
#t = -1.3632, df = 18.55, p-value = 0.1892
#alternative hypothesis: true difference in means is not equal to 0
#95 percent confidence interval:
# -3.264187e-05  6.918801e-06
#sample estimates:
#   mean of x    mean of y 
#0.0002010206 0.0002138821

# Resident CR versus translocated
t.test(x=allsites$H[which(allsites$CLASS == "Resident" & allsites$SAMPLE %in% res.unrelate == TRUE)], y=allsites$H[which(allsites$CLASS == "Translocated" & allsites$SAMPLE %in% donor.unrelate == TRUE)], alternative="two.sided")
#
#	Welch Two Sample t-test
#
#data:  allsites$H[which(allsites$CLASS == "Resident" & allsites$SAMPLE %in% res.unrelate == TRUE)] and allsites$H[which(allsites$CLASS == "Translocated" & allsites$SAMPLE %in% donor.unrelate == TRUE)]
#t = 1.6117, df = 23.43, p-value = 0.1204
#alternative hypothesis: true difference in means is not equal to 0
#95 percent confidence interval:
# -4.719847e-06  3.816916e-05
#sample estimates:
#   mean of x    mean of y 
#0.0002306068 0.0002138821

--- end R code ---

## Watterson's Theta and nucleotide diversity

--- start R code ---

grps = c("C", "contemporary_unrelated", "resident", "resident_unrelated", "T", "translocated_unrelated", "M4")

# T' is actually donor sites because it includes T_072 (RSW-K) who was from Site 1 but not translocated,
# 'translocated_unrelated' are just translocated jays.
# 'unrelated' groups are subsets of individuals for which all pairwise relatedness is <= 0.01

fprefix="/mnt/research/Fitz_Lab/projects/mosaic/popgen/theta/fsj_mosaic_allsites_main_autosomes_qc"

df = NULL
for (g in grps) {
        theta <- read.table(paste0(fprefix,"_",g,".thetas.idx.pestPG"))
        nsites = sum(theta[,14])
        theta$wt = theta[,14]/nsites
        df=rbind(df, data.frame(Group=g, Theta_Watterson = sum(theta[,4])/nsites, Pi = sum(theta[,5])/nsites, TajimaD = sum(theta[,9]*theta$wt)))
}

# write output
#write.table(df,file='/mnt/research/Fitz_Lab/projects/mosaic/popgen/theta/fsj_mosaic_allsites_main_autosomes_qc_genome_all_groups.thetas', col.names=TRUE, row.names=FALSE, quote=FALSE, sep="\t")

--- end R code ---

Reported thetas estimated using all contemporary CR and all resident CR individuals in the manuscript.

## ---------- INBREEDING NGSF ---------- ##

## Individual inbreeding based on deviation from Hardy-Weinberg Equilibrium genotype frequencies

The following describes calculating individual inbreeding coefficients, F, with ngsF based on allele frequencies 
for the population specific to sets of individuals. Allele frequencies were estimated for groups for which at least 
10 individuals were sampled after subsetting such that all within-group pairwise r <= 0.4.

# Calculate genotype likelihoods for populations

Genotype likelihoods for the Contemporary CR population

$sbatch /mnt/research/Fitz_Lab/projects/mosaic/popgen/genotypes/contemporary_binary_gl.sh
implements:

--- start bash code ---

BAMLIST='/mnt/research/Fitz_Lab/projects/mosaic/map/population_specific_bam_lists/contemporary_cr_bams.txt'
REGFILE='/mnt/research/Fitz_Lab/ref/bird/FSJ_V3/FSJ_V3_main_autosomes.txt'
SITESFILE='/mnt/research/Fitz_Lab/projects/mosaic/variants/vcf/biallelic_snps/fsj_mosaic_biallelic_snps_main_autosomes_qc.pos'
OUTPREFIX='/mnt/research/Fitz_Lab/projects/mosaic/popgen/genotypes/contemporary_cr_biallelic_snps_main_autosomes_qc_glf3'

angsd -bam $BAMLIST -out $OUTPREFIX -GL 1 -doGlf 3 -doMaf 1 -doMajorMinor 1 -SNP_pval 1e-4 -minQ 20 -minMapQ 20 -remove_bads 1 -only_proper_pairs 1 -uniqueOnly 1 -rf $REGFILE -sites $SITESFILE -P 16

--- end bash code ---

Genotype likelihoods for the resident CR population

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/popgen/genotypes/resident_binary_gl.sh
implements:

--- start bash code ---

BAMLIST='/mnt/research/Fitz_Lab/projects/mosaic/map/population_specific_bam_lists/resident_cr_bams.txt'
REGFILE='/mnt/research/Fitz_Lab/ref/bird/FSJ_V3/FSJ_V3_main_autosomes.txt'
SITESFILE='/mnt/research/Fitz_Lab/projects/mosaic/variants/vcf/biallelic_snps/fsj_mosaic_biallelic_snps_main_autosomes_qc.pos'
OUTPREFIX='/mnt/research/Fitz_Lab/projects/mosaic/popgen/genotypes/resident_cr_biallelic_snps_main_autosomes_qc_glf3'

angsd -bam $BAMLIST -out $OUTPREFIX -GL 1 -doGlf 3 -doMaf 1 -doMajorMinor 1 -SNP_pval 1e-4 -minQ 20 -minMapQ 20 -remove_bads 1 -only_proper_pairs 1 -uniqueOnly 1 -rf $REGFILE -sites $SITESFILE -P 16

--- end bash code ---

Genotype likelihoods for the donor population individuals

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/popgen/genotypes/donor_pop_binary_gl.sh
implements:

--- start bash code ---

BAMLIST='/mnt/research/Fitz_Lab/projects/mosaic/map/population_specific_bam_lists/donor_pop_bams.txt'
REGFILE='/mnt/research/Fitz_Lab/ref/bird/FSJ_V3/FSJ_V3_main_autosomes.txt'
SITESFILE='/mnt/research/Fitz_Lab/projects/mosaic/variants/vcf/biallelic_snps/fsj_mosaic_biallelic_snps_main_autosomes_qc.pos'
OUTPREFIX='/mnt/research/Fitz_Lab/projects/mosaic/popgen/genotypes/donor_pops_biallelic_snps_main_autosomes_qc_glf3'

angsd -bam $BAMLIST -out $OUTPREFIX -GL 1 -doGlf 3 -doMaf 1 -doMajorMinor 1 -SNP_pval 1e-4 -minQ 20 -minMapQ 20 -remove_bads 1 -only_proper_pairs 1 -uniqueOnly 1 -rf $REGFILE -sites $SITESFILE -P 16

--- end bash code ---

Genotype likelihoods for all historic (jays sampled from 2003-2008) M4 metapopulation individuals

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/popgen/genotypes/historic_metapop_binary_gl.sh
implements:

--- start bash code ---

BAMLIST='/mnt/research/Fitz_Lab/projects/mosaic/map/population_specific_bam_lists/historic_metapopulation_bams.txt'
REGFILE='/mnt/research/Fitz_Lab/ref/bird/FSJ_V3/FSJ_V3_main_autosomes.txt'
SITESFILE='/mnt/research/Fitz_Lab/projects/mosaic/variants/vcf/biallelic_snps/fsj_mosaic_biallelic_snps_main_autosomes_qc.pos'
OUTPREFIX='/mnt/research/Fitz_Lab/projects/mosaic/popgen/genotypes/historic_metapop_biallelic_snps_main_autosomes_qc_glf3'

angsd -bam $BAMLIST -out $OUTPREFIX -GL 1 -doGlf 3 -doMaf 1 -doMajorMinor 1 -SNP_pval 1e-4 -minQ 20 -minMapQ 20 -remove_bads 1 -only_proper_pairs 1 -uniqueOnly 1 -rf $REGFILE -sites $SITESFILE -P 16

--- end bash code ---
 
Genotype likelihoods for Site 13

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/popgen/genotypes/site13_binary_gl.sh
implements:

--- start bash code ---

BAMLIST='/mnt/research/Fitz_Lab/projects/mosaic/map/population_specific_bam_lists/site13_bams.txt'
REGFILE='/mnt/research/Fitz_Lab/ref/bird/FSJ_V3/FSJ_V3_main_autosomes.txt'
SITESFILE='/mnt/research/Fitz_Lab/projects/mosaic/variants/vcf/biallelic_snps/fsj_mosaic_biallelic_snps_main_autosomes_qc.pos'
OUTPREFIX='/mnt/research/Fitz_Lab/projects/mosaic/popgen/genotypes/site13_biallelic_snps_main_autosomes_qc_glf3'

angsd -bam $BAMLIST -out $OUTPREFIX -GL 1 -doGlf 3 -doMaf 1 -doMajorMinor 1 -SNP_pval 1e-4 -minQ 20 -minMapQ 20 -remove_bads 1 -only_proper_pairs 1 -uniqueOnly 1 -rf $REGFILE -sites $SITESFILE -P 16

--- end bash code ---

# Calculate inbreeding coefficients with ngsF

Calculate inbreeding coefficient for Contemporary CR individuals using Contemporary CR allele frequencies

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/popgen/fstats/contemporary_inbreed_coef.sh
implements:

--- start bash code ---

GENOLIKES='/mnt/research/Fitz_Lab/projects/mosaic/popgen/genotypes/contemporary_cr_biallelic_snps_main_autosomes_qc_glf3.glf'
OUTFILE='/mnt/research/Fitz_Lab/projects/mosaic/popgen/fstats/contemporary_cr_biallelic_snps_main_autosomes_qc_F.txt'

CMD="ngsF --glf $GENOLIKES --init_values e --out $OUTFILE --n_ind 28 --n_sites 1347940 --max_iters 3000 --n_threads 20"

printf "\n%s\n\n" "$CMD"

eval $CMD

--- end bash code ---

Calculate inbreeding coefficient for Resident CR individuals using Resident CR allele frequencies

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/popgen/fstats/resident_inbreed_coef.sh
implements:

--- start bash code ---

GENOLIKES='/mnt/research/Fitz_Lab/projects/mosaic/popgen/genotypes/resident_cr_biallelic_snps_main_autosomes_qc_glf3.glf'
OUTFILE='/mnt/research/Fitz_Lab/projects/mosaic/popgen/fstats/resident_cr_biallelic_snps_main_autosomes_qc_F.txt'

CMD="ngsF --glf $GENOLIKES --init_values e --out $OUTFILE --n_ind 16 --n_sites 1204026 --max_iters 3000 --n_threads 20"

printf "\n%s\n\n" "$CMD"

eval $CMD

--- end bash code ---

Calculate inbreeding coefficient for Site 13 individuals using Site 13 allele frequencies

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/popgen/fstats/site13_inbreed_coef.sh
implements:

--- start bash code ---

GENOLIKES='/mnt/research/Fitz_Lab/projects/mosaic/popgen/genotypes/site13_biallelic_snps_main_autosomes_qc_glf3.glf'
OUTFILE='/mnt/research/Fitz_Lab/projects/mosaic/popgen/fstats/site13_biallelic_snps_main_autosomes_qc_F.txt'

CMD="ngsF --glf $GENOLIKES --init_values e --out $OUTFILE --n_ind 19 --n_sites 919620 --max_iters 3000 --n_threads 20"

printf "\n%s\n\n" "$CMD"

eval $CMD

--- end bash code ---

Calculate inbreeding coefficient for donor site individuals using pooled donor site allele frequencies

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/popgen/fstats/donor_pops_inbreed_coef.sh
implements:

--- start bash code ---

GENOLIKES='/mnt/research/Fitz_Lab/projects/mosaic/popgen/genotypes/donor_pops_biallelic_snps_main_autosomes_qc_glf3.glf'
OUTFILE='/mnt/research/Fitz_Lab/projects/mosaic/popgen/fstats/donor_pops_biallelic_snps_main_autosomes_qc_F.txt'

CMD="ngsF --glf $GENOLIKES --init_values e --out $OUTFILE --n_ind 30 --n_sites 1391693 --max_iters 3000 --n_threads 20"

printf "\n%s\n\n" "$CMD"

eval $CMD

--- end bash code ---

Calculate inbreeding coefficient for historic metapopulation individuals using historic metapopulation allele frequencies

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/popgen/fstats/historic_metapop_inbreed_coef.sh
implements:

--- start bash code ---

GENOLIKES='/mnt/research/Fitz_Lab/projects/mosaic/popgen/genotypes/historic_metapop_biallelic_snps_main_autosomes_qc_glf3.glf'
OUTFILE='/mnt/research/Fitz_Lab/projects/mosaic/popgen/fstats/historic_metapop_biallelic_snps_main_autosomes_qc_F.txt'

CMD="ngsF --glf $GENOLIKES --init_values e --out $OUTFILE --n_ind 59 --n_sites 1869994 --max_iters 3000 --n_threads 20"

printf "\n%s\n\n" "$CMD"

eval $CMD

--- end bash code ---

Attach individual identity to the output of ngsF and collate results that use population specific allele frequencies. Note that 
{site1, site12, site18, Texaco} used allele frequencies from the pool of all donor sites and all 'other' M4 individuals used 
allele frequencies of the historic metapopulation (all jays sampled from 2003-2008). Allele frequencies were estimated after removing 
first degree relationships (all r <= 0.4 to be exact).

--- start R code ---

# read in metadata
meta <- read.table('/mnt/research/Fitz_Lab/projects/mosaic/M4_sequenced_FSJsamples_metadata.txt',head=TRUE,sep="\t")

# read in F values
contemp_cr <- read.table('/mnt/research/Fitz_Lab/projects/mosaic/popgen/fstats/contemporary_cr_biallelic_snps_main_autosomes_qc_F.txt', head=FALSE)
res_cr <- read.table('/mnt/research/Fitz_Lab/projects/mosaic/popgen/fstats/resident_cr_biallelic_snps_main_autosomes_qc_F.txt', head=FALSE)
s13 <- read.table('/mnt/research/Fitz_Lab/projects/mosaic/popgen/fstats/site13_biallelic_snps_main_autosomes_qc_F.txt', head=FALSE)
donor <- read.table('/mnt/research/Fitz_Lab/projects/mosaic/popgen/fstats/donor_pops_biallelic_snps_main_autosomes_qc_F.txt', head=FALSE)
histmeta <- read.table('/mnt/research/Fitz_Lab/projects/mosaic/popgen/fstats/historic_metapop_biallelic_snps_main_autosomes_qc_F.txt', head=FALSE)

# read in lists of bam files used to calculate genotype likelihood input for ngsF
contemp_bam <- read.table('/mnt/research/Fitz_Lab/projects/mosaic/map/population_specific_bam_lists/contemporary_cr_bams.txt', head=FALSE)
res_bam <- read.table('/mnt/research/Fitz_Lab/projects/mosaic/map/population_specific_bam_lists/resident_cr_bams.txt', head=FALSE)
s13_bam <- read.table('/mnt/research/Fitz_Lab/projects/mosaic/map/population_specific_bam_lists/site13_bams.txt', head=FALSE)
donor_bam <- read.table('/mnt/research/Fitz_Lab/projects/mosaic/map/population_specific_bam_lists/donor_pop_bams.txt', head=FALSE)
histmeta_bam <- read.table('/mnt/research/Fitz_Lab/projects/mosaic/map/population_specific_bam_lists/historic_metapopulation_bams.txt', head=FALSE)

# Associate IDs with F values
contemp_cr$ID <- gsub('/mnt/research/Fitz_Lab/projects/mosaic/map/bam/|.bam','',contemp_bam$V1)
res_cr$ID <- gsub('/mnt/research/Fitz_Lab/projects/mosaic/map/bam/|.bam','',res_bam$V1)
s13$ID <- gsub('/mnt/research/Fitz_Lab/projects/mosaic/map/bam/|.bam','',s13_bam$V1)
donor$ID <- gsub('/mnt/research/Fitz_Lab/projects/mosaic/map/bam/|.bam','',donor_bam$V1)
histmeta$ID <- gsub('/mnt/research/Fitz_Lab/projects/mosaic/map/bam/|.bam','',histmeta_bam$V1)

# collate values
combF <- data.frame(ID=read.table('/mnt/research/Fitz_Lab/projects/mosaic/M4_sequenced_FSJsamples_metadata.txt',head=TRUE,sep="\t")$LAB_ID)
combF$F_CONTEMPORARY_CR_AF <- unname(sapply(combF$ID,function(x,df){idx = which(df$ID == x); ifelse(length(idx) > 0, df$V1[idx], NA)}, df=contemp_cr))
combF$F_RESIDENT_CR_AF <- unname(sapply(combF$ID,function(x,df){idx = which(df$ID == x); ifelse(length(idx) > 0, df$V1[idx], NA)}, df=res_cr))
combF$F_SITE13_AF <- unname(sapply(combF$ID,function(x,df){idx = which(df$ID == x); ifelse(length(idx) > 0, df$V1[idx], NA)}, df=s13))
combF$F_DONOR_AF <- unname(sapply(combF$ID,function(x,df){idx = which(df$ID == x); ifelse(length(idx) > 0, df$V1[idx], NA)}, df=donor))
combF$F_HISTORIC_METAPOP_AF <- unname(sapply(combF$ID,function(x,df){idx = which(df$ID == x); ifelse(length(idx) > 0, df$V1[idx], NA)}, df=histmeta))

# Generate a column of F calculated using population specific allele frequencies
combF$F_POP_SPECIFIC_AF <- NA
for (i in 1:nrow(combF)) {
	id <- combF$ID[i]
	pop <- meta$pop[which(meta$LAB_ID == id)]
	if (pop == "Contemporary") {
		combF$F_POP_SPECIFIC_AF[i] <- combF$F_CONTEMPORARY_CR_AF[i]
	} else if (pop == "Resident") {
		combF$F_POP_SPECIFIC_AF[i] <- combF$F_RESIDENT_CR_AF[i]
	} else if (pop == "SITE_13") {
		combF$F_POP_SPECIFIC_AF[i] <- combF$F_SITE13_AF[i]
	} else if (pop == "SITE_1" || pop == "SITE_12" || pop == "SITE_18" || pop == "TEXACO") {
		combF$F_POP_SPECIFIC_AF[i] <- combF$F_DONOR_AF[i]
	} else if (pop == "Golden_Aster_Scrub" || pop == "Brigman" || pop == "W.Balm" || pop == "Duette_headwaters" || pop == "Sun_City") {
		combF$F_POP_SPECIFIC_AF[i] <- combF$F_HISTORIC_METAPOP_AF[i]
	} else {
		stop(paste0("Unknown population ",pop))
	}
}

# write results
# write.table(combF, file='/mnt/research/Fitz_Lab/projects/mosaic/popgen/fstats/fsj_mosaic_biallelic_snps_main_autosomes_qc_all_F_pop_specific_ref_AF.txt', col.names=TRUE, row.names=FALSE, sep="\t", quote=FALSE)

--- end R code ---

## Statistical tests comparing F between groups

--- start R code ---

# read in F values calculated using population-specific allele frequencies
f.popaf <- read.table('/mnt/research/Fitz_Lab/projects/mosaic/popgen/fstats/fsj_mosaic_biallelic_snps_main_autosomes_qc_all_F_pop_specific_ref_AF.txt', head=TRUE)

# read in IDs for subsets of individuals
contemp.all <- read.table('/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/inputs/contemporary_cr_ids.txt',head=FALSE)$V1 # pairwise relatedness between all of these samples is < 0.4, so is an "unrelated" sample for this analysis
res.all <- read.table('/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/inputs/resident_cr_ids.txt',head=FALSE)$V1
res.unrelate <- read.table('/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/inputs/resident_cr_relatedness_maxr0.4_ids.txt',head=FALSE)$V1
donors.all <- read.table('/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/inputs/donor_pops_ids.txt',head=FALSE)$V1
trans.all <- donors.all[-which(donors.all == "T_072")] # all translocated individuals
donors.unrelated <- read.table('/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/inputs/donor_pops_relatedness_maxr0.4_ids.txt',head=FALSE)$V1
trans.unrelated <- donors.unrelated[-which(donors.unrelated == "T_072")] # translocated individuals with no first degree relatives

## F is not normally distributed

shapiro.test(f.popaf$F_POP_SPECIFIC_AF[which(f.popaf$ID %in% contemp.all == TRUE)])
#
#	Shapiro-Wilk normality test
#
#data:  f.popaf$F_POP_SPECIFIC_AF[which(f.popaf$ID %in% contemp.all == TRUE)]
#W = 0.52384, p-value = 2.028e-08

shapiro.test(f.popaf$F_POP_SPECIFIC_AF[which(f.popaf$ID %in% res.all == TRUE)])
#
#	Shapiro-Wilk normality test
#
#data:  f.popaf$F_POP_SPECIFIC_AF[which(f.popaf$ID %in% res.all == TRUE)]
#W = 0.46324, p-value = 1.068e-06

shapiro.test(f.popaf$F_POP_SPECIFIC_AF[which(f.popaf$ID %in% res.unrelate == TRUE)])
#
#	Shapiro-Wilk normality test
#
#data:  f.popaf$F_POP_SPECIFIC_AF[which(f.popaf$ID %in% res.unrelate == TRUE)]
#W = 0.45359, p-value = 2.618e-06

shapiro.test(f.popaf$F_POP_SPECIFIC_AF[which(f.popaf$ID %in% trans.all == TRUE)])
#
#	Shapiro-Wilk normality test
#
#data:  f.popaf$F_POP_SPECIFIC_AF[which(f.popaf$ID %in% trans.all == TRUE)]
#W = 0.51958, p-value = 1.256e-08

shapiro.test(f.popaf$F_POP_SPECIFIC_AF[which(f.popaf$ID %in% trans.unrelated == TRUE)])
#
#	Shapiro-Wilk normality test
#
#data:  f.popaf$F_POP_SPECIFIC_AF[which(f.popaf$ID %in% trans.unrelated == TRUE)]
#W = 0.68529, p-value = 0.0001738

## F summary stats for different groups

# All Contemporary CR individuals (all pairwise r < 0.4, i.e. no first degree relatives)
mean(f.popaf$F_POP_SPECIFIC_AF[which(f.popaf$ID %in% contemp.all == TRUE)])
#[1] 0.01707861 
sd(f.popaf$F_POP_SPECIFIC_AF[which(f.popaf$ID %in% contemp.all == TRUE)])
#[1] 0.02587532
range(f.popaf$F_POP_SPECIFIC_AF[which(f.popaf$ID %in% contemp.all == TRUE)])
#[1] 0.001406 0.137558

# All resident CR individuals
mean(f.popaf$F_POP_SPECIFIC_AF[which(f.popaf$ID %in% res.all == TRUE)])
#[1] 0.01012019
sd(f.popaf$F_POP_SPECIFIC_AF[which(f.popaf$ID %in% res.all == TRUE)])
#[1] 0.02268801
range(f.popaf$F_POP_SPECIFIC_AF[which(f.popaf$ID %in% res.all == TRUE)])
#[1] 0.000277 0.091737

# Unrelated resident CR individuals
mean(f.popaf$F_POP_SPECIFIC_AF[which(f.popaf$ID %in% res.unrelate == TRUE)])
#[1] 0.01033443
#sd(f.popaf$F_POP_SPECIFIC_AF[which(f.popaf$ID %in% res.unrelate == TRUE)])
[1] 0.02424458
range(f.popaf$F_POP_SPECIFIC_AF[which(f.popaf$ID %in% res.unrelate == TRUE)])
#[1] 0.000277 0.091737

# all translocated individuals
mean(f.popaf$F_POP_SPECIFIC_AF[which(f.popaf$ID %in% trans.all == TRUE)])
#[1] 0.004767345
sd(f.popaf$F_POP_SPECIFIC_AF[which(f.popaf$ID %in% trans.all == TRUE)])
#[1] 0.009077819
#range(f.popaf$F_POP_SPECIFIC_AF[which(f.popaf$ID %in% trans.all == TRUE)])
[1] 0.000092 0.042977

# unrelated translocated individuals
mean(f.popaf$F_POP_SPECIFIC_AF[which(f.popaf$ID %in% trans.unrelated == TRUE)])
#[1] 0.008187267
sd(f.popaf$F_POP_SPECIFIC_AF[which(f.popaf$ID %in% trans.unrelated == TRUE)])
#[1] 0.01176101
range(f.popaf$F_POP_SPECIFIC_AF[which(f.popaf$ID %in% trans.unrelated == TRUE)])
#[1] 0.000183 0.042977

## Test for differences in F

# Contemporary vs Resident CR after removing relatedness > 0.4
wilcox.test(x=f.popaf$F_POP_SPECIFIC_AF[which(f.popaf$ID %in% contemp.all == TRUE)], y=f.popaf$F_POP_SPECIFIC_AF[which(f.popaf$ID %in% res.unrelate == TRUE)], alternative="two.sided")
#
#	Wilcoxon rank sum exact test
#
#data:  f.popaf$F_POP_SPECIFIC_AF[which(f.popaf$ID %in% contemp.all == TRUE)] and f.popaf$F_POP_SPECIFIC_AF[which(f.popaf$ID %in% res.unrelate == TRUE)]
#W = 308, p-value = 0.002208
#alternative hypothesis: true location shift is not equal to 0

# All Contemporary vs all Resident CR
wilcox.test(x=f.popaf$F_POP_SPECIFIC_AF[which(f.popaf$ID %in% contemp.all == TRUE)], y=f.popaf$F_POP_SPECIFIC_AF[which(f.popaf$ID %in% res.all == TRUE)], alternative="two.sided")
#
#	Wilcoxon rank sum exact test
#
#data:  f.popaf$F_POP_SPECIFIC_AF[which(f.popaf$ID %in% contemp.all == TRUE)] and f.popaf$F_POP_SPECIFIC_AF[which(f.popaf$ID %in% res.all == TRUE)]
#W = 340, p-value = 0.004002
#alternative hypothesis: true location shift is not equal to 0

# Contemporary versus unrelated translocated
wilcox.test(x=f.popaf$F_POP_SPECIFIC_AF[which(f.popaf$ID %in% contemp.all == TRUE)], y=f.popaf$F_POP_SPECIFIC_AF[which(f.popaf$ID %in% trans.unrelated == TRUE)], alternative="two.sided")
#
#	Wilcoxon rank sum exact test
#
#data:  f.popaf$F_POP_SPECIFIC_AF[which(f.popaf$ID %in% contemp.all == TRUE)] and f.popaf$F_POP_SPECIFIC_AF[which(f.popaf$ID %in% trans.unrelated == TRUE)]
#W = 298, p-value = 0.02453
#alternative hypothesis: true location shift is not equal to 0

# Contemporary versus all translocated
wilcox.test(x=f.popaf$F_POP_SPECIFIC_AF[which(f.popaf$ID %in% contemp.all == TRUE)], y=f.popaf$F_POP_SPECIFIC_AF[which(f.popaf$ID %in% trans.all == TRUE)], alternative="two.sided")
#
#	Wilcoxon rank sum exact test
#
#data:  f.popaf$F_POP_SPECIFIC_AF[which(f.popaf$ID %in% contemp.all == TRUE)] and f.popaf$F_POP_SPECIFIC_AF[which(f.popaf$ID %in% trans.all == TRUE)]
#W = 682, p-value = 3.515e-06
#alternative hypothesis: true location shift is not equal to 0

# Resident CR versus translocated individuals after removing relatedness > 0.4
wilcox.test(x=f.popaf$F_POP_SPECIFIC_AF[which(f.popaf$ID %in% res.unrelate == TRUE)], y=f.popaf$F_POP_SPECIFIC_AF[which(f.popaf$ID %in% trans.unrelated == TRUE)], alternative="two.sided")
#
#	Wilcoxon rank sum exact test
#
#data:  f.popaf$F_POP_SPECIFIC_AF[which(f.popaf$ID %in% res.unrelate == TRUE)] and f.popaf$F_POP_SPECIFIC_AF[which(f.popaf$ID %in% trans.unrelated == TRUE)]
#W = 89, p-value = 0.5045
#alternative hypothesis: true location shift is not equal to 0

# All Resident CR versus all translocated individuals
wilcox.test(x=f.popaf$F_POP_SPECIFIC_AF[which(f.popaf$ID %in% res.all == TRUE)], y=f.popaf$F_POP_SPECIFIC_AF[which(f.popaf$ID %in% trans.all == TRUE)], alternative="two.sided")
#
#	Wilcoxon rank sum exact test
#
#data:  f.popaf$F_POP_SPECIFIC_AF[which(f.popaf$ID %in% res.all == TRUE)] and f.popaf$F_POP_SPECIFIC_AF[which(f.popaf$ID %in% trans.all == TRUE)]
#W = 282, p-value = 0.2435
#alternative hypothesis: true location shift is not equal to 0

--- end R code ---


## boxplots comparing individuals inbreeding esimated using population-specific allele frequencies

--- start R code ---

library(scales)

meta <- read.table('/home/tyler/Dropbox/research/jay/mosaic/metadata/M4_sequenced_FSJsamples_metadata.txt',head=TRUE,sep="\t")
fdf <- read.table('/home/tyler/Dropbox/research/jay/mosaic/popgen/fstats/fsj_mosaic_biallelic_snps_main_autosomes_qc_all_F_pop_specific_ref_AF.txt', head=TRUE)
fdf <- fdf[match(meta$LAB_ID, fdf$ID),] # ensure that the order of individuals matches the metadata

meta$popletter <- popletters(meta) # popletters function defined in /home/tyler/Dropbox/research/jay/mosaic/popgen/fstats/README_MOSAIC_ANALYSIS
meta$popcol <- popcolor(meta) # popcolor function defined in /home/tyler/Dropbox/research/jay/mosaic/popgen/fstats/README_MOSAIC_ANALYSIS
meta$colors <- sitecol(meta) # sitecol function defined in /home/tyler/Dropbox/research/jay/mosaic/popgen/fstats/README_MOSAIC_ANALYSIS

# define groups
groups <- meta$pop
grplevels <- c("Contemporary", "Resident", "Translocated", "M4")

groups <- replace(groups, which(groups == "Golden_Aster_Scrub" | groups == "Brigman" | groups == "W.Balm" | 
groups == "Duette_headwaters" | groups == "Sun_City"), "M4")

groups <- replace(groups, which(groups == "SITE_1" | groups == "SITE_12" | groups == "SITE_13" | 
groups == "SITE_18" | groups == "TEXACO"), "Translocated")

fdf$group = factor(groups,levels=grplevels)

# omit T_072 (RSW-K) because this site 1 bird was not translocated and migrated to LMSP, which is outside of the Core
fdf <- fdf[-which(fdf$ID == "T_072"),]
meta <- meta[-which(meta$LAB_ID == "T_072"),]

# set point type
fdf$biopoint = biopoint(meta$pop) # biopoint function defined in /home/tyler/Dropbox/research/jay/mosaic/popgen/fstats/README_MOSAIC_ANALYSIS

max(fdf$F_POP_SPECIFIC_AF)
# [1] 0.137558 # set upper y-limit above this value

# plot
# h_boxplot2 function defined in /home/tyler/Dropbox/research/jay/mosaic/popgen/fstats/README_MOSAIC_ANALYSIS

#png(file='/home/tyler/Dropbox/research/jay/mosaic/figures/F_distribution_pop_specific_AF.png',width=7, height=7,units='in', res=300)
h_boxplot2(x=fdf, n=7, lev=grplevels, ylabel=expression(Individual~inbreeding~(italic(F))), pntlab=fdf$biopoint, seed=1947, color=meta$popcol, ylim=c(0,0.145))
axis(2, at=c((0.0+0.05)/2, (0.05+0.1)/2, (0.1+0.15)/2), line=NA, labels=NA) # add some extra axis tick marks for clarity
#dev.off()


# make plot with IDs at points
#pdf(file='/home/tyler/Dropbox/research/jay/mosaic/figures/F_distribution_pop_specific_AF_text.pdf',width=7, height=7)
h_boxplot2(x=fdf, n=7, lev=grplevels, ylabel=expression(Individual~inbreeding~(italic(F))), pntlab=NULL, seed=1947, color=meta$popcol, ylimits=c(0,0.145), idlabels=fdf$ID)
axis(2, at=c((0.0+0.05)/2, (0.05+0.1)/2, (0.1+0.15)/2), line=NA, labels=NA) # add some extra axis tick marks for clarity

# zoomed in plot to better distinguish IDs
h_boxplot2(x=fdf, n=7, lev=grplevels, ylabel=expression(Individual~inbreeding~(italic(F))), pntlab=NULL, seed=1947, color=meta$popcol, ylimits=c(0,0.05), idlabels=fdf$ID)
axis(2, at=c((0.0+0.05)/2, (0.05+0.1)/2, (0.1+0.15)/2), line=NA, labels=NA) # add some extra axis tick marks for clarity

# zoomed in more
h_boxplot2(x=fdf, n=7, lev=grplevels, ylabel=expression(Individual~inbreeding~(italic(F))), pntlab=NULL, seed=1947, color=meta$popcol, ylimits=c(0,0.008), idlabels=fdf$ID)
axis(2, at=c((0.0+0.05)/2, (0.05+0.1)/2, (0.1+0.15)/2), line=NA, labels=NA) # add some extra axis tick marks for clarity

# zoom even more
h_boxplot2(x=fdf, n=7, lev=grplevels, ylabel=expression(Individual~inbreeding~(italic(F))), pntlab=NULL, seed=1947, color=meta$popcol, ylimits=c(0,0.003), idlabels=fdf$ID)
axis(2, at=c((0.0+0.05)/2, (0.05+0.1)/2, (0.1+0.15)/2), line=NA, labels=NA) # add some extra axis tick marks for clarity

#dev.off()

## make a plot to find where the top 5 pedigree-based contributors circled in figure 3A are in the boxplot

h_boxplot_mask <- function(x=NULL, n=NULL, lev=grplevels, ylabel="Heterozygosity", pntlab=NULL, seed=10287, color=NULL, ylimits=NULL, idlabels=NULL) {
        if (length(grep("TeachingDemos",(.packages()))) == 0) library(TeachingDemos) # for shadowtext()
        nlevel = length(lev)

        par(mar=c(5,5,2,2))
        boxplot(x[,n] ~ group, data=x, outline=FALSE, names=c(rep("",nlevel)), xlab="", ylab=ylabel, main="", col="gray80", cex.axis=1.5, cex.lab=1.5, lwd=2, ylim=ylimits)
        #mtext(lev,1,at=1:nlevel, padj=1, cex=1.5)
        mtext(c(lev[1:3],paste("Other","M4",sep="\n")), 1,at=1:nlevel, padj=1, cex=1.5)
        #mtext("Group",1,at=3,padj=2.5, cex=1.5)

        # add points
        for (i in lev) {
                idx = which(as.character(x$group) == i)
                set.seed(seed)
                xjitter = jitter(rep(which(lev == i),length(idx)), amount=0.2)
                ptcol = NULL
                for (j in 1:length(idx)) {
                        if (is.null(color)) ptcol = alpha("maroon",0.5) else ptcol = color[idx[j]]
                        if (is.null(pntlab) || is.na(pntlab[idx[j]])) {
                                if (!is.null(idlabels)) {
                                  text(y=x[idx[j],n], x=xjitter[j],idlabels[idx[j]],cex=0.5,col="red")
                                } else {
                                  points(y=x[idx[j],n], x=xjitter[j], pch=1, cex=1.2)
                                  points(y=x[idx[j],n], x=xjitter[j], pch=16, cex=1.2, col=ptcol)
                                }
                        } else if (class(pntlab) == "numeric") {
                                points(y=x[idx[j],n], x=xjitter[j], pch=pntlab[idx[j]], col=alpha("grey70",0.5), bg=color[idx[j]],lwd=1.3,cex=1.5)
                        }  else if (class(pntlab) == "character") {
                                shadowtext(y=x[idx[j],n], x=xjitter[j], labels=pntlab[idx[j]], col=color[idx[j]], bg=alpha("black",0.5), r=0.07, cex=1.2)       
                        } else stop("Unknown argument to pntlab")
                }
        }

}

meta$maskcol = meta$popcol
meta$maskcol[-which(meta$LAB_ID == "T_071" | meta$LAB_ID == "T_099" | meta$LAB_ID == "T_081" | meta$LAB_ID == "T_086" | meta$LAB_ID == "T_067")] <- alpha("grey90",0)
meta$maskcol[which(meta$LAB_ID == "T_071")] <- alpha(meta$popcol[which(meta$LAB_ID == "T_071")],0.65)
meta$maskcol[which(meta$LAB_ID == "T_099")] <- alpha(meta$popcol[which(meta$LAB_ID == "T_099")],0.65)
meta$maskcol[which(meta$LAB_ID == "T_081")] <- alpha(meta$popcol[which(meta$LAB_ID == "T_081")],0.65)
meta$maskcol[which(meta$LAB_ID == "T_086")] <- alpha(meta$popcol[which(meta$LAB_ID == "T_086")],0.65)
meta$maskcol[which(meta$LAB_ID == "T_067")] <- alpha(meta$popcol[which(meta$LAB_ID == "T_067")],0.65)

h_boxplot_mask(x=fdf, n=7, lev=grplevels, ylabel=expression(Individual~inbreeding~(italic(F))), pntlab=fdf$biopoint, seed=1947, color=meta$maskcol, ylim=c(0,0.145))

--- end R code ---

## ---------- PRINCIPAL COMPONENT ANALYSIS ---------- ##

# Estimate genetic covariance between individuals

TL TODO

# Calculate eigen vectors and values and visualize PCA

covar <- as.matrix(read.table('/home/tyler/Dropbox/research/jay/mosaic/popgen/pca/fsj_mosaic_biallelic_snps_main_autosomes_qc_all_unweighted.covar',head=FALSE))
eig <- eigen(covar)
var <- round((eig$values/sum(eig$values))*100, digits=2)

meta <- read.table('./data/M4_sequenced_FSJsamples_metadata.txt',head=TRUE,sep="\t")
meta$letter_code <- pointletters(meta)
meta$grpcol <- pntcol(meta)
meta$popcode <- popletters(meta)
meta$popcol <- popcolor(meta)

# set color IDs
jayid <- read.csv('/home/tyler/Dropbox/research/jay/mosaic/metadata/jayid_map_20230512.txt',head=TRUE,sep="\t")
meta$COLOR_ID = unname(sapply(meta$LAB_ID,function(x,df){id=df$COLOR_ID[which(df$LAB_ID == x)]; ifelse(id=="*",x,id)},df=jayid)) # uses M4 LAB IDs since the M4 birds don't have color IDs

# plot locality (i.e. type) PCA
#pdf(file='/home/tyler/Dropbox/research/jay/mosaic/popgen/pca/plots/mosaic_fsj_locality.pdf',width=8,height=8)
#pdf(file='/home/tyler/Dropbox/research/jay/mosaic/popgen/pca/plots/mosaic_fsj_locality_colors2.pdf',width=8,height=8)
pdf(file='/home/tyler/Dropbox/research/jay/mosaic/popgen/pca/plots/mosaic_fsj_locality_colors2_print.pdf',width=8,height=8)
i = 1
while (i < 7) {
	j = i+1
	par(mar=c(5.1,4.1,4,2)+0.1)
	plot(x=eig$vectors[,i], y=eig$vectors[,j], xlab=paste0("PC",i,", ",var[i],"%"), ylab=paste0("PC",j,", ",var[j],"%"), type="n", cex.axis=1.4, cex.lab=1.4)
	text(x=eig$vectors[,i],y=eig$vectors[,j], labels = meta$letter_code, col=meta$grpcol, cex=1.2)
	#if (i == 1) legend('topleft',fill=c(meta$grpcol[which(meta$type == "E")[1]], meta$grpcol[which(meta$type == "C")[1]], meta$grpcol[which(meta$type == "T")[1]], meta$grpcol[which(meta$type == "M4")[1]], meta$grpcol[which(meta$type == "I")[1]]), c("E","C","T","M4","I"),bty="n", horiz=TRUE, cex=0.8)
	if (i == 1) legend('topleft',fill=c(meta$grpcol[which(meta$type == "E")[1]], meta$grpcol[which(meta$type == "C")[1]], meta$grpcol[which(meta$type == "T")[1]], meta$grpcol[which(meta$type == "M4")[1]], meta$grpcol[which(meta$type == "I")[1]]), c("E","C","T","M4","U"),bty="n", horiz=TRUE, cex=1.3)
	i = i+2
}
dev.off()

# plot individual PCA
#pdf(file='/home/tyler/Dropbox/research/jay/mosaic/popgen/pca/plots/mosaic_fsj_individual.pdf',width=8,height=8)
pdf(file='/home/tyler/Dropbox/research/jay/mosaic/popgen/pca/plots/mosaic_fsj_individual_popcol.pdf',width=8,height=8)
i = 1
while (i < 13) {
	j = i+1
	plot(x=eig$vectors[,i], y=eig$vectors[,j], xlab=paste0("PC",i,", ",var[i],"%"), ylab=paste0("PC",j,", ",var[j],"%"), type="n")
	#text(x=eig$vectors[,i],y=eig$vectors[,j], labels = meta$LAB_ID, col=meta$grpcol, cex=0.6) # group coloring
	text(x=eig$vectors[,i],y=eig$vectors[,j], labels = meta$LAB_ID, col=meta$popcol, cex=0.6) # pop coloring
	#if (i == 1) legend('topleft',fill=c(meta$grpcol[which(meta$type == "E")[1]], meta$grpcol[which(meta$type == "C")[1]], meta$grpcol[which(meta$type == "T")[1]], meta$grpcol[which(meta$type == "M4")[1]], meta$grpcol[which(meta$type == "I")[1]]), c("E","C","T","M4","I"),bty="n", horiz=TRUE, cex=0.8)
	i = i+2
}
dev.off()

# plot population PCA
idx.wellfield = which(meta$pop == "Resident" | meta$pop == "Contemporary")
pdf(file='/home/tyler/Dropbox/research/jay/mosaic/popgen/pca/plots/mosaic_fsj_pop.pdf',width=8,height=8)
i=1
while (i < 13) {
	j = i+1
	par(mar=c(5.1,4.1,4,2)+0.1)
	plot(x=eig$vectors[,i], y=eig$vectors[,j], xlab=paste0("PC",i,", ",var[i],"%"), ylab=paste0("PC",j,", ",var[j],"%"), type="n", cex.axis=1.4, cex.lab=1.4)
	# text is added in two steps just so that wellfield points are on top
	text(x=eig$vectors[-idx.wellfield,i],y=eig$vectors[-idx.wellfield,j], labels = meta$popcode[-idx.wellfield], col=meta$popcol[-idx.wellfield], cex=1.2)
	text(x=eig$vectors[idx.wellfield,i],y=eig$vectors[idx.wellfield,j], labels = meta$popcode[idx.wellfield], col=meta$popcol[idx.wellfield], cex=1.2)
	i = i+2
}
dev.off()

# plot variability explained
#pdf(file='/home/tyler/Dropbox/research/jay/mosaic/popgen/pca/plots/mosaic_fsj_pca_variance_explained.pdf',width=7,height=7)
n = length(eig$vector[,1])
for (i in 0:2) {
	barplot(var,ylab="% variance explained", xlab="PCs", names.arg=1:n,col=c(rep("gray",i*2),rep("plum4",2),rep("gray",n-(2*(i+1)))))
}
#dev.off()

# PC1 vs PC2 with individuals labeled by biological origin for paper
meta$biopoint <- biopoint(meta$pop)
rswk.idx = which(meta$COLOR_ID == "RSW-K")
#meta$biopoint[rswk.idx] <- 22 # RSW-K was from Site 1B and immigrated into Little Manatee State Park (not part of The Core and was not translocated).

pc1.scale = var[1]/var[2]
axis.height = 8
axis.width = axis.height * pc1.scale

# shape points
x11(width=axis.width,height=axis.height)
#png(file='/home/tyler/Dropbox/research/jay/mosaic/figures/pca_pop_colors.png',width=axis.width, height=axis.height, units='in', res=300)
par(mar=c(5.1,4.1,4,2)+0.1)
plot(x=eig$vectors[,1], y=eig$vectors[,2], xlab=paste0("PC",1,", ",var[1],"%"), ylab=paste0("PC",2,", ",var[2],"%"),cex.axis=1.4, cex.lab=1.4,
pch=meta$biopoint, col=meta$popcol, bg=alpha(meta$popcol,0.65), cex=1.7, lwd=1.2)
points(x=eig$vectors[rswk.idx,1], y=eig$vector[rswk.idx,2], pch=3, cex=1.3, col="grey20", lwd=1.5)

#dev.off()

# text points
x11(width=axis.width,height=axis.height)
#png(file='/home/tyler/Dropbox/research/jay/mosaic/figures/pca_pop_colors_text.png',width=axis.width, height=axis.height, units='in', res=300)
par(mar=c(5.1,4.1,4,2)+0.1)
plot(x=eig$vectors[,1], y=eig$vectors[,2], xlab=paste0("PC",1,", ",var[1],"%"), ylab=paste0("PC",2,", ",var[2],"%"),cex.axis=1.4, cex.lab=1.4, type="n")
text(x=eig$vectors[,1],y=eig$vectors[,2], labels = meta$COLOR_ID, col=meta$popcol, cex=0.5)

#dev.off()


## PCA of Wellfield C population only (2 percent minimum MAF)

covar.c <- as.matrix(read.table('fsj_mosaic_biallelic_snps_main_autosomes_qc_C_minmaf2perc.covar',head=FALSE))
eig.c <- eigen(covar.c)
var.c <- round((eig.c$values/sum(eig.c$values))*100, digits=2)

meta <- read.table('/home/tyler/Dropbox/research/jay/mosaic/metadata/M4_sequenced_FSJsamples_metadata.txt',head=TRUE,sep="\t")
meta$LAB_ID <- as.character(meta$LAB_ID)

# plot individual PCA
#pdf(file='/home/tyler/Dropbox/research/jay/mosaic/popgen/pca/plots/mosaic_fsj_individual_C_minmaf2perc.pdf',width=8,height=8)
i = 1
while (i < 7) {
        j = i+1
        plot(x=eig.c$vectors[,i], y=eig.c$vectors[,j], xlab=paste0("PC",i,", ",var.c[i],"%"), ylab=paste0("PC",j,", ",var.c[j],"%"), type="n")
        text(x=eig.c$vectors[,i],y=eig.c$vectors[,j], labels = meta$LAB_ID[1:28], cex=0.6)
        i = i+2
}
#dev.off()

#pdf(file='/home/tyler/Dropbox/research/jay/mosaic/popgen/pca/plots/mosaic_fsj_C_minmaf2perc_pca_variance_explained.pdf',width=7,height=7)
n = length(eig.c$vector[,1])
for (i in 0:2) {
        barplot(var.c,ylab="% variance explained", xlab="PCs", names.arg=1:n,col=c(rep("gray",i*2),rep("plum4",2),rep("gray",n-(2*(i+1)))))
}
#dev.off()

## PCA of Wellfield C population (5 percent minimum MAF)

covar.c5 <- as.matrix(read.table('fsj_mosaic_biallelic_snps_main_autosomes_qc_C_minmaf5perc.covar',head=FALSE))
eig.c5 <- eigen(covar.c5)
var.c5 <- round((eig.c5$values/sum(eig.c5$values))*100, digits=2)

meta <- read.table('/home/tyler/Dropbox/research/jay/mosaic/metadata/M4_sequenced_FSJsamples_metadata.txt',head=TRUE,sep="\t")
meta$LAB_ID <- as.character(meta$LAB_ID)

# plot individual PCA
#pdf(file='/home/tyler/Dropbox/research/jay/mosaic/popgen/pca/plots/mosaic_fsj_individual_C_minmaf5perc.pdf',width=8,height=8)
i = 1
while (i < 7) {
        j = i+1
        plot(x=eig.c5$vectors[,i], y=eig.c5$vectors[,j], xlab=paste0("PC",i,", ",var.c5[i],"%"), ylab=paste0("PC",j,", ",var.c5[j],"%"), type="n")
        text(x=eig.c5$vectors[,i],y=eig.c5$vectors[,j], labels = meta$LAB_ID[1:28], cex=0.6)
        i = i+2
}
#dev.off()

#pdf(file='/home/tyler/Dropbox/research/jay/mosaic/popgen/pca/plots/mosaic_fsj_C_minmaf5perc_pca_variance_explained.pdf',width=7,height=7)
n = length(eig.c5$vector[,1])
for (i in 0:2) {
        barplot(var.c5,ylab="% variance explained", xlab="PCs", names.arg=1:n,col=c(rep("gray",i*2),rep("plum4",2),rep("gray",n-(2*(i+1)))))
}
#dev.off()

## Admixture

R

meta <- read.table('/home/tyler/Dropbox/research/jay/mosaic/metadata/M4_sequenced_FSJsamples_metadata.txt',head=TRUE,sep="\t")
meta$LAB_ID <- as.character(meta$LAB_ID)
meta$type <- as.character(meta$type)

fprefix='fsj_mosaic_biallelic_snps_main_autosomes_qc'
kn = 14
niter = 3
groups <- meta$type

cx = length(which(groups == "C"))
ex = cx + length(which(groups == "E"))
ix = ex + length(which(groups == "I"))
m4x = ix + length(which(groups == "M4"))
tx = m4x + length(which(groups == "T"))

qcols = c('gold2', 'violetred2', 'turquoise2', 'tomato2', 'steelblue2', 'springgreen4', 'red4', 'navy', 'violetred', 'pink', 'lavender', 'salmon2', 'springgreen1', 'darkslategrey')

#pdf(file='/home/tyler/Dropbox/research/jay/mosaic/popgen/admix/plots/fsj_mosaic_biallelic_snps_main_autosomes_qc_admixture.pdf',width=10,height=7)

for (k in 2:kn) {
	par(mfrow=c(3,1))
	for (i in 1:niter) {
		# read in admixture proportions
		df = read.table(paste0(fprefix,"_k",k,"_iter",i,".qopt"),head=FALSE)
		admixp.mat <- t(as.matrix(df))

		# make barplot
		par(mar=c(5.1,5.7,4.1,2.1),mgp=c(3.8,1,0))
		barplot(admixp.mat,col=qcols[1:k],space=0,xlab="",ylab="Ancestry proportion", main=paste0("K= ",k), axisnames=TRUE, cex.lab=1.8, cex.axis=1.8, names.arg=meta$LAB_ID, cex.names=0.8, las=2)
		
		# add group demarcations
		lines(x<-c(cx,cx),y<-c(0,1),col="grey100",lwd=2, lty=1)
		lines(x<-c(ex,ex),y<-c(0,1),col="grey100",lwd=2, lty=1)
		lines(x<-c(ix,ix),y<-c(0,1),col="grey100",lwd=2, lty=1)
		lines(x<-c(m4x,m4x),y<-c(0,1),col="grey100",lwd=2, lty=1)
		lines(x<-c(tx,tx),y<-c(0,1),col="grey100",lwd=2, lty=1)
	}
}
#dev.off()

# plot all iterations for K of 3,6,9,10,14
outprefix='/home/tyler/Dropbox/research/jay/mosaic/popgen/admix/plots/fsj_mosaic_biallelic_snps_main_autosomes_qc_k'
niter = 20
for (k in c(3,6,9,10,14)) {
	pdf(file=paste0(outprefix,k,".pdf"))
	par(mfrow=c(3,1))
	for (i in 1:niter) {
		# read in admixture proportions
		df = read.table(paste0(fprefix,"_k",k,"_iter",i,".qopt"),head=FALSE)
		admixp.mat <- t(as.matrix(df))

		# make barplot
		par(mar=c(5.1,5.7,4.1,2.1),mgp=c(3.8,1,0))
		barplot(admixp.mat,col=qcols[1:k],space=0,xlab="",ylab="Ancestry proportion", main=paste0("K= ",k), axisnames=TRUE, cex.lab=1.8, cex.axis=1.8, names.arg=meta$LAB_ID, cex.names=0.6, las=2)
		
		# add group demarcations
		lines(x<-c(cx,cx),y<-c(0,1),col="grey100",lwd=2, lty=1)
		lines(x<-c(ex,ex),y<-c(0,1),col="grey100",lwd=2, lty=1)
		lines(x<-c(ix,ix),y<-c(0,1),col="grey100",lwd=2, lty=1)
		lines(x<-c(m4x,m4x),y<-c(0,1),col="grey100",lwd=2, lty=1)
		lines(x<-c(tx,tx),y<-c(0,1),col="grey100",lwd=2, lty=1)
	}
	dev.off()
}

# Determine optimal K

icer_workdir='/mnt/ufs18/rs-012/Fitz_Lab/projects/mosaic/popgen/admix'

Collect likelihoods for different admixture runs
$ echo "$(printf '\tK%s' {1..16} | sed 's/^\t//')" >> fsj_mosaic_biallelic_snps_main_autosomes_qc_likes.txt
$ for i in {1..20}; do lkstr=""; for K in {1..16}; do lk=$(grep "best like=" fsj_mosaic_biallelic_snps_main_autosomes_qc_k${K}_iter${i}.log | cut -f2 -d '=' | perl -ne 'print "$1\n" if ($_ =~ /^(\S+)/)'); lkstr+=" ${lk}"; done; lkstr=$(echo "$lkstr" | sed 's/^ //' | sed 's/ /\t/g'); printf "%s\n" "$lkstr" >> fsj_mosaic_biallelic_snps_main_autosomes_qc_likes.txt; done;

Use Evanno 2005 delta K method to find best K

R

lk <- read.table('/home/tyler/Dropbox/research/jay/mosaic/popgen/admix/fsj_mosaic_biallelic_snps_main_autosomes_qc_likes.txt',head=TRUE)
nk <- c(1:16)
lk.mean <- sapply(1:ncol(lk),function(x,df){mean(df[,x])},df=lk)
lk.sd <- sapply(1:ncol(lk),function(x,df){sd(df[,x])},df=lk) # mean likelihoods
lk.delta <- sapply(2:(ncol(lk)-1),function(i,df){mean(abs(df[,i+1] - 2*lk[,i] + lk[,i-1]))/sd(lk[,i])},df=lk)

# plot mean
pdf(file='/home/tyler/Dropbox/research/jay/mosaic/popgen/admix/plots/k_fit.pdf')
plot(x=nk,y=lk.mean, ylab="Mean log likelihood", xlab="K") # plot means
arrows(nk,lk.mean-lk.sd,nk,lk.mean+lk.sd,code=3,length=0.06,angle=90) # error bars

# plot delta K
plot(x=2:(ncol(lk)-1), y=lk.delta,type="b", xlab="K", ylab="Delta K")
dev.off()

## Tree

fsj_mosaic_biallelic_snps_main_autosomes_qc_all.dist distances are -log(1-raw_p_dist) transformed.
To transform distances to raw p-distances, raw_p = 1 - exp(-1*transformed_p)

icer_workdir='/mnt/research/Fitz_Lab/projects/mosaic/popgen/tree'

# extract out full dataset tree
$ head -n1 fsj_mosaic_biallelic_snps_main_autosomes_qc_all_boot.nwk > fsj_mosaic_biallelic_snps_main_autosomes_qc_all.nwk

# extract out bootstrap trees (10k block bootstraps)
$ tail -n +2 fsj_mosaic_biallelic_snps_main_autosomes_qc_all_boot.nwk | awk 'NF' > fsj_mosaic_biallelic_snps_main_autosomes_qc_all.boot.nwk

# add boostrap suppor to main NJ tree
$ raxml-ng --support --tree fsj_mosaic_biallelic_snps_main_autosomes_qc_all.nwk --bs-trees fsj_mosaic_biallelic_snps_main_autosomes_qc_all.boot.nwk --prefix fsj_mosaic_biallelic_snps_main_autosomes_qc_all

# plot tree with bootstrap support

R

library(phytools)

njtree <- read.tree('/home/tyler/Dropbox/research/jay/mosaic/popgen/tree/fsj_mosaic_biallelic_snps_main_autosomes_qc_all.raxml.support')

meta <- read.table('/home/tyler/Dropbox/research/jay/mosaic/metadata/M4_sequenced_FSJsamples_metadata.txt',head=TRUE,sep="\t")
meta$popcode <- popletters(meta)
meta$popcol <- popcolor(meta)
#meta$letter_code <- pointletters(meta)
#meta$grpcol <- pntcol(meta)
meta$grpcol <- sitecol(meta)

#tipcol <- as.character(meta$type[match(njtree$tip.label, meta$LAB_ID)])
#tipcol <- pntcol(tipcol)
#tipcol <- as.character(meta$grpcol[match(njtree$tip.label, meta$LAB_ID)])
tipcol <- as.character(meta$popcol[match(njtree$tip.label, meta$LAB_ID)])

#site <- as.character(meta$site[match(njtree$tip.label, meta$LAB_ID)])
#njtree$tip.label = paste0(njtree$tip.label,", ",site)
#njtree$tip.label = gsub("^I", "U", njtree$tip.label) # change "I" to "U"
pop <- as.character(meta$pop[match(njtree$tip.label, meta$LAB_ID)])
pop.abr <- as.character(meta$popcode[match(njtree$tip.label, meta$LAB_ID)])
njtree$tip.label <- paste0(njtree$tip.label, "-", pop.abr)

node.label.new <- as.character(as.numeric(njtree$node.label)/100)
node.label.new[is.na(node.label.new)] <- ""
njtree$node.label <- node.label.new

# plot genome-wide trees a few different ways
# see ?plot.phylo for options
#pdf(file='/home/tyler/Dropbox/research/jay/mosaic/popgen/tree/plot/mosaic_fsj_nj_tree_colors2.pdf')
#pdf(file='/home/tyler/Dropbox/research/jay/mosaic/popgen/tree/plot/mosaic_fsj_nj_tree_colors2_print.pdf')
pdf(file='/home/tyler/Dropbox/research/jay/mosaic/popgen/tree/plot/mosaic_fsj_nj_tree_pop_labels_print.pdf')
#plot(njtree,type="phylogram",lab4ut="axial",no.margin=TRUE,cex=0.4,align.tip.label=FALSE, show.node.label=TRUE, tip.color=tipcol, underscore=TRUE)
#plot(njtree,type="radial",lab4ut="axial",no.margin=TRUE,cex=0.4,align.tip.label=FALSE, show.node.label=TRUE, tip.color=tipcol, underscore=TRUE)
#plot(njtree,type="unrooted",lab4ut="axial",no.margin=TRUE,cex=0.4,align.tip.label=FALSE, show.node.label=FALSE, tip.color=tipcol)
plot(njtree,type="unrooted",lab4ut="axial",no.margin=TRUE,cex=0.8,align.tip.label=FALSE, show.node.label=FALSE, tip.color=tipcol, underscore=TRUE)
#dev.off()

## Distance matrix

library(gplots) # heatmap.2()
library(viridis)

dist.mat <- as.matrix(read.table('~/Dropbox/research/jay/mosaic/popgen/tree/fsj_mosaic_biallelic_snps_main_autosomes_qc_all.dist.matrix',head=FALSE)) # -log(1-raw_p_dist)
dist.raw <- 1 - exp(-1*dist.mat) # raw p-distance

meta$pop.names <- popnames(meta)
colnames(dist.raw) <- paste0(meta$LAB_ID," ",meta$pop.names)
rownames(dist.raw) <- paste0(meta$LAB_ID," ",meta$pop.names)

# Ordered using Ward's minimum variance clustering of euclidean distances between rows (i.e. individuals). Row/Column ordering by row means.
pdf('/home/tyler/Dropbox/research/jay/mosaic/popgen/tree/plot/pairwise_dist_ward.pdf', width=10, height=10)

heatmap.2(dist.raw, symm = TRUE, breaks = 40, trace="none", dendrogram="column", Rowv=TRUE, colCol=meta$popcol, colRow=meta$popcol, col=viridis, margins=c(7,7), cexRow=0.55, cexCol=0.55, offsetRow=-0.5, offsetCol=-0.5, key.title=NA, keysize=1, hclustfun = function(x) hclust(x,method="ward.D"), distfun=function(x)dist(x,method="euclidean"))

dev.off()


## Relatedness

R
library(gplots) # heatmap.2()
library(viridis) # plasma colors

df <- read.table('/home/tyler/Dropbox/research/jay/mosaic/popgen/relatedness/fsj_mosaic_biallelic_snps_main_autosomes_qc_relatedness.txt',head=TRUE)
meta <- read.table('/home/tyler/Dropbox/research/jay/mosaic/metadata/M4_sequenced_FSJsamples_metadata.txt',head=TRUE,sep="\t")
meta$pop.names <- popnames(meta)
meta$popcol <- popcolor(meta)

# convert pairwise comparisons into a matrix
n = 87
rmat <- matrix(ncol=n, nrow=n)

for (i in 1:n) {
	iidx = i-1
	for (j in 1:n) {
		jidx = j-1
		if (i == j) {
			rmat[i,j] = NA
		} else if (!is.na(rmat[j,i])) {
			rmat[i,j] = rmat[j,i]
			#if (j < i) rmat[i,j] = NA # this makes half matrix
		} else {
			rmat[i,j] = df$rab[which(df$a == iidx & df$b == jidx)]
		}
	}
}

# make output matrix
#colnames(rmat) <- paste0(meta$LAB_ID,":",gsub(" ", "_", meta$pop.names))
#rownames(rmat) <- paste0(meta$LAB_ID,":",gsub(" ", "_", meta$pop.names))
#write.table(rmat,file='/home/tyler/Dropbox/research/jay/mosaic/popgen/relatedness/fsj_mosaic_biallelic_snps_main_autosomes_qc_relatedness_matrix.txt',col.names=TRUE,row.names=TRUE,quote=FALSE,sep="\t")
#write.table(rmat,file='/home/tyler/Dropbox/research/jay/mosaic/popgen/relatedness/#fsj_mosaic_biallelic_snps_main_autosomes_qc_relatedness_matrix.nonames.txt',col.names=FALSE,row.names=FALSE,quote=FALSE,sep="\t")

colnames(rmat) <- paste0(meta$LAB_ID," ",meta$pop.names)
rownames(rmat) <- paste0(meta$LAB_ID," ",meta$pop.names)

pdf(file='/home/tyler/Dropbox/research/jay/mosaic/popgen/relatedness/plots/pairwise_relate_matrix_Ward_clustering.pdf',width=10,height=10)

heatmap.2(rmat, symm = TRUE, breaks = 40, trace="none", dendrogram="column", Rowv=TRUE, colCol=meta$popcol, colRow=meta$popcol, col=viridis, margins=c(7,7), cexRow=0.55, cexCol=0.55, offsetRow=-0.5, offsetCol=-0.5, key.title=NA, keysize=1, hclustfun = function(x) hclust(x,method="ward.D"), distfun=function(x)dist(x,method="euclidean"))

dev.off()

#pdf(file='/home/tyler/Dropbox/research/jay/mosaic/popgen/relatedness/plots/pairwise_relate_matrix_Ward_clustering_modkey.pdf',width=10,height=10)
#heatmap.2(rmat, symm = TRUE, breaks = 40, trace="none", dendrogram="column", Rowv=TRUE, colCol=meta$popcol, colRow=meta$popcol, col=viridis, margins=c(7,7), cexRow=0.55, cexCol=0.55, offsetRow=-0.5, offsetCol=-0.5, key.title=NA, keysize=1, hclustfun = function(x) hclust(x,method="ward.D"), distfun=function(x)dist(x,method="euclidean"), density.info='none') # version without key density
#dev.off()


pdf(file='/home/tyler/Dropbox/research/jay/mosaic/popgen/relatedness/plots/pairwise_relate_matrix_complete_linkage_clustering.pdf',width=10,height=10)

heatmap.2(rmat, symm = TRUE, breaks = 40, trace="none", dendrogram="column", Rowv=TRUE, colCol=meta$popcol, colRow=meta$popcol, col=viridis, margins=c(7,7), cexRow=0.55, cexCol=0.55, offsetRow=-0.5, offsetCol=-0.5, key.title=NA, keysize=1, hclustfun = function(x) hclust(x,method="complete"), distfun=function(x)dist(x,method="euclidean"))

dev.off()

# make sorted version of r matrix
meta.sort <- meta[c(which(meta$pop == "Contemporary"), which(meta$pop == "Resident"), which(meta$pop == "SITE_1"),
which(meta$pop == "SITE_12"), which(meta$pop == "SITE_13"), which(meta$pop == "SITE_18"), which(meta$pop == "TEXACO"), 
which(meta$pop == "Brigman"), which(meta$pop == "Duette_headwaters"), which(meta$pop == "Golden_Aster_Scrub"), 
which(meta$pop == "W.Balm"), which(meta$pop == "Sun_City")),]

meta.sort$popcol <- popcolor(meta.sort)
meta.sort$pop.names <- popnames(meta.sort)

df$a.ind <- meta$LAB_ID[df$a+1]
df$b.ind <- meta$LAB_ID[df$b+1]
rmat.sort <- matrix(ncol=n, nrow=n)

for (i in 1:n) {
	id.a = meta.sort$LAB_ID[i]
	for (j in 1:n) {
		id.b = meta.sort$LAB_ID[j]
		if (i == j) {
			rmat.sort[i,j] = NA
			next
		}
		rmat.sort[i,j] = df$rab[which((df$a.ind == id.a & df$b.ind == id.b) | (df$a.ind == id.b & df$b.ind == id.a))]
	}
}

#rmat.sort[which(upper.tri(rmat.sort) == FALSE)] = NA
#colnames(rmat.sort) = paste0(meta.sort$LAB_ID,"_",as.character(meta.sort$site))
#rownames(rmat.sort) = paste0(meta.sort$LAB_ID,"_",as.character(meta.sort$site))

rmat.sort <- apply(rmat.sort,2,rev) # reverse matrix for consisting plotting
colnames(rmat.sort) = paste0(meta.sort$LAB_ID," ",meta.sort$pop.names)
rownames(rmat.sort)= (paste0(meta.sort$LAB_ID," ",meta.sort$pop.names))[n:1]

# plot updated heatmap (reassigned "I" individuals)
pdf(file='/home/tyler/Dropbox/research/jay/mosaic/popgen/relatedness/plots/pairwise_relate_matrix_pop_order.pdf',width=10,height=10)

heatmap.2(rmat.sort, breaks=20, Rowv=FALSE,Colv=FALSE,dendrogram=c("none"),keysize=1,trace="none", margins=c(7,7),col=plasma,cexRow=0.55, cexCol=0.55, offsetRow=-0.5, offsetCol=-0.5, colCol=meta.sort$popcol, colRow=meta.sort$popcol[n:1], colsep=c(86,85,83,80,74,71,70,51,49,44,28), rowsep=c(1,2,4,7,13,16,17,36,38,43,59),sepcolor="white",sepwidth=c(0.01,0.01),key.title=NA)

dev.off()

pdf(file='/home/tyler/Dropbox/research/jay/mosaic/popgen/relatedness/plots/pairwise_relate_matrix_pop_order_viridis.pdf',width=10,height=10)

heatmap.2(rmat.sort, breaks=20, Rowv=FALSE,Colv=FALSE,dendrogram=c("none"),keysize=1,trace="none", margins=c(7,7),col=viridis,cexRow=0.55, cexCol=0.55, offsetRow=-0.5, offsetCol=-0.5, colCol=meta.sort$popcol, colRow=meta.sort$popcol[n:1], colsep=c(86,85,83,80,74,71,70,51,49,44,28), rowsep=c(1,2,4,7,13,16,17,36,38,43,59),sepcolor="white",sepwidth=c(0.01,0.01),key.title=NA)

dev.off()

# distribution of inbreeding within pops
ew = grep("^E_\\d+_Wellfield", colnames(rmat),perl=TRUE)
cw = grep("^C_\\d+_Wellfield", colnames(rmat),perl=TRUE)
s1 = grep("^T_\\d+_SITE_1$", colnames(rmat),perl=TRUE)
s12 = grep("^T_\\d+_SITE_12", colnames(rmat),perl=TRUE)
s13 = grep("^T_\\d+_SITE_13", colnames(rmat),perl=TRUE)
#s18 = grep("^T_\\d+_SITE_18", colnames(rmat),perl=TRUE)
tx = grep("^T_\\d+_TEXACO", colnames(rmat),perl=TRUE)
m4g = grep("^M4_\\d+_Golden", colnames(rmat),perl=TRUE)
m4b = grep("^M4_\\d+_Brigman", colnames(rmat),perl=TRUE)
#m4a = grep("^M4_\\d+_W.Balm", colnames(rmat),perl=TRUE)
m4d = grep("^M4_\\d+_Duette", colnames(rmat),perl=TRUE)
#m4s = grep("^M4_\\d+_Sun", colnames(rmat),perl=TRUE)
imis = grep("^I_\\d+_missing", colnames(rmat),perl=TRUE)

ewr = c(rmat[ew,ew])
cwr = c(rmat[cw,cw])
s1r = c(rmat[s1,s1])
s12r = c(rmat[s12,s12])
s13r = c(rmat[s13,s13])
txr = c(rmat[tx,tx])
m4gr = c(rmat[m4g,m4g])
m4br = c(rmat[m4b,m4b])
m4dr = c(rmat[m4d,m4d])
imisr = c(rmat[imis,imis])

popr <- NULL
popr <- rbind(popr, data.frame(pop=rep("E_Wellfield",length(ewr)), r=ewr))
popr <- rbind(popr, data.frame(pop=rep("C_Wellfield",length(cwr)), r=cwr))
popr <- rbind(popr, data.frame(pop=rep("S1",length(s1r)), r=s1r))
popr <- rbind(popr, data.frame(pop=rep("S12",length(s12r)), r=s12r))
popr <- rbind(popr, data.frame(pop=rep("S13",length(s13r)), r=s13r))
popr <- rbind(popr, data.frame(pop=rep("TEXACO",length(txr)), r=txr))
popr <- rbind(popr, data.frame(pop=rep("Golden_Aster",length(m4gr)), r=m4gr))
popr <- rbind(popr, data.frame(pop=rep("Brigman",length(m4br)), r=m4br))
popr <- rbind(popr, data.frame(pop=rep("Duette",length(m4dr)), r=m4dr))
popr <- rbind(popr, data.frame(pop=rep("immigrant",length(imisr)), r=imisr))
popr <- popr[which(!is.na(popr$r)),]

# calculate average relatedness among individuals per groups
rsummary <- NULL
rsummary <- rbind(rsummary,data.frame(comp="C vs C", mean=mean(df$rab[which(df$a >= 0 & df$a < 28 & df$b >= 0 & df$b < 28)]), sd=sd(df$rab[which(df$a >= 0 & df$a < 28 & df$b >= 0 & df$b < 28)])))
rsummary <- rbind(rsummary,data.frame(comp="C vs E", mean=mean(df$rab[which(df$a >= 0 & df$a < 28 & df$b >= 28 & df$b < 39)]), sd=sd(df$rab[which(df$a >= 0 & df$a < 28 & df$b >= 28 & df$b < 39)])))
rsummary <- rbind(rsummary,data.frame(comp="C vs I", mean=mean(df$rab[which(df$a >= 0 & df$a < 28 & df$b >= 39 & df$b < 45)]), sd=sd(df$rab[which(df$a >= 0 & df$a < 28 & df$b >= 39 & df$b < 45)])))
rsummary <- rbind(rsummary,data.frame(comp="C vs M4", mean=mean(df$rab[which(df$a >= 0 & df$a < 28 & df$b >= 45 & df$b < 58)]), sd=sd(df$rab[which(df$a >= 0 & df$a < 28 & df$b >= 45 & df$b < 58)])))
rsummary <- rbind(rsummary,data.frame(comp="C vs T", mean=mean(df$rab[which(df$a >= 0 & df$a < 28 & df$b >= 58 & df$b < 87)]), sd=sd(df$rab[which(df$a >= 0 & df$a < 28 & df$b >= 58 & df$b < 87)])))
rsummary <- rbind(rsummary,data.frame(comp="E vs E", mean=mean(df$rab[which(df$a >= 28 & df$a < 39 & df$b >= 28 & df$b < 39)]), sd=sd(df$rab[which(df$a >= 28 & df$a < 39 & df$b >= 28 & df$b < 39)])))
rsummary <- rbind(rsummary,data.frame(comp="E vs I", mean=mean(df$rab[which(df$a >= 28 & df$a < 39 & df$b >= 39 & df$b < 45)]), sd=sd(df$rab[which(df$a >= 28 & df$a < 39 & df$b >= 39 & df$b < 45)])))
rsummary <- rbind(rsummary,data.frame(comp="E vs M4", mean=mean(df$rab[which(df$a >= 28 & df$a < 39 & df$b >= 45 & df$b < 58)]), sd=sd(df$rab[which(df$a >= 28 & df$a < 39 & df$b >= 45 & df$b < 58)])))
rsummary <- rbind(rsummary,data.frame(comp="E vs T", mean=mean(df$rab[which(df$a >= 28 & df$a < 39 & df$b >= 58 & df$b < 87)]), sd=sd(df$rab[which(df$a >= 28 & df$a < 39 & df$b >= 58 & df$b < 87)])))
rsummary <- rbind(rsummary,data.frame(comp="I vs I", mean=mean(df$rab[which(df$a >= 39 & df$a < 45 & df$b >= 39 & df$b < 45)]), sd=sd(df$rab[which(df$a >= 39 & df$a < 45 & df$b >= 39 & df$b < 45)])))
rsummary <- rbind(rsummary,data.frame(comp="I vs M4", mean=mean(df$rab[which(df$a >= 39 & df$a < 45 & df$b >= 45 & df$b < 58)]), sd=sd(df$rab[which(df$a >= 39 & df$a < 45 & df$b >= 45 & df$b < 58)])))
rsummary <- rbind(rsummary,data.frame(comp="I vs T", mean=mean(df$rab[which(df$a >= 39 & df$a < 45 & df$b >= 58 & df$b < 87)]), sd=sd(df$rab[which(df$a >= 39 & df$a < 45 & df$b >= 58 & df$b < 87)])))
rsummary <- rbind(rsummary,data.frame(comp="M4 vs M4", mean=mean(df$rab[which(df$a >= 45 & df$a < 58 & df$b >= 45 & df$b < 58)]), sd=sd(df$rab[which(df$a >= 45 & df$a < 58 & df$b >= 45 & df$b < 58)])))
rsummary <- rbind(rsummary,data.frame(comp="M4 vs T", mean=mean(df$rab[which(df$a >= 45 & df$a < 58 & df$b >= 58 & df$b < 87)]), sd=sd(df$rab[which(df$a >= 45 & df$a < 58 & df$b >= 58 & df$b < 87)])))
rsummary <- rbind(rsummary,data.frame(comp="T vs T", mean=mean(df$rab[which(df$a >= 58 & df$a < 87 & df$b >= 58 & df$b < 87)]), sd=sd(df$rab[which(df$a >= 58 & df$a < 87 & df$b >= 58 & df$b < 87)])))

nlab=NULL
for (id in unique(popr$pop)) { n=length(which(popr$pop==id)); nlab=c(nlab,paste0("(",n,")")) }

# plot relatedness info

# plot heatmap
#pdf(file='/home/tyler/Dropbox/research/jay/mosaic/popgen/relatedness/plots/fsj_mosaic_biallelic_snps_main_autosomes_qc_relatedness.pdf')
heatmap.2(rmat,Rowv=FALSE,Colv=FALSE,dendrogram=c("none"),keysize=1,density.info="none",trace="none",revC=TRUE,margins=c(9,9),rowsep=c(29,42,48,59),colsep=c(28,39,45,58),sepcolor="white",col=plasma, cexRow=0.3, cexCol=0.3)

# plot sorted heatmap
#pdf(file='/home/tyler/Dropbox/research/jay/mosaic/popgen/relatedness/plots/fsj_mosaic_biallelic_snps_main_autosomes_qc_relatedness_sorted.pdf')
pdf(file='/home/tyler/Dropbox/research/jay/mosaic/popgen/relatedness/plots/fsj_mosaic_biallelic_snps_main_autosomes_qc_relatedness_sorted_print.pdf',width=10,height=10)
#heatmap.2(rmat.sort,Rowv=FALSE,Colv=FALSE,dendrogram=c("none"),keysize=1,density.info="none",trace="none",revC=TRUE,margins=c(9,9),rowsep=c(29,42,48,59),colsep=c(28,39,45,58),sepcolor="white",col=plasma, cexRow=0.3, cexCol=0.3, colCol=meta.sort$labcol, colRow=meta.sort$labcol[87:1], labRow=rownames(rmat.sort)[87:1])
heatmap.2(rmat.sort,Rowv=FALSE,Colv=FALSE,dendrogram=c("none"),keysize=1,density.info="none",trace="none",revC=TRUE,margins=c(9,9),rowsep=c(29,42,48,59),colsep=c(28,39,45,58),sepcolor="white",col=plasma, cexRow=0.5, cexCol=0.5, colCol=meta.sort$labcol, colRow=meta.sort$labcol[87:1], labRow=rownames(rmat.sort)[87:1])
dev.off()

# mean group pairwise scatterplot
plot(x=1:nrow(rsummary), y=rsummary$mean, ylab="Pairwise relatedness (r)", xlab="", xaxt="n",ylim=c(0,0.24),pch=19,cex=1.3, cex.axis=1.2,cex.lab=1.2)
arrows(1:nrow(rsummary),rsummary$mean-rsummary$sd,1:nrow(rsummary),rsummary$mean+rsummary$sd,code=3,length=0.06,angle=90,lwd=1.2)
axis(side=1, at=1:nrow(rsummary), labels=as.character(rsummary$comp), tick=FALSE, las=2, cex=1.2)

#dev.off()

# plot population boxplots
pdf(file='/home/tyler/Dropbox/research/jay/mosaic/popgen/relatedness/plots/fsj_mosaic_biallelic_snps_main_autosomes_qc_relatedness_pop_boxplot.pdf',width=11,height=7)
plot(popr$r ~ popr$pop, xlab="Population", ylab="Pairwise relatedness (r)", col="grey",cex.lab=1.2, cex.axis=1.2, xaxt="n",ylim=c(0,0.7))
axis(side=1, at=1:length(unique(popr$pop)), labels=as.character(unique(popr$pop)), tick=TRUE, cex.axis=0.8)
axis(side=1, at=1:length(unique(popr$pop)), labels=nlab, tick=FALSE, cex.axis=0.8, padj=1.5)
#dev.off()

## ranked relatedness matrix plot

R

library(plot.matrix)
library(scales)

df <- read.table('/home/tyler/Dropbox/research/jay/mosaic/popgen/relatedness/fsj_mosaic_biallelic_snps_main_autosomes_qc_relatedness.txt',head=TRUE)
meta <- read.table('/home/tyler/Dropbox/research/jay/mosaic/metadata/M4_sequenced_FSJsamples_metadata.txt',head=TRUE,sep="\t")
meta$LAB_ID = as.character(meta$LAB_ID)
meta$popnice <- popnames(meta)

#meta$type.loc = paste0(meta$type,"_",meta$site)
#meta$id.full = paste0(meta$LAB_ID,"_",meta$site)
#meta$id.full = paste0(meta$LAB_ID,"_",meta$pop)
meta$id.full = paste0(meta$LAB_ID,":",meta$popnice)

# assign colors
meta$id.col <- popcolor(meta)

# assign code
meta$id.code <- replace(meta$pop, which(meta$pop == "Contemporary"), "1")
meta$id.code <- replace(meta$id.code, which(meta$id.code == "Resident"), "2")
meta$id.code <- replace(meta$id.code, which(meta$id.code == "SITE_1"), "3")
meta$id.code <- replace(meta$id.code, which(meta$id.code == "SITE_12"), "4")
meta$id.code <- replace(meta$id.code, which(meta$id.code == "SITE_13"), "5")
meta$id.code <- replace(meta$id.code, which(meta$id.code == "SITE_18"), "6")
meta$id.code <- replace(meta$id.code, which(meta$id.code == "TEXACO"), "7")
meta$id.code <- replace(meta$id.code, which(meta$id.code == "Brigman"), "8")
meta$id.code <- replace(meta$id.code, which(meta$id.code == "Duette_headwaters"), "9")
meta$id.code <- replace(meta$id.code, which(meta$id.code == "Golden_Aster_Scrub"), "10")
meta$id.code <- replace(meta$id.code, which(meta$id.code == "Sun_City"), "11")
meta$id.code <- replace(meta$id.code, which(meta$id.code == "W.Balm"), "12")
meta$id.code <- as.numeric(meta$id.code)

colvec <- c(sapply(1:12,function(x,df){meta$id.col[which(meta$id.code == x)[1]]},df=meta),"gray90")

#df$a.typeloc <- meta$type.loc[df$a+1]
#df$b.typeloc <- meta$type.loc[df$b+1]
df$a.pop <- meta$pop[df$a+1]
df$b.pop <- meta$pop[df$b+1]
df$a.id.full <- meta$id.full[df$a+1]
df$b.id.full <- meta$id.full[df$b+1]

# set up matrices for plotting

codemat <- matrix(nrow=87,ncol=87)
valmat <- matrix(nrow=87,ncol=87)
colmat <- matrix(nrow=87, ncol=87)
indmat <- matrix(nrow=87, ncol=87)
rcutoff = 0.004222888 # average relatedness between translocated and Residents 
for (idx in 0:86) {
	i = idx+1
	df.sub <- df[which(df$a == idx | df$b == idx),c(1,2,13,34:37)]
	df.sub.ord <- df.sub[order(-df.sub$rab),]
	namevec <- ifelse(df.sub.ord$a == idx, df.sub.ord$b.pop, df.sub.ord$a.pop)
	indvec <- ifelse(df.sub.ord$a == idx, df.sub.ord$b.id.full, df.sub.ord$a.id.full)
	codevec <- sapply(namevec,function(x,df){df$id.code[which(df$pop == x)[1]]},USE.NAMES=FALSE, df=meta)
	colarr <- sapply(namevec,function(x,df){df$id.col[which(df$pop == x)[1]]},USE.NAMES=FALSE, df=meta)
	# mask-code comparisons with rab < cutoff
	codevec[which(df.sub.ord$rab < rcutoff)] <- 13
	codemat[i,] <- c(meta$id.code[i], codevec)
	colarr[which(df.sub.ord$rab < rcutoff)] <- "gray90"
	colmat[i,] <- c(meta$id.col[i], colarr)
	valmat[i,] <- c(1,df.sub.ord$rab)
	indmat[i,] <- c(meta$id.full[i], indvec)
}

# write ranked relatedness matrix

#write.table(indmat, file='/home/tyler/Dropbox/research/jay/mosaic/popgen/relatedness/fsj_mosaic_biallelic_snps_main_autosomes_qc_relatedness_ranked.txt',col.names=FALSE, row.names=FALSE, sep="\t", quote=FALSE)
#rownames(valmat) <- meta$id.full
#write.table(valmat, file='/home/tyler/Dropbox/research/jay/mosaic/popgen/relatedness/fsj_mosaic_biallelic_snps_main_autosomes_qc_relatedness_ranked_values.txt', col.names=FALSE, row.names=TRUE, sep="\t", quote=FALSE)

# group rows of matrices by population

popidx <- c(grep("Contemporary",indmat[,1]), grep("Resident",indmat[,1]), grep("Site 1$",indmat[,1]), grep("Site 12",indmat[,1]), grep("Site 13",indmat[,1]), grep("Site 18",indmat[,1]), grep("Texaco",indmat[,1]), grep("Brigman",indmat[,1]), grep("Duette headwaters",indmat[,1]), grep("Golden Aster Scrub",indmat[,1]), grep("Sun City",indmat[,1]), grep("W. Balm",indmat[,1]))

codemat <- codemat[popidx,]
valmat <- valmat[popidx,]
colmat <- colmat[popidx,]
indmat <- indmat[popidx,]

# make plot legend

groups <- unique(meta$pop)
group.col <- sapply(groups,function(x,df){df$id.col[which(df$pop == x)[1]]},USE.NAMES=FALSE,df=meta)

#pdf(file='/home/tyler/Dropbox/research/jay/mosaic/popgen/relatedness/plots/fsj_mosaic_biallelic_snps_main_autosomes_qc_relatedness_ranked.pdf')
#pdf(file='/home/tyler/Dropbox/research/jay/mosaic/popgen/relatedness/plots/fsj_mosaic_biallelic_snps_main_autosomes_qc_relatedness_ranked_colors2.pdf')
pdf(file='/home/tyler/Dropbox/research/jay/mosaic/popgen/relatedness/plots/fsj_mosaic_biallelic_snps_main_autosomes_qc_relatedness_ranked_popcolors.pdf')

plot.new()
legend('topleft',legend=groups, fill=group.col, bty='n', cex=1.8)

# plot all individuals - solid colors

plot(codemat,col=colvec,breaks=seq(from=1,to=15,by=1), key=NULL, axis.col=list(side=1, labels=FALSE, tick=FALSE), axis.row=list(side=2, labels=FALSE, tick=FALSE), ylab="", xlab="", main=NA, polygon.cell=list(lwd=0.2,lty=1,col=alpha("gray80",0.3))) # without indicating relatedness intensity
title(ylab="Individual",line=0.5,cex.lab=1.2)
title(xlab="Ranked pairwise relatedness",line=0.5,cex.lab=1.2)

abline(v=1.45,col="white",lwd=3) # add break line

# plot all individuals with relatedness intensity mask

plot(codemat,col="white", key=NULL, axis.col=list(side=1, labels=FALSE, tick=FALSE), axis.row=list(side=2, labels=FALSE, tick=FALSE), ylab="", xlab="", main=NA, polygon.cell=list(border=NA)) # with relatedness intensity
title(ylab="Individual",line=0.5,cex.lab=1.2)
title(xlab="Ranked pairwise relatedness",line=0.5,cex.lab=1.2)

yt=nrow(valmat)+1.5
for (i in 1:nrow(valmat)) {
	yt = yt-1
	yb = yt-1
	xl=-0.5
	for (j in 1:ncol(valmat)) {
		xl = xl+1
		xr = xl+1
		#rect(xleft=xl, xright=xr, ybottom=yb, ytop=yt, border=NA, col=alpha("black",0.7*(1-valmat[i,j])))
		#rect(xleft=xl, xright=xr, ybottom=yb, ytop=yt, border=NA, col=alpha("white",0.6*(1-valmat[i,j])))
		rect(xleft=xl, xright=xr, ybottom=yb, ytop=yt, border=alpha("gray80",0.3), col=alpha(colmat[i,j],2.5*valmat[i,j]))
	}
}

abline(v=1.45,col="white",lwd=3) # add break line

# plot Residents and Contemporary Wellfield individuals - solid colors

submat <- codemat[1:44,]
subval <- valmat[1:44,]

plot(submat,col=colvec,breaks=seq(from=1,to=15,by=1), key=NULL, axis.col=list(side=1, labels=FALSE, tick=FALSE), axis.row=list(side=2, labels=FALSE, tick=FALSE), ylab="", xlab="", main=NA, polygon.cell=list(lwd=0.2,lty=1,col=alpha("gray80",0.3))) # without intensity
title(ylab="Individual",line=0.5,cex.lab=1.2)
title(xlab="Ranked pairwise relatedness",line=0.5,cex.lab=1.2)

abline(v=1.45,col="white",lwd=3)

# plot Residents and Contemporary only with relatedness intensity mask

plot(submat,col="white", key=NULL, axis.col=list(side=1, labels=FALSE, tick=FALSE), axis.row=list(side=2, labels=FALSE, tick=FALSE), ylab="", xlab="", main=NA, polygon.cell=list(border=NA)) # with relatedness intensity
title(ylab="Individual",line=0.5,cex.lab=1.2)
title(xlab="Ranked pairwise relatedness",line=0.5,cex.lab=1.2)

# add intensity mask to submatrix

yt=nrow(subval)+1.5
for (i in 1:nrow(subval)) {
	yt = yt-1
	yb = yt-1
	xl=-0.5
	for (j in 1:ncol(subval)) {
		xl = xl+1
		xr = xl+1
		#rect(xleft=xl, xright=xr, ybottom=yb, ytop=yt, border=NA, col=alpha("black",0.7*(1-subval[i,j])))
		#rect(xleft=xl, xright=xr, ybottom=yb, ytop=yt, border=NA, col=alpha("white",0.6*(1-subval[i,j])))
		rect(xleft=xl, xright=xr, ybottom=yb, ytop=yt, border=alpha("gray80",0.3), col=alpha(colmat[i,j],2.5*subval[i,j]))
	}
}

abline(v=1.45,col="white",lwd=3) # add break line
#dev.off()

# make color intensity legend for submatrix

gradmat <- matrix(seq(from=1, to=0, by=-0.125),nrow=1)
gradmat.col <- matrix(rep("red",ncol(gradmat)),nrow=1)

#pdf(file='/home/tyler/Dropbox/research/jay/mosaic/popgen/relatedness/plots/fsj_mosaic_biallelic_snps_main_autosomes_qc_relatedness_ranked_colors2_scale.pdf')
plot(gradmat,col="white", key=NULL, axis.col=list(side=1, labels=FALSE, tick=FALSE), axis.row=list(side=2, labels=FALSE, tick=FALSE), ylab="", xlab="", main=NA, polygon.cell=list(border=NA)) # with relatedness intensity
title(ylab="Individual",line=0.5,cex.lab=1.2)
title(xlab="Ranked pairwise relatedness",line=0.5,cex.lab=1.2)

yt=nrow(gradmat)+1.5
for (i in 1:nrow(gradmat)) {
	yt = yt-1
	yb = yt-1
	xl=-0.5
	for (j in 1:ncol(gradmat)) {
		xl = xl+1
		xr = xl+1
		#rect(xleft=xl, xright=xr, ybottom=yb, ytop=yt, border=NA, col=alpha("black",0.7*(1-gradmat[i,j])))
		#rect(xleft=xl, xright=xr, ybottom=yb, ytop=yt, border=NA, col=alpha("white",0.6*(1-gradmat[i,j])))
		rect(xleft=xl, xright=xr, ybottom=yb, ytop=yt, border=alpha("gray80",0.3), col=alpha(gradmat.col[i,j],gradmat[i,j]))
	}
}

#dev.off()

# plot Contemporary only with relatedness demarcations

cmat <- codemat[1:28,]
cval <- valmat[1:28,]
cnames <- sapply(indmat[1:28,1],function(x){strsplit(x,":")[[1]][1]},USE.NAMES=FALSE)
ncnames <- apply(indmat,c(1,2),function(x){strsplit(x,":")[[1]][1]})
min.relate = 0.004222888

# find contemporary individual with most relatives with relatedness > 0.004222888 (average relatedness of translocated to Residents).
colmax = 0
for (i in 1:nrow(cval)) {
	tr = 0
	for (j in 1:nrow(cval)) {
		tr = tr+1
		if (cval[i,j] < min.relate) break
	}
	if (tr > colmax) colmax = tr
}

x11(width=10,height=13)
pdf(file='/home/tyler/Dropbox/research/jay/mosaic/popgen/relatedness/plots/contemporary_ranked_matrix.pdf',width=10,height=13)

plot(cmat[,1:colmax],col="white", key=NULL, axis.col=list(side=1, labels=FALSE, tick=FALSE), axis.row=list(side=2, labels=FALSE, tick=FALSE), ylab="", xlab="", main=NA, polygon.cell=list(border=NA))
#title(ylab="Individual",line=0.5,cex.lab=1.2)
title(xlab="Ranked pairwise relatedness",line=0.5,cex.lab=1.2)

# add intensity mask to submatrix
tracecol1 = "blue"
tracecol2 = "red"
tracecol3 = "black"
colscale <- 7
yt=nrow(cval)+1.5
for (i in 1:nrow(cval)) {
	yt = yt-1
	yb = yt-1
	xl=-0.5
	cutoff1 = 0
	cutoff2 = 0
	cutoff3 = 0
	for (j in 2:colmax) {
		xl = xl+1
		xr = xl+1
		rect(xleft=xl, xright=xr, ybottom=yb, ytop=yt, border=alpha("gray80",0.3), col=alpha(colmat[i,j],colscale*cval[i,j]))
		# plot demarcation lines
		if (!cutoff1 && j < ncol(cval) && cval[i,j+1] < min.relate) {
			lines(x=c(xr,xr), y=c(yb,yt), col=tracecol1, lty=2,lwd=2)
			if (i > 1) lines(x=c(xr, x.prev1),y=c(y.prev1,y.prev1), col=tracecol1, lty=2, lwd=2)
			x.prev1 = xr
			y.prev1 = yb
			cutoff1 = 1
		}
		if (!cutoff2 && j < ncol(cval) && cval[i,j+1] < 0.01) {
			lines(x=c(xr,xr+adj), y=c(yb,yt), col=tracecol2, lty=2,lwd=2)
			if (i > 1) lines(x=c(xr, x.prev2),y=c(y.prev2,y.prev2), col=tracecol2, lty=2, lwd=2)
			x.prev2 = xr
			y.prev2 = yb
			cutoff2 = 1
		}
		if (!cutoff3 && j < ncol(cval) && cval[i,j+1] < 0.0243058) {
			lines(x=c(xr,xr), y=c(yb,yt), col=tracecol3, lty=2, lwd=2)
			if (i > 1) lines(x=c(xr, x.prev3),y=c(y.prev3,y.prev3), col=tracecol3, lty=2, lwd=2)
			x.prev3 = xr
			y.prev3 = yb
			cutoff3 = 1
		}
		
		# plot individual labels
		text(x=(xl+xr)/2,y=(yb+yt)/2,labels=ncnames[i,j],col="gray50",cex=0.7,srt=-90)
	}
}

text(x=-0.5, y=(nrow(cval)):1, labels=cnames, xpd=TRUE)

dev.off()

# color intensity key for Contemporary only
cmax <- round(cmax+0.05,digits=1)
gradmat.c <- matrix(seq(from=0, to=cmax, by=0.01),nrow=1)
gradmat.c.col <- matrix(rep("black",ncol(gradmat.c)),nrow=1)

x11(width=17,height=4)
#pdf(file='/home/tyler/Dropbox/research/jay/mosaic/popgen/relatedness/plots/contemporary_ranked_matrix_color_scale.pdf',width=17,height=4)

plot(gradmat.c,col="white", key=NULL, axis.col=list(side=1, labels=FALSE, tick=FALSE), axis.row=list(side=2, labels=FALSE, tick=FALSE), ylab="", xlab="", main=NA, polygon.cell=list(border=NA))
yt=nrow(gradmat.c)+1.5
for (i in 1:nrow(gradmat.c)) {
	yt = yt-1
	yb = yt-1
	xl=-0.5
	for (j in 1:(ncol(gradmat.c)-1)) {
		xl = xl+1
		xr = xl+1
		rect(xleft=xl, xright=xr, ybottom=yb, ytop=yt, border=alpha("gray80",0.3), col=alpha(gradmat.c.col[i,j],colscale*gradmat.c[i,j]))
	}
}

axis(side=1,at=seq(from=0.5,to=ncol(gradmat.c),by=1),labels=sprintf("%.2f",gradmat.c[1,]), cex.axis=4, padj=0.8, xpd=TRUE, lwd.ticks=2, tck=-0.08)

dev.off()

## Relatedness versus fledging sucess

df <- read.table('/home/tyler/Dropbox/research/jay/mosaic/popgen/relatedness/fsj_mosaic_biallelic_snps_main_autosomes_qc_relatedness.txt',head=TRUE)
meta <- read.table('/home/tyler/Dropbox/research/jay/mosaic/metadata/M4_sequenced_FSJsamples_metadata.txt',head=TRUE,sep="\t")
fledge <- read.table('~/Dropbox/research/jay/mosaic/monitoring_data/translocated_jay_fledging_success.txt',head=TRUE)
rank_names <- read.table('/home/tyler/Dropbox/research/jay/mosaic/popgen/relatedness/fsj_mosaic_biallelic_snps_main_autosomes_qc_relatedness_ranked.txt', head=FALSE)

df$id_a <- NA
df$fed_a <- NA
df$type_a <- NA
df$id_b <- NA
df$fed_b <- NA
df$type_b <- NA
for (i in 1:nrow(df)) {
	aidx <- df$a[i]+1
	bidx <- df$b[i]+1
	df$id_a[i] <- meta$LAB_ID[aidx]
	df$fed_a[i] <- meta$USFWS_ID[aidx]
	df$type_a[i] <- meta$type[aidx]
	df$id_b[i] <- meta$LAB_ID[bidx]
	df$fed_b[i] <- meta$USFWS_ID[bidx]
	df$type_b[i] <- meta$type[bidx]
}

trans_id <- meta$LAB_ID[which(meta$type == "T")]
df.summary <- NULL
for (id in trans_id) {
	subdf <- df[which((df$id_a == id | df$id_b == id) & (df$type_a == "C" | df$type_b == "C")),]
	fedid <- meta$USFWS_ID[which(meta$LAB_ID == id)]
	site <- meta$site[which(meta$LAB_ID == id)]
	df.summary <- rbind(df.summary,data.frame(LAB_ID=id, USFWS_ID=fedid, site=site, avg_rab = mean(subdf$rab), median_rab = median(subdf$rab), var_rab = var(subdf$rab), min_rab = min(subdf$rab), max_rab = max(subdf$rab), n0.01 = length(which(subdf$rab > 0.01)), n0.05 = length(which(subdf$rab > 0.05)), n0.1 = length(which(subdf$rab > 0.1)), n0.5 = length(which(subdf$rab > 0.5))))
}

df.summary$fledge <- unname(sapply(df.summary$USFWS_ID,function(x,df){ifelse(x %in% df$FEDERAL_ID, df$total_fledged[which(df$FEDERAL_ID == x)], NA)}, df=fledge))

merge_name <- paste(df.summary$LAB_ID,df.summary$site,sep="_")
df.summary$toprelate <- 0
for (i in 1:nrow(rank_names)) {
	if (length(grep("^C", rank_names[i,1])) > 0) {
		for (j in 2:ncol(rank_names)) {
			if (length(grep("^[EI]", rank_names[i,j])) > 0) break else { # excluding individuals with high E/I individuals prevents confounding T ancestry through E/I ancestry
				if (length(grep("^T", rank_names[i,j])) > 0) {
					idx = which(merge_name == rank_names[i,j])
					df.summary$toprelate[idx] = df.summary$toprelate[idx] + 1
					break
				}
			}
		}
	}
}

# fit site-specific lines to the number of nearest genetic relatives against fledging success
# note: site18 only has one sequenced individual so not fitting 
# note: site12 has two sequenced individuals with no variation in either the response or explanatory variables, so not fitting
# note: texaco shows no variation in response variable so not fitting

site1.fit <- lm(toprelate ~ fledge, data=df.summary[which(df.summary$site == "SITE_1"),])
site13.fit <- lm(toprelate ~ fledge, data=df.summary[which(df.summary$site == "SITE_13"),])

#summary(site1.fit)
#
#Call:
#lm(formula = toprelate ~ fledge, data = df.summary[which(df.summary$site == 
#    "SITE_1"), ])
#
#Residuals:
#       3        5       22       25 
# 0.24880  0.07656  0.24880 -0.57416 
#
#Coefficients:
#            Estimate Std. Error t value Pr(>|t|)   
#(Intercept) -0.24880    0.28962  -0.859  0.48083   
#fledge       0.41148    0.03828  10.750  0.00854 **
#---
#Signif. codes:  0 *** 0.001 ** 0.01 * 0.05 . 0.1   1
#
#Residual standard error: 0.4792 on 2 degrees of freedom
#  (1 observation deleted due to missingness)
#Multiple R-squared:  0.983,	Adjusted R-squared:  0.9745 
#F-statistic: 115.6 on 1 and 2 DF,  p-value: 0.008543

#summary(site13.fit)
#
#Call:
#lm(formula = toprelate ~ fledge, data = df.summary[which(df.summary$site == 
#    "SITE_13"), ])
#
#Residuals:
#    Min      1Q  Median      3Q     Max 
#-0.8489 -0.3347 -0.3347  0.2980  1.6653 
#
#Coefficients:
#            Estimate Std. Error t value Pr(>|t|)
#(Intercept)  0.33473    0.21944   1.525    0.147
#fledge       0.03673    0.03210   1.144    0.269
#
#Residual standard error: 0.7008 on 16 degrees of freedom
#Multiple R-squared:  0.07561,	Adjusted R-squared:  0.01784 
#F-statistic: 1.309 on 1 and 16 DF,  p-value: 0.2694

# plot
library(scales)

df.summary$site.col <- replace(df.summary$site, which(df.summary$site == "SITE_1"), "limegreen")
df.summary$site.col <- replace(df.summary$site.col, which(df.summary$site.col == "SITE_13"), "gold2")
df.summary$site.col <- replace(df.summary$site.col, which(df.summary$site.col == "SITE_12"), "maroon4")
df.summary$site.col <- replace(df.summary$site.col, which(df.summary$site.col == "SITE_18"), "dodgerblue1")
df.summary$site.col <- replace(df.summary$site.col, which(df.summary$site.col == "TEXACO"), "darkslategrey")

#df.summary$site.col[which(df.summary$LAB_ID == "T_086")] = "red"
#df.summary$site.col[which(df.summary$LAB_ID == "T_083")] = "red"
#df.summary$site.col[which(df.summary$LAB_ID == "T_084")] = "red"
#df.summary$site.col[which(df.summary$LAB_ID == "T_079")] = "red"
#df.summary$site.col[which(df.summary$LAB_ID == "T_081")] = "red"
#df.summary$site.col[which(df.summary$LAB_ID == "T_100")] = "red"

#df.summary$site.col[which(df.summary$LAB_ID == "T_082")] = "cyan"
#df.summary$site.col[which(df.summary$LAB_ID == "T_096")] = "cyan"
#df.summary$site.col[which(df.summary$LAB_ID == "T_067")] = "cyan"
#df.summary$site.col[which(df.summary$LAB_ID == "T_078")] = "cyan"
#df.summary$site.col[which(df.summary$LAB_ID == "T_080")] = "cyan"
#df.summary$site.col[which(df.summary$LAB_ID == "T_077")] = "cyan"
#df.summary$site.col[which(df.summary$LAB_ID == "T_074")] = "cyan"
#df.summary$site.col[which(df.summary$LAB_ID == "T_070")] = "cyan"

nsite1 = length(which(df.summary$site == "SITE_1"))
nsite12 = length(which(df.summary$site == "SITE_12"))
nsite13 = length(which(df.summary$site == "SITE_13"))
nsite18 = length(which(df.summary$site == "SITE_18"))
ntex = length(which(df.summary$site == "TEXACO"))

#pdf(file='/home/tyler/Dropbox/research/jay/mosaic/popgen/relatedness/plots/fsj_nearest_genetic_relatives_vs_fledging_2.pdf')
pdf(file='/home/tyler/Dropbox/research/jay/mosaic/popgen/relatedness/plots/fsj_nearest_genetic_relatives_vs_fledging_2_print.pdf')
par(mar=c(4.8,4.2,3.8,2)+0.1)
set.seed(10284)
plot(jitter(df.summary$toprelate,amount=0.03) ~ jitter(df.summary$fledge,amount=0.8), col=df.summary$site.col, cex=2, ylab="Number genetically nearest C Wellfield relatives", 
xlab="Total fledged offspring following translocation", cex.axis=1.5, cex.lab = 1.5, type="n")

abline(coefficients(site1.fit)[1], coefficients(site1.fit)[2], col=alpha("limegreen",0.2), lwd=2.3)
abline(coefficients(site13.fit)[1], coefficients(site13.fit)[2], col=alpha("gold2",0.5), lwd=2.3)
abline(h=0, col=alpha("darkslategrey",0.2), lwd=2.3)

set.seed(10284)
points(jitter(df.summary$toprelate,amount=0.03) ~ jitter(df.summary$fledge,amount=0.8), col=alpha(df.summary$site.col,0.8), cex=2, pch=19)
set.seed(10284)
#points(jitter(df.summary$toprelate,amount=0.03) ~ jitter(df.summary$fledge,amount=0.8), col=df.summary$site.col, cex=2, pch=1)
points(jitter(df.summary$toprelate,amount=0.03) ~ jitter(df.summary$fledge,amount=0.8), col="gray10", cex=2, pch=1, lwd=1)

legend('topleft', c(paste0("site 1 (","n = ", nsite1,")"), paste0("site 12 (","n = ",nsite12,")"), paste0("site 13 (","n = ",nsite13,")"), paste0("site 18 (","n = ",nsite18, ")"), paste0("Texaco (","n = ", ntex, ")")), fill=c("limegreen", "maroon4", "gold2", "dodgerblue1", "darkslategrey"), bty='n', cex=1.2)
dev.off()

## Relatedness proportion plot

meta <- read.table('/home/tyler/Dropbox/research/jay/mosaic/metadata/M4_sequenced_FSJsamples_metadata.txt',head=TRUE,sep="\t")
meta$popcol <- popcolor(meta)

dat <- read.table('/home/tyler/Dropbox/research/jay/mosaic/popgen/relatedness/fsj_mosaic_biallelic_snps_main_autosomes_qc_relatedness_ranked_usfws_pretty2.txt',head=FALSE)

relate.counts <- NULL
rmin <- sort(c(0.00390625, 0.004222888, 0.01, 0.0243058))
ids <- NULL
for (i in 1:ncol(dat)) {
	tok = strsplit(dat[1,i],",")[[1]]
	if (tok[3] != "Contemporary") {
		ids <- c(ids, tok[1])
		counts <- rep(0, length(rmin))
		for (j in 2:nrow(dat)) {
			tok2 = strsplit(dat[j,i],",")[[1]]
			if (tok2[3] == "Contemporary") {
				for (k in 1:length(rmin)) {
					if (as.numeric(tok2[4]) >= rmin[k]) counts[k] = counts[k] + 1				
				}
			}
		}
		relate.counts <- rbind(relate.counts, matrix(counts, nrow=1))
	}
}

# add pop info for sorting
rownames(relate.counts) <- ids
colnames(relate.counts) <- as.character(sprintf("%.4f",round(rmin,4)))
relate.percent <- (relate.counts/(ncol(dat)-length(ids))) * 100

relate.df <- cbind(data.frame(ID = rownames(relate.percent), pop = sapply(rownames(relate.percent), function(x,df){df$pop[which(df$LAB_ID == x)]}, USE.NAMES=FALSE, df=meta), idx=1:(nrow(relate.percent))), data.frame(relate.percent))
relate.df$col <- sapply(relate.df$ID, function(x,df){df$popcol[which(df$LAB_ID == x)]}, USE.NAMES=FALSE, df=meta)
relate.df$pop_name <- popnames(relate.df)

# format for plotting
pop.idx.sort <- relate.df$idx[c(which(relate.df$pop == "Resident"), which(relate.df$pop == "SITE_1"), which(relate.df$pop == "SITE_12"), which(relate.df$pop == "SITE_13"), which(relate.df$pop == "SITE_18"), which(relate.df$pop == "TEXACO"), which(relate.df$pop == "Brigman"), which(relate.df$pop == "Duette_headwaters"), which(relate.df$pop == "Golden_Aster_Scrub"), which(relate.df$pop == "Sun_City"), which(relate.df$pop == "W.Balm"))]

relate.percent.sort <- relate.percent[pop.idx.sort,] # order by population

# plot

#x11(width=16, height=7)
pdf(file='/home/tyler/Dropbox/research/jay/mosaic/popgen/relatedness/plots/percent_relatives.pdf',width=16,height=7)
par(mar=c(5,4.5,4,2)+0.1)
relate.bar <- barplot(height=t(relate.percent.sort[,4:2]), beside=TRUE, axisnames=FALSE, col=c("lightpink2", "aquamarine2", "steelblue"), cex.axis=1.4, ylab="Percent Contemporary individuals", cex.lab=1.4, ylim=c(0,50))
text(x=colMeans(relate.bar), y=-3.5, labels=rownames(relate.percent.sort), xpd=TRUE, srt=90)
legend(x=215, y=50,legend=as.character(sprintf("%.4f",round(rmin,4)))[4:2], fill=c("lightpink2", "aquamarine2", "steelblue"), bty='n', cex=1.4, text.col="grey20", title="r cutoff")
dev.off()

## Distribution of number of related Contemporary individuals

s <- read.table("/home/tyler/Dropbox/research/jay/mosaic/popgen/relatedness/skew_stat_024.txt",head=TRUE)
pdf(file='/home/tyler/Dropbox/research/jay/mosaic/popgen/relatedness/plots/number_related_Contemporary_r024.pdf')
par(mar=c(5, 4.5, 4, 2)+0.1)
hist(s$n.relate,breaks=10,xlab="Number related Contemporary Individuals", ylab="Frequency", cex.axis=1.4, cex.lab=1.4, main="")
text(x=6,y=25,labels="r > 0.024", cex=1.4, xpd=TRUE)
dev.off()

## Skewed relatedness analysis

meta <- read.table('/home/tyler/Dropbox/research/jay/mosaic/metadata/M4_sequenced_FSJsamples_metadata.txt',head=TRUE,sep="\t")
meta$popcol <- popcolor(meta)

dat <- read.table('/home/tyler/Dropbox/research/jay/mosaic/popgen/relatedness/fsj_mosaic_biallelic_snps_main_autosomes_qc_relatedness_ranked_usfws_pretty2.txt',head=FALSE)

c.idx = NULL
for (i in 1:ncol(dat)) {
	if (strsplit(dat[1,i],",")[[1]][3] == "Contemporary") c.idx <- c(c.idx, i)
}
nc = length(c.idx)

# average background pairwise relatedness among residents
rc = NULL
for (i in c.idx) {
	ind1 = strsplit(dat[1,i],",")[[1]][1]
	for (k in 2:nrow(dat)) {
		tok = strsplit(dat[k,i],",")[[1]]
		ind2 = tok[1]
		if (tok[3] == "Contemporary" && (length(which(rc$ind1 == ind1)) < 1 || length(which(rc$ind1 == ind2)) < 1)) {
			rc <- rbind(rc, data.frame(ind1 = ind1, ind2 = ind2, r = as.numeric(tok[4])))
		}
	}
}

avg.rc = mean(rc$r)

# average pairwise relatedness between translocated individuals and Residents
r.rt = NULL # stores the pairwise relatedness between Residents and translocated individuals
transpop <- c("SITE_1", "SITE_12", "SITE_13", "SITE_18", "TEXACO")
for (i in 1:ncol(dat)) {
	tok = strsplit(dat[1,i],",")[[1]]
	if (tok[3] != "Resident") next
	for (j in 2:nrow(dat)) {
		tok = strsplit(dat[j,i],",")[[1]]
		if (tok[3] %in% transpop || tok[1] == "I_049") r.rt <- c(r.rt, as.numeric(tok[4]))
	}
}

calc_r_stats <- function(df, r.cutoff = 0.001) {

# Statistic: X_{i,c}
#
# X_{i,c}: Joint probability that non-Contemporary individual i will be related to a Contemporary individual j 
# (based on r_{i,j} > c) and that the relatedness of i to j is higher than that of any other contemporary individual 
# to j.
#
# X_{i,c} = a_{i,c} * b_{i,c}
# a_i = P(r_{i,j} > r_{k,j} | r_{i,j} > c) where j is a random Contemporary individual and k is a random non-Contemporary individual, k != i
# b_i = P(r_{i,j} > c) where j is a random Contemporary individual
#
#
# In other words, X_{i,c} is the average normalized relatedness ranking of individual i among their Contemporary relatives, 
# weighted by the proportion of the Contemporary individuals that are related to i.

	# initialize list
	indvec = NULL
	x = list()
	n = 1
	for (i in 1:ncol(df)) {
		tok = strsplit(df[1,i],",")[[1]]
		if (tok[3] == "Contemporary") next
		indvec <- c(indvec, tok[1])
		x[[n]] <- list(name = tok[1], rank = NULL, ncutoff = 0, relative.ID = NULL)
		n = n+1
	}

	# record ranks and counts
	for (j in 1:ncol(df)) {
		tok = strsplit(df[1,j],",")[[1]]
		if (tok[3] != "Contemporary") next
		r.rank = 0
		cind = tok[1]
		for (k in 2:nrow(df)) {
			tok = strsplit(df[k,j],",")[[1]]
			if (tok[3] != "Contemporary") {
				idx = which(indvec == tok[1])
				r.rank = r.rank + 1
				if (as.numeric(tok[4]) >= r.cutoff) {
					# This contemporary individual is considered a relative
					x[[idx]]$ncutoff = x[[idx]]$ncutoff + 1
					x[[idx]]$rank <- c(x[[idx]]$rank, r.rank)
					x[[idx]]$relative.ID <- c(x[[idx]]$relative.ID, cind)
				}
			}
		}
	}

	# calculate stats
	stat.df = NULL
	n.ind = length(indvec)
	nc = ncol(df) - n.ind
	for (i in 1:n.ind) {
		id = x[[i]]$name
		avg.rank = ifelse(is.null(x[[i]]$rank), 0, mean((n.ind-x[[i]]$rank)/(n.ind-1)))
		p = x[[i]]$ncutoff/nc
		rel = ifelse(is.null(x[[i]]$relative.ID), NA, paste(x[[i]]$relative.ID,collapse=","))
		stat.df = rbind(stat.df, data.frame(ID = x[[i]]$name, avg.rank = avg.rank, n.relate = x[[i]]$ncutoff, r.skew = avg.rank*p, relatives=rel))
	}

	return(stat.df)
}

df.relate <- calc_r_stats(df = dat, r.cutoff = 0.00390625 ) # 2/512 = Half third cousin (see Hartl and Clark pg. 272), r = 2*F
df.relate2 <- calc_r_stats(df = dat, r.cutoff = 0.01) # corresponds to approximatley half second cousins (r = 2/128)
df.relate3 <- calc_r_stats(df = dat, r.cutoff = mean(r.rt)) # 0.004222888: mean pairwise relatedness between Residents and translocated
df.relate4 <- calc_r_stats(df = dat, r.cutoff = unname(quantile(r.rt, 0.95))) # 0.0243058: top 5% pairwise relatedness between Residents and translocated

# output skew stat dataframes
#write.table(df.relate,file='/home/tyler/Dropbox/research/jay/mosaic/popgen/relatedness/skew_stat_0039.txt',col.names=TRUE,row.names=FALSE,quote=FALSE,sep="\t")
#write.table(df.relate2,file='/home/tyler/Dropbox/research/jay/mosaic/popgen/relatedness/skew_stat_01.txt',col.names=TRUE,row.names=FALSE,quote=FALSE,sep="\t")
#write.table(df.relate3,file='/home/tyler/Dropbox/research/jay/mosaic/popgen/relatedness/skew_stat_0042.txt',col.names=TRUE,row.names=FALSE,quote=FALSE,sep="\t")
#write.table(df.relate4,file='/home/tyler/Dropbox/research/jay/mosaic/popgen/relatedness/skew_stat_024.txt',col.names=TRUE,row.names=FALSE,quote=FALSE,sep="\t")

# plot genetic skew statistic
library(scales)

# relatedness cutoff of 0.00390625
df.relate.sort <- df.relate[order(-df.relate$r.skew),c(1,4)]

pdf(file='/home/tyler/Dropbox/research/jay/mosaic/popgen/relatedness/plots/genetic_skew_004.pdf',width=13,height=7)

par(mar=c(5,5.2,4,2)+0.1)
plot(x=1:nrow(df.relate.sort), y=df.relate.sort$r.skew, type="l", lwd=4, col="grey60", ylab = expression(paste("Genetic skew (",hat(rho)[0.0039],")")), xlab="", xaxt='n',cex.lab=1.6, cex.axis=1.4)
axis(1, at=1:nrow(df.relate.sort), labels=df.relate.sort$ID,cex=1.2,las=2)
pointcols = meta$popcol[sapply(df.relate.sort$ID,function(x,df){which(df$LAB_ID == x)},df=meta, USE.NAMES=FALSE)]
points(x=1:nrow(df.relate.sort), y=df.relate.sort$r.skew, pch=19, col=alpha(pointcols,0.8), cex=2)
points(x=1:nrow(df.relate.sort), y=df.relate.sort$r.skew, pch=1, col=pointcols, cex=2, lwd=2)
lh = df.relate.sort$r.skew-0.008
lh[which(lh < 0.008)] = 0
lines(x=1:nrow(df.relate.sort), y=lh, type="h", lwd=14, col=alpha(pointcols,0.4))

dev.off()

# relatedness cutoff of 0.01
df.relate.sort2 <- df.relate2[order(-df.relate2$r.skew),c(1,4)]

pdf(file='/home/tyler/Dropbox/research/jay/mosaic/popgen/relatedness/plots/genetic_skew_01.pdf',width=13,height=7)

par(mar=c(5,5.2,4,2)+0.1)
plot(x=1:nrow(df.relate.sort2), y=df.relate.sort2$r.skew, type="l", lwd=4, col="grey60", ylab = expression(paste("Genetic skew (",hat(rho)[0.01],")")), xlab="", xaxt='n',cex.lab=1.6, cex.axis=1.4)
axis(1, at=1:nrow(df.relate.sort2), labels=df.relate.sort2$ID,cex=1.2,las=2)
pointcols = meta$popcol[sapply(df.relate.sort2$ID,function(x,df){which(df$LAB_ID == x)},df=meta, USE.NAMES=FALSE)]
points(x=1:nrow(df.relate.sort2), y=df.relate.sort2$r.skew, pch=19, col=alpha(pointcols,0.8), cex=2)
points(x=1:nrow(df.relate.sort2), y=df.relate.sort2$r.skew, pch=1, col=pointcols, cex=2, lwd=2)
lh = df.relate.sort2$r.skew-0.008
lh[which(lh < 0.008)] = 0
lines(x=1:nrow(df.relate.sort2), y=lh, type="h", lwd=14, col=alpha(pointcols,0.4))

dev.off()

# relatedness cutoff of 0.004222888 (mean pairwise relatedness between Residents and translocated)
df.relate.sort3 <- df.relate3[order(-df.relate3$r.skew),c(1,4)]

pdf(file='/home/tyler/Dropbox/research/jay/mosaic/popgen/relatedness/plots/genetic_skew_0042.pdf',width=13,height=7)

par(mar=c(5,5.2,4,2)+0.1)
plot(x=1:nrow(df.relate.sort3), y=df.relate.sort3$r.skew, type="l", lwd=4, col="grey60", ylab = expression(paste("Genetic skew (",hat(rho)[0.0042],")")), xlab="", xaxt='n',cex.lab=1.6, cex.axis=1.4)
axis(1, at=1:nrow(df.relate.sort3), labels=df.relate.sort3$ID,cex=1.2,las=2)
pointcols = meta$popcol[sapply(df.relate.sort3$ID,function(x,df){which(df$LAB_ID == x)},df=meta, USE.NAMES=FALSE)]
points(x=1:nrow(df.relate.sort3), y=df.relate.sort3$r.skew, pch=19, col=alpha(pointcols,0.8), cex=2)
points(x=1:nrow(df.relate.sort3), y=df.relate.sort3$r.skew, pch=1, col=pointcols, cex=2, lwd=2)
lh = df.relate.sort3$r.skew-0.008
lh[which(lh < 0.008)] = 0
lines(x=1:nrow(df.relate.sort3), y=lh, type="h", lwd=14, col=alpha(pointcols,0.4))

dev.off()

# relatedness cutoff of 0.0243058 (top 5% pairwise relatedness between Residents and translocated)
df.relate.sort4 <- df.relate4[order(-df.relate4$r.skew),c(1,4)]

pdf(file='/home/tyler/Dropbox/research/jay/mosaic/popgen/relatedness/plots/genetic_skew_024.pdf',width=13,height=7)

par(mar=c(5,5.2,4,2)+0.1)
plot(x=1:nrow(df.relate.sort4), y=df.relate.sort4$r.skew, type="l", lwd=4, col="grey60", ylab = expression(paste("Genetic skew (",hat(rho)[0.024],")")), xlab="", xaxt='n',cex.lab=1.6, cex.axis=1.4)
axis(1, at=1:nrow(df.relate.sort4), labels=df.relate.sort4$ID,cex=1.2,las=2)
pointcols = meta$popcol[sapply(df.relate.sort4$ID,function(x,df){which(df$LAB_ID == x)},df=meta, USE.NAMES=FALSE)]
points(x=1:nrow(df.relate.sort4), y=df.relate.sort4$r.skew, pch=19, col=alpha(pointcols,0.8), cex=2)
points(x=1:nrow(df.relate.sort4), y=df.relate.sort4$r.skew, pch=1, col=pointcols, cex=2, lwd=2)
lh = df.relate.sort4$r.skew-0.008
lh[which(lh < 0.008)] = 0
lines(x=1:nrow(df.relate.sort4), y=lh, type="h", lwd=14, col=alpha(pointcols,0.4))

dev.off()

# Genetic skew against fledging

fledge <- read.table('~/Dropbox/research/jay/mosaic/monitoring_data/translocated_jay_fledging_success.txt',head=TRUE)

# Add fledging info to data frames of relatedness stats
df.relate$USFWS_ID = sapply(df.relate$ID,function(x,df){df$USFWS_ID[which(df$LAB_ID == x)]},USE.NAMES=FALSE,df=meta)
df.relate2$USFWS_ID = sapply(df.relate2$ID,function(x,df){df$USFWS_ID[which(df$LAB_ID == x)]},USE.NAMES=FALSE,df=meta)
df.relate3$USFWS_ID = sapply(df.relate3$ID,function(x,df){df$USFWS_ID[which(df$LAB_ID == x)]},USE.NAMES=FALSE,df=meta)
df.relate4$USFWS_ID = sapply(df.relate4$ID,function(x,df){df$USFWS_ID[which(df$LAB_ID == x)]},USE.NAMES=FALSE,df=meta)

df.relate$fledge <- sapply(df.relate$USFWS_ID, function(x,df){if (x %in% df$FEDERAL_ID) return(df$total_fledged[which(df$FEDERAL_ID == x)]) else return (NA)}, USE.NAMES=FALSE, df=fledge)
df.relate2$fledge <- sapply(df.relate2$USFWS_ID, function(x,df){if (x %in% df$FEDERAL_ID) return(df$total_fledged[which(df$FEDERAL_ID == x)]) else return (NA)}, USE.NAMES=FALSE, df=fledge)
df.relate3$fledge <- sapply(df.relate3$USFWS_ID, function(x,df){if (x %in% df$FEDERAL_ID) return(df$total_fledged[which(df$FEDERAL_ID == x)]) else return (NA)}, USE.NAMES=FALSE, df=fledge)
df.relate4$fledge <- sapply(df.relate4$USFWS_ID, function(x,df){if (x %in% df$FEDERAL_ID) return(df$total_fledged[which(df$FEDERAL_ID == x)]) else return (NA)}, USE.NAMES=FALSE, df=fledge)

pntcol <- sapply(df.relate4$ID, function(x,df){df$popcol[which(df$LAB_ID == x)]}, USE.NAMES=FALSE, df=meta)

# Data frame of individuals with highest skew statistic per closely related group (these are likely the highly successful reproduces 
# in each group). This prevents points for individuals with high skew statistics through relatedness to a genetically highly successful individual 
# from being plotted and obscurring the relationship between genetic skew and fledging success.
# Choose individuals based on grouping from Ward minimum variance clustering of pairwise relatedness and the PCA groupings.

site1.1 <- c("T_071", "T_090", "T_097") 
site12.1 <- c("T_068","T_089")
site13.1 <- c("T_079", "T_081", "T_083", "T_084", "T_086", "T_100") # Site 13 group 1
site13.2 <- c("T_070", "T_074", "T_077", "T_078", "T_080") # Site 13 group 2
site13.3 <- c("T_067", "T_082", "T_098", "I_049") # Site 13 group 3
tex.1 <- c("T_073","T_075","T_101")

groups <- list(site1.1, site12.1, site13.1, site13.2, site13.3, tex.1)
group.ind <- NULL

set.seed(4642)

dfmax <- list(NULL, NULL, NULL, NULL)
for (i in 1:length(groups)) {
	subdf1 <- df.relate[which(df.relate$ID %in% groups[[i]]),]
	#dfmax[[1]] <- rbind(dfmax[[1]], subdf1[which(subdf1$r.skew == max(subdf1$r.skew))[1],])
	idx1 <- which(subdf1$r.skew == max(subdf1$r.skew))
	dfmax[[1]] <- rbind(dfmax[[1]], subdf1[ifelse(length(idx1) > 1,sample(x=idx1,size=1) ,idx1),]) # randomly sample 1 individual when there are ties for highest skew

	subdf2 <- df.relate2[which(df.relate2$ID %in% groups[[i]]),]
	#dfmax[[2]] <- rbind(dfmax[[2]], subdf2[which(subdf2$r.skew == max(subdf2$r.skew))[1],])
	idx2 <- which(subdf2$r.skew == max(subdf2$r.skew))
	dfmax[[2]] <- rbind(dfmax[[2]], subdf2[ifelse(length(idx2) > 1,sample(x=idx2,size=1) ,idx2),])

	subdf3 <- df.relate3[which(df.relate3$ID %in% groups[[i]]),]
	#dfmax[[3]] <- rbind(dfmax[[3]], subdf3[which(subdf3$r.skew == max(subdf3$r.skew))[1],])
	idx3 <- which(subdf3$r.skew == max(subdf3$r.skew))
	dfmax[[3]] <- rbind(dfmax[[3]], subdf3[ifelse(length(idx3) > 1,sample(x=idx3,size=1) ,idx3),])

	subdf4 <- df.relate4[which(df.relate4$ID %in% groups[[i]]),]
	#dfmax[[4]] <- rbind(dfmax[[4]], subdf4[which(subdf4$r.skew == max(subdf4$r.skew))[1],])
	idx4 <- which(subdf4$r.skew == max(subdf4$r.skew))
	dfmax[[4]] <- rbind(dfmax[[4]], subdf4[ifelse(length(idx4) > 1,sample(x=idx4,size=1) ,idx4),])

	group.ind <- c(group.ind, groups[[i]])
}

dfmax[[1]] <- rbind(dfmax[[1]], df.relate[which(df.relate$ID %in% group.ind == FALSE & !is.na(df.relate$fledge)),])
dfmax[[2]] <- rbind(dfmax[[2]], df.relate2[which(df.relate2$ID %in% group.ind == FALSE & !is.na(df.relate2$fledge)),])
dfmax[[3]] <- rbind(dfmax[[3]], df.relate3[which(df.relate3$ID %in% group.ind == FALSE & !is.na(df.relate3$fledge)),])
dfmax[[4]] <- rbind(dfmax[[4]], df.relate4[which(df.relate4$ID %in% group.ind == FALSE & !is.na(df.relate4$fledge)),])

for (i in 1:4) {
	dfmax[[i]]$popcol <- sapply(dfmax[[i]]$ID,function(x,df){df$popcol[which(df$LAB_ID == x)]},USE.NAMES=FALSE, df=meta)
}

# plot
pdf(file='/home/tyler/Dropbox/research/jay/mosaic/popgen/relatedness/plots/genetic_skew_vs_fledging3.pdf') # this version fixes a text typo
#pdf(file='/home/tyler/Dropbox/research/jay/mosaic/popgen/relatedness/plots/genetic_skew_vs_fledging2.pdf')
#pdf(file='/home/tyler/Dropbox/research/jay/mosaic/popgen/relatedness/plots/genetic_skew_vs_fledging.pdf')
#pdf(file='/home/tyler/Dropbox/research/jay/mosaic/popgen/relatedness/plots/genetic_skew_vs_fledging_labels.pdf')

# relatedness cutoff of 0.00390625

dfmax.c <- df.relate[which(df.relate$ID %in% dfmax[[1]]$ID == FALSE & !is.na(df.relate$fledge)),]
dfmax.c$popcol <- sapply(dfmax.c$ID,function(x,df){df$popcol[which(df$LAB_ID == x)]},USE.NAMES=FALSE, df=meta)
dfmax.comb <- rbind(dfmax[[1]], dfmax.c)

fledge.fit <- lm(r.skew ~ fledge, data=dfmax[[1]])

#summary(fledge.fit)

#Call:
#lm(formula = r.skew ~ fledge, data = dfmax[[1]])
#
#Residuals:
#     Min       1Q   Median       3Q      Max 
#-0.14726 -0.09418 -0.03703  0.10453  0.20258 
#
#Coefficients:
#            Estimate Std. Error t value Pr(>|t|)  
#(Intercept) 0.129561   0.050784   2.551   0.0288 *
#fledge      0.012904   0.006415   2.012   0.0720 .
#---
#Signif. codes:  0 *** 0.001 ** 0.01 * 0.05 . 0.1   1
#
#Residual standard error: 0.1265 on 10 degrees of freedom
#Multiple R-squared:  0.2881,	Adjusted R-squared:  0.2169 
#F-statistic: 4.046 on 1 and 10 DF,  p-value: 0.07199

fledge.fit.all <- lm(r.skew~fledge, data=dfmax.comb)

#summary(fledge.fit.all)

#Call:
#lm(formula = r.skew ~ fledge, data = dfmax.comb)
#
#Residuals:
#     Min       1Q   Median       3Q      Max 
#-0.18227 -0.08459 -0.02509  0.04393  0.28733 
#
#Coefficients:
#            Estimate Std. Error t value Pr(>|t|)    
#(Intercept) 0.146781   0.031685   4.633 8.87e-05 ***
#fledge      0.006025   0.004620   1.304    0.204    
#---
#Signif. codes:  0 *** 0.001 ** 0.01 * 0.05 . 0.1   1
#
#Residual standard error: 0.1258 on 26 degrees of freedom
#Multiple R-squared:  0.06139,	Adjusted R-squared:  0.02529 
#F-statistic: 1.701 on 1 and 26 DF,  p-value: 0.2036

set.seed(2496)
par(mar=c(5,5.2,4,2)+0.1)
x1 = jitter(dfmax[[1]]$fledge,amount=0.1)
plot(x=x1, y=dfmax[[1]]$r.skew, pch=19, cex=1.5, col=dfmax[[1]]$popcol, ylab=expression(paste("Genetic skew (",hat(rho)[0.0039],")")), xlab="Total fledged offspring", xlim=c(0,17), cex.lab=1.6, cex.axis=1.4, ylim=c(0,0.48),type="n")
abline(coefficients(fledge.fit)[1], coefficients(fledge.fit)[2], col="grey60", lwd=2.3)
abline(coefficients(fledge.fit.all)[1], coefficients(fledge.fit.all)[2], col="grey60", lwd=3.3, lty=3)
points(x=jitter(dfmax.c$fledge,amount=0.1), y=dfmax.c$r.skew, pch=1, col=dfmax.c$popcol, cex=2, lwd=3)
points(x=x1, y=dfmax[[1]]$r.skew, pch=19, col=alpha(dfmax[[1]]$popcol,0.8), cex=2)
points(x=x1, y=dfmax[[1]]$r.skew, pch=1, col=dfmax[[1]]$popcol, cex=2, lwd=3)
text(x=13,y=0.33,substitute(paste(R^2," = ",rsq),list(rsq=round(summary(fledge.fit)$r.squared,digits=2))),cex=1.2,col="grey20")
text(x=14,y=0.26,substitute(paste(R^2," = ",rsq),list(rsq=round(summary(fledge.fit.all)$r.squared,digits=2))),cex=1.2,col="grey20")
#text(x=x1, y=jitter(dfmax[[1]]$r.skew,amount=0.01), dfmax[[1]]$ID)

# relatedness cutoff of 0.01

dfmax2.c <- df.relate2[which(df.relate2$ID %in% dfmax[[2]]$ID == FALSE & !is.na(df.relate2$fledge)),]
dfmax2.c$popcol <- sapply(dfmax2.c$ID,function(x,df){df$popcol[which(df$LAB_ID == x)]},USE.NAMES=FALSE, df=meta)
dfmax2.comb <- rbind(dfmax[[2]], dfmax2.c)

fledge.fit2 <- lm(r.skew ~ fledge, data=dfmax[[2]])

#summary(fledge.fit2)

#Call:
#lm(formula = r.skew ~ fledge, data = dfmax[[2]])
#
#Residuals:
#      Min        1Q    Median        3Q       Max 
#-0.216479 -0.083743 -0.008584  0.074247  0.159572 
#
#Coefficients:
#            Estimate Std. Error t value Pr(>|t|)  
#(Intercept) 0.116178   0.046762   2.484   0.0323 *
#fledge      0.011917   0.005891   2.023   0.0706 .
#---
#Signif. codes:  0 *** 0.001 ** 0.01 * 0.05 . 0.1   1
#
#Residual standard error: 0.123 on 10 degrees of freedom
#Multiple R-squared:  0.2904,	Adjusted R-squared:  0.2194 
#F-statistic: 4.092 on 1 and 10 DF,  p-value: 0.07065


fledge.fit2.all <- lm(r.skew ~ fledge, data=dfmax2.comb)

#summary(fledge.fit2.all)

#Call:
#lm(formula = r.skew ~ fledge, data = dfmax2.comb)
#
#Residuals:
#     Min       1Q   Median       3Q      Max 
#-0.15852 -0.09406 -0.02450  0.04758  0.27845 
#
#Coefficients:
#            Estimate Std. Error t value Pr(>|t|)    
#(Intercept) 0.124259   0.031930   3.892  0.00062 ***
#fledge      0.005710   0.004656   1.226  0.23101    
#---
#Signif. codes:  0 *** 0.001 ** 0.01 * 0.05 . 0.1   1
#
#Residual standard error: 0.1267 on 26 degrees of freedom
#Multiple R-squared:  0.05469,	Adjusted R-squared:  0.01833 
#F-statistic: 1.504 on 1 and 26 DF,  p-value: 0.231

set.seed(2496)
par(mar=c(5,5.2,4,2)+0.1)
x2 = jitter(dfmax[[2]]$fledge,amount=0.1)
plot(x=x2, y=dfmax[[2]]$r.skew, pch=19, cex=1.5, col=dfmax[[2]]$popcol, ylab=expression(paste("Genetic skew (",hat(rho)[0.01],")")), xlab="Total fledged offspring", xlim=c(0,17), cex.lab=1.6, cex.axis=1.4, ylim=c(0,0.48),type="n")
abline(coefficients(fledge.fit2)[1], coefficients(fledge.fit2)[2], col="grey60", lwd=2.3)
abline(coefficients(fledge.fit2.all)[1], coefficients(fledge.fit2.all)[2], col="grey60", lwd=3.3, lty=3)
points(x=jitter(dfmax2.c$fledge,amount=0.1), y=dfmax2.c$r.skew, pch=1, col=dfmax2.c$popcol, cex=2, lwd=3)
points(x=x2, y=dfmax[[2]]$r.skew, pch=19, col=alpha(dfmax[[2]]$popcol,0.8), cex=2)
points(x=x2, y=dfmax[[2]]$r.skew, pch=1, col=dfmax[[2]]$popcol, cex=2, lwd=3)
text(x=13,y=0.30,substitute(paste(R^2," = ",rsq),list(rsq=round(summary(fledge.fit2)$r.squared,digits=2))),cex=1.2,col="grey20")
text(x=14,y=0.18,substitute(paste(R^2," = ",rsq),list(rsq=round(summary(fledge.fit2.all)$r.squared,digits=2))),cex=1.2,col="grey20")
#text(x=x2, y=jitter(dfmax[[2]]$r.skew,amount=0.01), dfmax[[2]]$ID)

# relatedness cutoff of 0.004222888 (mean pairwise relatedness between Residents and translocated)

dfmax3.c <- df.relate3[which(df.relate3$ID %in% dfmax[[3]]$ID == FALSE & !is.na(df.relate3$fledge)),]
dfmax3.c$popcol <- sapply(dfmax3.c$ID,function(x,df){df$popcol[which(df$LAB_ID == x)]},USE.NAMES=FALSE, df=meta)
dfmax3.comb <- rbind(dfmax[[3]], dfmax3.c)

fledge.fit3 <- lm(r.skew ~ fledge, data=dfmax[[3]])

#summary(fledge.fit3)

#Call:
#lm(formula = r.skew ~ fledge, data = dfmax[[3]])
#
#Residuals:
#     Min       1Q   Median       3Q      Max 
#-0.13423 -0.09960 -0.03879  0.10514  0.19766 
#
#Coefficients:
#            Estimate Std. Error t value Pr(>|t|)  
#(Intercept) 0.124995   0.048949   2.554   0.0287 *
#fledge      0.013958   0.006297   2.216   0.0510 .
#---
#Signif. codes:  0 *** 0.001 ** 0.01 * 0.05 . 0.1   1
#
#Residual standard error: 0.125 on 10 degrees of freedom
#Multiple R-squared:  0.3294,	Adjusted R-squared:  0.2624 
#F-statistic: 4.913 on 1 and 10 DF,  p-value: 0.051

fledge.fit3.all <- lm(r.skew ~ fledge, data=dfmax3.comb)

#summary(fledge.fit3.all)

#Call:
#lm(formula = r.skew ~ fledge, data = dfmax3.comb)
#
#Residuals:
#     Min       1Q   Median       3Q      Max 
#-0.17949 -0.08306 -0.02271  0.03609  0.28886 
#
#Coefficients:
#            Estimate Std. Error t value Pr(>|t|)    
#(Intercept) 0.145249   0.031947   4.547 0.000111 ***
#fledge      0.005912   0.004658   1.269 0.215654    
#---
#Signif. codes:  0 *** 0.001 ** 0.01 * 0.05 . 0.1   1
#
#Residual standard error: 0.1268 on 26 degrees of freedom
#Multiple R-squared:  0.05833,	Adjusted R-squared:  0.02211 
#F-statistic: 1.611 on 1 and 26 DF,  p-value: 0.2157

set.seed(2496)
par(mar=c(5,5.2,4,2)+0.1)
x3 = jitter(dfmax[[3]]$fledge,amount=0.1)
plot(x=x3, y=dfmax[[3]]$r.skew, pch=19, cex=1.5, col=dfmax[[3]]$popcol, ylab=expression(paste("Genetic skew (",hat(rho)[0.0042],")")), xlab="Total fledged offspring", xlim=c(0,17), cex.lab=1.6, cex.axis=1.4, ylim=c(0,0.48),type="n")
abline(coefficients(fledge.fit3)[1], coefficients(fledge.fit3)[2], col="grey60", lwd=2.3)
abline(coefficients(fledge.fit3.all)[1], coefficients(fledge.fit3.all)[2], col="grey60", lwd=3.3, lty=3)
points(x=jitter(dfmax3.c$fledge,amount=0.1), y=dfmax3.c$r.skew, pch=1, col=dfmax3.c$popcol, cex=2, lwd=3)
points(x=x3, y=dfmax[[3]]$r.skew, pch=19, col=alpha(dfmax[[3]]$popcol,0.8), cex=2)
points(x=x3, y=dfmax[[3]]$r.skew, pch=1, col=dfmax[[3]]$popcol, cex=2, lwd=3)
text(x=12.5,y=0.34,substitute(paste(R^2," = ",rsq),list(rsq=round(summary(fledge.fit3)$r.squared,digits=2))),cex=1.2,col="grey20")
text(x=14,y=0.25,substitute(paste(R^2," = ",rsq),list(rsq=round(summary(fledge.fit3.all)$r.squared,digits=2))),cex=1.2,col="grey20")
#text(x=x3, y=jitter(dfmax[[3]]$r.skew,amount=0.01), dfmax[[3]]$ID)

# relatedness cutoff of 0.0243058 (top 5% pairwise relatedness between Residents and translocated)

dfmax4.c <- df.relate4[which(df.relate4$ID %in% dfmax[[4]]$ID == FALSE & !is.na(df.relate4$fledge)),]
dfmax4.c$popcol <- sapply(dfmax4.c$ID,function(x,df){df$popcol[which(df$LAB_ID == x)]},USE.NAMES=FALSE, df=meta)
dfmax4.comb <- rbind(dfmax[[4]], dfmax4.c)

fledge.fit4 <- lm(r.skew ~ fledge, data=dfmax[[4]])

#summary(fledge.fit4)

#Call:
#lm(formula = r.skew ~ fledge, data = dfmax[[4]])
#
#Residuals:
#      Min        1Q    Median        3Q       Max 
#-0.206099 -0.075977  0.000536  0.069014  0.200869 
#
#Coefficients:
#            Estimate Std. Error t value Pr(>|t|)  
#(Intercept) 0.074305   0.051311   1.448   0.1782  
#fledge      0.011981   0.006075   1.972   0.0769 .
#---
#Signif. codes:  0 *** 0.001 ** 0.01 * 0.05 . 0.1   1
#
#Residual standard error: 0.1251 on 10 degrees of freedom
#Multiple R-squared:   0.28,	Adjusted R-squared:  0.208 
#F-statistic: 3.889 on 1 and 10 DF,  p-value: 0.07687

fledge.fit4.all <- lm(r.skew ~ fledge, data=dfmax4.comb)

#summary(fledge.fit4.all)

#Call:
#lm(formula = r.skew ~ fledge, data = dfmax4.comb)
#
#Residuals:
#     Min       1Q   Median       3Q      Max 
#-0.16786 -0.09086 -0.02012  0.04182  0.23650 
#
#Coefficients:
#            Estimate Std. Error t value Pr(>|t|)   
#(Intercept) 0.091338   0.028269   3.231  0.00334 **
#fledge      0.006956   0.004122   1.688  0.10346   
#---
#Signif. codes:  0 *** 0.001 ** 0.01 * 0.05 . 0.1   1
#
#Residual standard error: 0.1122 on 26 degrees of freedom
#Multiple R-squared:  0.09872,	Adjusted R-squared:  0.06406 
#F-statistic: 2.848 on 1 and 26 DF,  p-value: 0.1035


# Regression with Texaco excluded

dfmax4.notex <- dfmax[[4]][-which(dfmax[[4]]$ID %in% meta$LAB_ID[which(meta$pop == "TEXACO")]),]
fledge.fit4.notex <- lm(r.skew ~ fledge, data=dfmax4.notex)

#summary(fledge.fit4.notex)

#Call:
#lm(formula = r.skew ~ fledge, data = dfmax4.notex)
#
#Residuals:
#      Min        1Q    Median        3Q       Max 
#-0.155279 -0.077328 -0.003509  0.071995  0.172344 
#
#Coefficients:
#            Estimate Std. Error t value Pr(>|t|)  
#(Intercept) 0.077328   0.044741   1.728   0.1180  
#fledge      0.014815   0.005473   2.707   0.0241 *
#---
#Signif. codes:  0 *** 0.001 ** 0.01 * 0.05 . 0.1   1
#
#Residual standard error: 0.109 on 9 degrees of freedom
#Multiple R-squared:  0.4487,	Adjusted R-squared:  0.3875 
#F-statistic: 7.326 on 1 and 9 DF,  p-value: 0.02413

set.seed(2496)
par(mar=c(5,5.2,4,2)+0.1)
x4 = jitter(dfmax[[4]]$fledge,amount=0.1)
plot(x=x4, y=dfmax[[4]]$r.skew, pch=19, cex=1.5, col=dfmax[[4]]$popcol, ylab=expression(paste("Genetic skew (",hat(rho)[0.024],")")), xlab="Total fledged offspring", xlim=c(0,17), cex.lab=1.6, cex.axis=1.4, ylim=c(0,0.45),type="n")
abline(coefficients(fledge.fit4)[1], coefficients(fledge.fit4)[2], col="grey60", lwd=2.3)
abline(coefficients(fledge.fit4.notex)[1], coefficients(fledge.fit4.notex)[2], col="grey60", lwd=2.3, lty=5)
abline(coefficients(fledge.fit4.all)[1], coefficients(fledge.fit4.all)[2], col="grey60", lwd=3.3, lty=3)
points(x=jitter(dfmax4.c$fledge,amount=0.1), y=dfmax4.c$r.skew, pch=1, col=dfmax4.c$popcol, cex=2, lwd=3)
points(x=x4, y=dfmax[[4]]$r.skew, pch=19, col=alpha(dfmax[[4]]$popcol,0.8), cex=2)
points(x=x4, y=dfmax[[4]]$r.skew, pch=1, col=dfmax[[4]]$popcol, cex=2, lwd=3)
#text(x=15,y=0.23,substitute(paste(R^2," = ",rsq),list(rsq=round(summary(fledge.fit4)$r.squared,digits=2))),cex=1,col="grey20")
#text(x=16,y=0.35,substitute(paste(R^2," = ",rsq),list(rsq=round(summary(fledge.fit4.notex)$r.squared,digits=2))),cex=1,col="grey20")
#text(x=12,y=0.15,substitute(paste(R^2," = ",rsq),list(rsq=sprintf("%.2f",round(summary(fledge.fit4.all)$r.squared,digits=2)))),cex=1,col="grey20")
legend(x=-0.5, y=0.470, substitute(paste("Highest genetic contributors / group, ", R^2," = ",rsq),list(rsq=round(summary(fledge.fit4)$r.squared,digits=2))),cex=1.025,col="grey20",lty=1,bty='n',lwd=2.3)
legend(x=-0.5, y=0.445, substitute(paste("Highest without Texaco, ", R^2," = ",rsq),list(rsq=round(summary(fledge.fit4.notex)$r.squared,digits=2))),cex=1.025,col="grey20",lty=2,bty='n',lwd=2.3)
legend(x=-0.5, y=0.420, substitute(paste("All ind., ", R^2," = ",rsq),list(rsq=sprintf("%.2f",round(summary(fledge.fit4.all)$r.squared,digits=2)))),cex=1.025,col="grey20",lty=3,bty='n',lwd=3.3)
#legend(x=-0.5, y=0.475, "Highest genetic contributors / group", cex=1,col="grey20",lty=1,bty='n',lwd=2.3)
#legend(x=-0.5, y=0.45, "Highest without Texaco",cex=1,col="grey20",lty=5,bty='n',lwd=2.3)
#legend(x=-0.5, y=0.425, "All ind.",cex=1,col="grey20",lty=3,bty='n',lwd=2.3)
#text(x=x4, y=jitter(dfmax[[4]]$r.skew,amount=0.01), dfmax[[4]]$ID)

dev.off()

# check distribution of errors

#pdf(file='/home/tyler/Dropbox/research/jay/mosaic/popgen/relatedness/plots/skew_fledging_model_assessment.pdf')

res4 <- resid(fledge.fit4)
qqnorm(res4, xlab="Theoretical quantiles", ylab="Observed quantiles", main="max skew ~ fledging", cex.lab=1.3, cex.axis=1.3, cex=1.2); qqline(res4, lty=2,col="gray40")
plot(fitted(fledge.fit4), res4, xlab="Fitted values", ylab="Residuals", main="max skew ~ fledging", cex.lab=1.3, cex.axis=1.3, cex=1.2); abline(h=0, lty=2, col="gray40")

shapiro.test(res4)

#	Shapiro-Wilk normality test
#
#data:  res4
#W = 0.97824, p-value = 0.9757
# We fail to reject that the residuals are not normally distributed


res4.notex <- resid(fledge.fit4.notex)
qqnorm(res4.notex, xlab="Theoretical quantiles", ylab="Observed quantiles", main="max skew (Texaco excluded) ~ fledging", cex.lab=1.3, cex.axis=1.3, cex=1.2); qqline(res4.notex, lty=2,col="gray40")
plot(fitted(fledge.fit4.notex), res4.notex, xlab="Fitted values", ylab="Residuals", main="max skew (Texaco excluded) ~ fledging", cex.lab=1.3, cex.axis=1.3, cex=1.2); abline(h=0, lty=2, col="gray40")

shapiro.test(res4.notex)

#	Shapiro-Wilk normality test
#
#data:  res4.notex
#W = 0.97249, p-value = 0.9105
# Fail to reject that the residuals are not normally distribruted

res4.all <- resid(fledge.fit4.all)
qqnorm(res4.all, xlab="Theoretical quantiles", ylab="Observed quantiles", main="skew ~ fledging", cex.lab=1.3, cex.axis=1.3, cex=1.2); qqline(res4.all, lty=2,col="gray40")
plot(fitted(fledge.fit4.all), res4.all, xlab="Fitted values", ylab="Residuals", main="skew ~ fledging", cex.lab=1.3, cex.axis=1.3, cex=1.2); abline(h=0, lty=2, col="gray40")

dev.off()

shapiro.test(res4.all)

#	Shapiro-Wilk normality test
#
#data:  res4.all
#W = 0.91055, p-value = 0.02039
# Reject that the residuals are normally distributed

## Fledging and skew quantiles among translocated individuals
meta <- read.table('M4_sequenced_FSJsamples_metadata.txt',head=TRUE)
trans <- meta[which(meta$type == "T" | meta$LAB_ID == "I_049"),] # isolate translocated individuals (including I_049)

# fledging quantiles
fledge.ecdf <- ecdf(trans$total_fledged)

fledge.ecdf(trans$total_fledged[which(trans$LAB_ID == "T_071")])
#[1] 1

fledge.ecdf(trans$total_fledged[which(trans$LAB_ID == "T_099")])
# [1] 0.7857143

fledge.ecdf(trans$total_fledged[which(trans$LAB_ID == "T_067")])
# [1] 0.8571429

fledge.ecdf(trans$total_fledged[which(trans$LAB_ID == "T_070")])
# [1] 0.8571429

fledge.ecdf(trans$total_fledged[which(trans$LAB_ID == "T_081")])
# [1] 1

fledge.ecdf(trans$total_fledged[which(trans$LAB_ID == "T_101")]) # Texaco
# [1] 0.8928571

fledge.ecdf(trans$total_fledged[which(trans$LAB_ID == "T_075")]) # Texaco
# [1] 0.6785714

fledge.ecdf(trans$total_fledged[which(trans$LAB_ID == "T_073")]) # Texaco
# [1] 0.6071429

# relatedness skew quantiles

skew.ecdf <- ecdf(trans$r_skew_024)

skew.ecdf(trans$r_skew_024[which(trans$LAB_ID == "T_081")])
# [1] 0.8333333

skew.ecdf(trans$r_skew_024[which(trans$LAB_ID == "T_070")])
# [1] 0.5

## Genetic skew against translocation information
# note "HY" (hatch year) in age of introduction have been recoded as zero.

meta <- read.table('/home/tyler/Dropbox/research/jay/mosaic/metadata/M4_sequenced_FSJsamples_metadata.txt',head=TRUE,sep="\t")
meta$popcol <- popcolor(meta)

# set months since translocation

month <- c("January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December")
dates <- NULL
month.count <- 0
for (i in seq(from=min(meta$translocation_year,na.rm=TRUE), to=max(meta$translocation_year,na.rm=TRUE), by=1)) {
	for (j in month) {
		dates <- rbind(dates, data.frame(time=paste0(i,"_",j), months_since = month.count))
		month.count <- month.count+1
	}
}

meta$trans_chrono <- sapply(paste0(meta$translocation_year, "_", meta$translocation_month), function(x,df){idx = ifelse(x == "NA_NA", NA, which(df$time == x)); val = ifelse(is.na(idx), NA, df$months_since[idx]); return(val)}, USE.NAMES=FALSE, df=dates)

meta$trans_chrono <- meta$trans_chrono - min(meta$trans_chrono, na.rm = TRUE) # scale to first introduction

# set resident translocation year to one year before first translocation
meta$trans_chrono[which(meta$pop == "Resident")] = -1

# subset of individuals with highest skew stat per family group (i.e. the most likely reproducers)

site1.1 <- c("T_071", "T_090", "T_097") 
site12.1 <- c("T_068","T_089")
site13.1 <- c("T_079", "T_081", "T_083", "T_084", "T_086", "T_100") # Site 13 group 1
site13.2 <- c("T_070", "T_074", "T_077", "T_078", "T_080") # Site 13 group 2
site13.3 <- c("T_067", "T_082", "T_098", "I_049") # Site 13 group 3
tex.1 <- c("T_073","T_075","T_101")
wellres.1 <- c("E_030", "E_036", "E_037", "E_039", "E_041") # Wellfield residents group 1
wellres.2 <- c("I_045", "I_046", "E_032", "E_035", "E_038", "E_042")
wellres.3 <- c("I_050", "E_034")

groups <- list(site1.1, site12.1, site13.1, site13.2, site13.3, tex.1, wellres.1, wellres.2, wellres.3)

maxidx <- NULL
group.ind <- NULL

set.seed(4642)

for (i in 1:length(groups)) {
	subdf <- meta[which(meta$LAB_ID %in% groups[[i]]),]
	idx <- which(subdf$r_skew_024 == max(subdf$r_skew_024, na.rm=TRUE))
	maxind <- subdf$LAB_ID[ifelse(length(idx) > 1, sample(x=idx,size=1), idx)] # randomly sample 1 individual when there are ties for highest skew
	maxidx <- c(maxidx, which(meta$LAB_ID == maxind))
	group.ind <- c(group.ind, groups[[i]])
}

maxrho.df <- rbind(meta[maxidx,], meta[which(meta$LAB_ID %in% group.ind == FALSE & meta$pop != "Contemporary"),])
maxrho.df.c <- meta[which(meta$LAB_ID %in% maxrho.df$LAB_ID == FALSE & meta$pop != "Contemporary"),]

# year of introduction without residents

maxrho.df.nores <- maxrho.df[-which(maxrho.df$pop == "Resident"),]
maxrho.df.nores.c <- maxrho.df.c[-which(maxrho.df.c$pop == "Resident"),]
maxrho.df.nores.comb <- rbind(maxrho.df.nores, maxrho.df.nores.c)

intro.nores.fit <- lm(r_skew_024 ~ trans_chrono, data=maxrho.df.nores)

#Call:
#lm(formula = r_skew_024 ~ trans_chrono, data = maxrho.df.nores)
#
#Residuals:
#     Min       1Q   Median       3Q      Max 
#-0.17048 -0.09192 -0.03888  0.05317  0.26959 
#
#Coefficients:
#              Estimate Std. Error t value Pr(>|t|)
#(Intercept)  0.1148004  0.0857586   1.339    0.210
#trans_chrono 0.0005923  0.0014088   0.420    0.683
#
#Residual standard error: 0.1461 on 10 degrees of freedom
#  (14 observations deleted due to missingness)
#Multiple R-squared:  0.01737,	Adjusted R-squared:  -0.08089 
#F-statistic: 0.1768 on 1 and 10 DF,  p-value: 0.6831

intro.nores.fit.all <- lm(r_skew_024 ~ trans_chrono, data=maxrho.df.nores.comb)

#summary(intro.nores.fit.all)

#Call:
#lm(formula = r_skew_024 ~ trans_chrono, data = maxrho.df.nores.comb)
#
#Residuals:
#     Min       1Q   Median       3Q      Max 
#-0.16498 -0.07895 -0.01447  0.04724  0.29670 
#
#Coefficients:
#               Estimate Std. Error t value Pr(>|t|)   
#(Intercept)   0.1757963  0.0497186   3.536  0.00161 **
#trans_chrono -0.0009011  0.0007663  -1.176  0.25071   
#---
#Signif. codes:  0 *** 0.001 ** 0.01 * 0.05 . 0.1   1
#
#Residual standard error: 0.1172 on 25 degrees of freedom
#  (16 observations deleted due to missingness)
#Multiple R-squared:  0.05241,	Adjusted R-squared:  0.01451 
#F-statistic: 1.383 on 1 and 25 DF,  p-value: 0.2507

pdf(file='/home/tyler/Dropbox/research/jay/mosaic/popgen/relatedness/plots/skew_vs_trans_chronology.pdf')

set.seed(2496)
par(mar=c(5,5.2,4,2)+0.5)
x.intro = jitter(maxrho.df.nores$trans_chrono,amount=0.7)
x.intro[which(x.intro < 0)] <- 0
plot(x=x.intro, y=maxrho.df.nores$r_skew_024, pch=19, cex=1.5, col=maxrho.df.nores$popcol, ylab=expression(paste("Genetic skew (",hat(rho)[0.024],")")), xlab="Translocation period (months)", xlim=c(0,max(meta$trans_chrono, na.rm=TRUE)), cex.lab=1.6, cex.axis=1.4, ylim=c(0,0.45),type="n")
abline(coefficients(intro.nores.fit)[1], coefficients(intro.nores.fit)[2], col="grey60", lwd=2.3)
abline(coefficients(intro.nores.fit.all)[1], coefficients(intro.nores.fit)[2], col="grey60", lwd=3.3, lty=3)
x.intro.c <- jitter(maxrho.df.nores.c$trans_chrono,amount=0.7)
x.intro.c[which(x.intro.c < 0)] <- 0 
points(x=x.intro.c, y=maxrho.df.nores.c$r_skew_024, pch=1, col=maxrho.df.nores.c$popcol, cex=2, lwd=3)
points(x=x.intro, y=maxrho.df.nores$r_skew_024, pch=19, col=alpha(maxrho.df.nores$popcol,0.8), cex=2)
points(x=x.intro, y=maxrho.df.nores$r_skew_024, pch=1, col=maxrho.df.nores$popcol, cex=2, lwd=3)
legend(x=-0.5, y=0.53, substitute(paste("Highest genetic contributors / group, ", R^2," = ",rsq),list(rsq=round(summary(intro.nores.fit)$r.squared,digits=2))),cex=1.025,col="grey20",lty=1,bty='n',lwd=2.3,xpd=TRUE)
legend(x=-0.5, y=0.50, substitute(paste("All ind., ", R^2," = ",rsq),list(rsq=round(summary(intro.nores.fit.all)$r.squared,digits=2))),cex=1.025,col="grey20",lty=1,bty='n',lwd=2.3,xpd=TRUE)
text(x=x.intro, y=jitter(maxrho.df.nores$r_skew_024,amount=0.03), maxrho.df.nores$LAB_ID)

dev.off()

res.trans_chron <- resid(intro.nores.fit)
shapiro.test(res.trans_chron)

#	Shapiro-Wilk normality test
#
#data:  res.trans_chron
#W = 0.90173, p-value = 0.167

res.trans_chron.all <- resid(intro.nores.fit.all)
shapiro.test(res.trans_chron.all)

#	Shapiro-Wilk normality test
#
#data:  res.trans_chron.all
#W = 0.93123, p-value = 0.07409


# year of introduction with residents

maxrho.df.comb <- rbind(maxrho.df, maxrho.df)

intro.fit <- lm(r_skew_024 ~ trans_chrono, data=maxrho.df)

#summary(intro.fit)

#Call:
#lm(formula = r_skew_024 ~ trans_chrono, data = maxrho.df)
#
#Residuals:
#     Min       1Q   Median       3Q      Max 
#-0.17006 -0.07472 -0.01828  0.05502  0.26941 
#
#Coefficients:
#              Estimate Std. Error t value Pr(>|t|)  
#(Intercept)  0.1159808  0.0397999   2.914   0.0101 *
#trans_chrono 0.0005753  0.0008007   0.719   0.4828  
#---
#Signif. codes:  0 *** 0.001 ** 0.01 * 0.05 . 0.1   1
#
#Residual standard error: 0.1199 on 16 degrees of freedom
#  (14 observations deleted due to missingness)
#Multiple R-squared:  0.03126,	Adjusted R-squared:  -0.02928 
#F-statistic: 0.5164 on 1 and 16 DF,  p-value: 0.4828


intro.fit.all <- lm(r_skew_024 ~ trans_chrono, data=maxrho.df.comb)

#summary(intro.fit.all)

#Call:
#lm(formula = r_skew_024 ~ trans_chrono, data = maxrho.df.comb)
#
#Residuals:
#     Min       1Q   Median       3Q      Max 
#-0.17006 -0.07973 -0.01828  0.05824  0.26941 
#
#Coefficients:
#              Estimate Std. Error t value Pr(>|t|)    
#(Intercept)  0.1159808  0.0273025   4.248 0.000158 ***
#trans_chrono 0.0005753  0.0005493   1.047 0.302260    
#---
#Signif. codes:  0 *** 0.001 ** 0.01 * 0.05 . 0.1   1
#
#Residual standard error: 0.1163 on 34 degrees of freedom
#  (28 observations deleted due to missingness)
#Multiple R-squared:  0.03126,	Adjusted R-squared:  0.002771 
#F-statistic: 1.097 on 1 and 34 DF,  p-value: 0.3023


set.seed(2496)
par(mar=c(5,5.2,4,2)+0.5)
x.intro = jitter(maxrho.df$trans_chrono,amount=0.7)
#x.intro[which(x.intro < 0)] <- 0
plot(x=x.intro, y=maxrho.df$r_skew_024, pch=19, cex=1.5, col=maxrho.df$popcol, ylab=expression(paste("Genetic skew (",hat(rho)[0.024],")")), xlab="Translocation period (months)", xlim=c(-1,max(meta$trans_chrono, na.rm=TRUE)), cex.lab=1.6, cex.axis=1.4, ylim=c(0,0.45),type="n")
abline(coefficients(intro.fit)[1], coefficients(intro.fit)[2], col="grey60", lwd=2.3)
abline(coefficients(intro.fit.all)[1], coefficients(intro.fit)[2], col="grey60", lwd=3.3, lty=3)
x.intro.c <- jitter(maxrho.df.c$trans_chrono,amount=0.7)
#x.intro.c[which(x.intro.c < 0)] <- 0 
points(x=x.intro.c, y=maxrho.df.c$r_skew_024, pch=1, col=maxrho.df.c$popcol, cex=2, lwd=3)
points(x=x.intro, y=maxrho.df$r_skew_024, pch=19, col=alpha(maxrho.df$popcol,0.8), cex=2)
points(x=x.intro, y=maxrho.df$r_skew_024, pch=1, col=maxrho.df$popcol, cex=2, lwd=3)
legend(x=-0.5, y=0.53, substitute(paste("Highest genetic contributors / group, ", R^2," = ",rsq),list(rsq=round(summary(intro.fit)$r.squared,digits=2))),cex=1.025,col="grey20",lty=1,bty='n',lwd=2.3,xpd=TRUE)
legend(x=-0.5, y=0.50, substitute(paste("All ind., ", R^2," = ",rsq),list(rsq=round(summary(intro.fit.all)$r.squared,digits=2))),cex=1.025,col="grey20",lty=1,bty='n',lwd=2.3,xpd=TRUE)
text(x=x.intro, y=jitter(maxrho.df$r_skew_024,amount=0.03), maxrho.df$LAB_ID)



## ROH

The following procedure was carried out for running bcftools without --rec-rate (no recombination, results in 
/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/allsamp_af/no_recomb) and with --rec-rate 1.3e-8 (constant recombination 
rate of 1.3e-8 per site, results in /mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/allsamp_af/const_recomb)

icer_workdir='/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/allsamp_af/train'

$ for i in {1..87}; do SAMP=$(sed -n "${i}p" /mnt/research/Fitz_Lab/projects/mosaic/mosiac_ids.txt); grep "^VT" fsj_mosaic_biallelic_snps_main_autosomes_qc_${SAMP}.viterbi | tail -n 1 | cut -f2,7,9 >> fsj_mosaic_biallelic_snps_main_autosomes_qc_hmm_pars.txt; done
$ printf "sample\tchromosome\tstart\tend\tlength_bp\tn_snps\tavg_quality\n" > fsj_mosaic_biallelic_snps_main_autosomes_qc.hmm.roh.regions
$ for i in {1..87}; do SAMP=$(sed -n "${i}p" /mnt/research/Fitz_Lab/projects/mosaic/mosiac_ids.txt); grep "^RG" fsj_mosaic_biallelic_snps_main_autosomes_qc_${SAMP}.hmm.roh | cut -f2- >> fsj_mosaic_biallelic_snps_main_autosomes_qc.hmm.roh.regions; done

R

meta <- read.table('/home/tyler/Dropbox/research/jay/mosaic/metadata/M4_sequenced_FSJsamples_metadata.txt',head=TRUE,sep="\t")
meta$grpcol <- pntcol(meta)

# ROH calculations without recombination

roh.n <- read.table('/home/tyler/Dropbox/research/jay/mosaic/popgen/roh/fsj_mosaic_biallelic_snps_main_autosomes_qc_norecomb.hmm.roh.regions',head=TRUE) # no recombination rate roh
roh.n <- roh.n[which(roh.n$avg_quality >= 20),]

# calculate number of ROH > 1 mb
rohc.count <- NULL
for (id in unique(roh.n$sample)) { rohc.count <- rbind(rohc.count, data.frame(sample=id, n_roh = length(which(roh.n$length_bp[which(roh.n$sample == id)] > 10^6)))) }

#plot

png(file='/home/tyler/Dropbox/research/jay/mosaic/popgen/roh/plots/fsj_mosaic_biallelic_snps_main_autosomes_qc_norecomb.hmm.roh.dist.png', width=14,height=7,units='in',res=120)
par(mar=c(5, 6, 4, 2)+1)
plot(length_bp ~ sample, data=roh.n, las=2, xlab="", ylab="", col=meta$grpcol, outcol=meta$grpcol, xaxt="n")
axis(1, at=1:nrow(rohc.count),labels=rohc.count$sample,las=2,cex.axis=0.8)
title(ylab="ROH length (bp)", outer=FALSE, line=5)
dev.off()

png(file='/home/tyler/Dropbox/research/jay/mosaic/popgen/roh/plots/fsj_mosaic_biallelic_snps_main_autosomes_qc_norecomb.hmm.roh.count.png', width=14,height=7,units='in',res=120)
barplot(rohc.count$n_roh,names.arg=rohc.count$sample,las=2,col=meta$grpcol, ylab="Number ROH longer than 10^6 bp",cex.names=0.8)
dev.off()

# roh calculation assuming constant recombination

roh.c <- read.table('/home/tyler/Dropbox/research/jay/mosaic/popgen/roh/fsj_mosaic_biallelic_snps_main_autosomes_qc_constrecomb.hmm.roh.regions',head=TRUE) # no recombination rate roh
roh.c <- roh.c[which(roh.c$avg_quality >= 20),]

# calculate number of ROH > 1 mb
rohc.count <- NULL
for (id in unique(roh.c$sample)) { rohc.count <- rbind(rohc.count, data.frame(sample=id, n_roh = length(which(roh.c$length_bp[which(roh.c$sample == id)] > 10^6)))) }

#plot

png(file='/home/tyler/Dropbox/research/jay/mosaic/popgen/roh/plots/fsj_mosaic_biallelic_snps_main_autosomes_qc_constcomb.hmm.roh.dist.png', width=14,height=7,units='in',res=120)
par(mar=c(5, 6, 4, 2)+1)
plot(length_bp ~ sample, data=roh.c, las=2, xlab="", ylab="", col=meta$grpcol, outcol=meta$grpcol, xaxt="n")
axis(1, at=1:nrow(rohc.count),labels=rohc.count$sample,las=2,cex.axis=0.8)
title(ylab="ROH length (bp)", outer=FALSE, line=5)
dev.off()

png(file='/home/tyler/Dropbox/research/jay/mosaic/popgen/roh/plots/fsj_mosaic_biallelic_snps_main_autosomes_qc_constrecomb.hmm.roh.count.png', width=14,height=7,units='in',res=120)
barplot(rohc.count$n_roh,names.arg=rohc.count$sample,las=2,col=meta$grpcol, ylab="Number ROH longer than 10^6 bp",cex.names=0.8)
dev.off()


## PRIVATE VARIATION LOSS

icer_workdir='/mnt/ufs18/rs-012/Fitz_Lab/projects/mosaic/variants/vcf/biallelic_snps/private_variants'

# this command prints all sites for which alleles detected in the E population are not found in M4 or T
$ bcftools query -f '%CHROM\t%POS[\t%GT]\n' ../fsj_mosaic_biallelic_snps_main_autosomes_qc.vcf.gz | perl -ne 'chomp($l = $_); @tok = split(/\t/,$l); $chr = shift @tok; $pos = shift @tok; $geno = join(/ /,@tok[28..38]); @alleles = (); push @alleles, 0 if $geno =~ /0/; push @alleles, 1 if $geno =~ /1/; $geno_comp = join(//,@tok[45..86]); $n = 0; foreach $a (@alleles) { $n++ if ($geno_comp !~ /$a/);}; print "$chr\t$pos\n" if ($n);' > historic_wellfield_private_variants.pos

# this command prints all sites for which alleles detected in either M4 or T are not found in E
$ bcftools query -f '%CHROM\t%POS[\t%GT]\n' ../fsj_mosaic_biallelic_snps_main_autosomes_qc.vcf.gz | perl -ne 'chomp($l = $_); @tok = split(/\t/,$l); $chr = shift @tok; $pos = shift @tok; $geno = join(/ /,@tok[45..86]); @alleles = (); push @alleles, 0 if $geno =~ /0/; push @alleles, 1 if $geno =~ /1/; $geno_comp = join(//,@tok[28..38]); $n = 0; foreach $a (@alleles) { $n++ if ($geno_comp !~ /$a/);}; print "$chr\t$pos\n" if ($n);' > historic_T_M4_private_variants.pos

# this command prints all sites for which alleles detected in T are not round in E
$ bcftools query -f '%CHROM\t%POS[\t%GT]\n' ../fsj_mosaic_biallelic_snps_main_autosomes_qc.vcf.gz | perl -ne 'chomp($l = $_); @tok = split(/\t/,$l); $chr = shift @tok; $pos = shift @tok; $geno = join(/ /,@tok[58..86]); @alleles = (); push @alleles, 0 if $geno =~ /0/; push @alleles, 1 if $geno =~ /1/; $geno_comp = join(//,@tok[28..38]); $n = 0; foreach $a (@alleles) { $n++ if ($geno_comp !~ /$a/);}; print "$chr\t$pos\n" if ($n);' > T_variants_not_in_E.pos

# generate 2D-SFS between C and E at sites with historically private wellfield variants

$ angsd -bam ../../map/mosaic_E_bam_list.txt -out historic_wellfield_private_variants_E -GL 1 -doSaf 1 -anc /mnt/research/Fitz_Lab/ref/bird/FSJ_V3/FSJ.V3.fa -minQ 20 -minMapQ 20 -sites ../../variants/vcf/biallelic_snps/private_variants/historic_wellfield_private_variants.pos -rf ../../variants/vcf/biallelic_snps/private_variants/historic_wellfield_private_variants.rf -P 12

$ angsd -bam ../../map/mosaic_C_bam_list.txt -out historic_wellfield_private_variants_C -GL 1 -doSaf 1 -anc /mnt/research/Fitz_Lab/ref/bird/FSJ_V3/FSJ.V3.fa -minQ 20 -minMapQ 20 -sites ../../variants/vcf/biallelic_snps/private_variants/historic_wellfield_private_variants.pos -rf ../../variants/vcf/biallelic_snps/private_variants/historic_wellfield_private_variants.rf -P 12$ realSFS historic_wellfield_private_variants_E.saf.idx historic_wellfield_private_variants_C.saf.idx > historic_wellfield_private_variants_E_vs_C.2dsfs

$ realSFS historic_wellfield_private_variants_E.saf.idx historic_wellfield_private_variants_C.saf.idx > historic_wellfield_private_variants_E_vs_C.2dsfs

R
sfs <- scan('/home/tyler/Dropbox/research/jay/mosaic/popgen/sfs/historic_wellfield_private_variants_E_vs_C.2dsfs')
mat <- matrix(sfs, nrow=2*11+1, ncol=2*28+1)

## spatial analysis of relatedness

R

library(stringr)
gps <- read.csv('/home/tyler/Dropbox/research/jay/mosaic/sampling_map/mosaic_samples_gps.csv')
rank_names <- read.table('/home/tyler/Dropbox/research/jay/mosaic/popgen/relatedness/fsj_mosaic_biallelic_snps_main_autosomes_qc_relatedness_ranked.txt', head=FALSE)
gps.well <- gps[1:39,]
merge_name <- paste(gps.well$LAB_ID, gps.well$site,sep="_")
gps.well$source_ind <- NA
gps.well$source_site <- NA

for (i in 1:nrow(gps.well)) {
	rank_idx <- which(rank_names[,1] == merge_name[i])
	for (j in 2:ncol(rank_names)) {
		if ((i <= 28 && length(grep("^[^C]", rank_names[rank_idx,j])) > 0) || (i > 28 && length(grep("^[^EC]", rank_names[rank_idx,j])) > 0)) {
			relvec = str_split(rank_names[rank_idx,j],"_")[[1]]
			gps.well$source_ind[i] <- paste0(relvec[1], "_", relvec[2])
			gps.well$source_site[i] <- paste(relvec[3:length(relvec)],collapse="_")
			break
		}
	}
}

#write.csv(gps.well,file='~/Dropbox/research/jay/mosaic/sampling_map/mosaic_wellfield_samples_gps.csv',quote=FALSE,row.names=FALSE)

# make gps file for plotting colors on map based on contemporary Wellfeild PCA orientation

gps.c.well <- gps.well[1:28,]
c.covar <- as.matrix(read.table('~/Dropbox/research/jay/mosaic/popgen/pca/fsj_mosaic_biallelic_snps_main_autosomes_qc_C_minmaf2perc.covar',head=FALSE))
c.eig <- eigen(c.covar)

gps.c.well$PC1 <- c.eig$vectors[,1]
gps.c.well$PC2 <- c.eig$vectors[,2]
gps.c.well$PC3 <- c.eig$vectors[,3]
gps.c.well$PC4 <- c.eig$vectors[,4]
gps.c.well$PC5 <- c.eig$vectors[,5]
gps.c.well$PC6 <- c.eig$vectors[,6]
gps.c.well$PC7 <- c.eig$vectors[,7]
gps.c.well$PC8 <- c.eig$vectors[,8]
gps.c.well$PC9 <- c.eig$vectors[,9]
gps.c.well$PC10 <- c.eig$vectors[,10]

#write.csv(gps.c.well,file='~/Dropbox/research/jay/mosaic/sampling_map/mosaic_C_wellfield_samples_gps.csv',quote=FALSE,row.names=FALSE)

## Novogene Quality Assessment
report <- read.csv('/home/tyler/Dropbox/research/jay/mosaic/raw_data/report/X202SC21114224-Z01-F003_final_20220407122035/src/tables/qc_summary_for_R.csv',head=TRUE,sep="\t")

# calculate number of clean reads per sample
df <- NULL

for (id in unique(report$Sample)) { 
   df.tmp <- report[which(report$Sample == id),]
   nreads <- sum(df.tmp$Raw_reads * df.tmp$Effective_percent)
   df <- rbind(df,data.frame(Sample = df.tmp$Sample[1], clean_reads = nreads))
}

min(df$clean_reads)
#[1] 7760778142

max(df$clean_reads)
# [1] 14886796518

median(df$clean_reads)
# [1] 8399727872


### SKEW ANALYSIS

## extract census for only the core population (Mosaic Wellfield + Duette Preserve + Coker Tract) from metadata

workdir='/home/tyler/Dropbox/research/jay/mosaic/metadata/20230512_metadata'

$ R
--- BEGIN R CODE FOR EXTRACTING CORE POP INDIVIDUALS ---
census <- read.csv(/home/tyler/Dropbox/research/jay/mosaic/metadata/20230512_metadata/Longform_Data_05122023.tsv',head=TRUE,sep="\t")
core <- census[which(census$PROPERTY == "MW" | census$PROPERTY == "DUETTE PRESERVE" | census$PROPERTY == "COKER"),]
core.ids <- toupper(unique(core$COLOR_ID)) # unique set of IDs for birds censused in the core region
write.table(data.frame(ID=core.ids),file='/home/tyler/Dropbox/research/jay/mosaic/metadata/20230512_metadata/core_pop/core_pop_color_ids.txt',col.names=FALSE,row.names=FALSE,quote=FALSE)
write.table(core,file='/home/tyler/Dropbox/research/jay/mosaic/metadata/20230512_metadata/core_pop/Longform_Data_05122023_core.tsv',col.names=TRUE,row.names=FALSE,quote=FALSE,sep="\t")

--- END R CODE FOR EXTRACTING CORE POP INDIVIDUALS ---

## make inputs for makePed.pl
wordir='/home/tyler/Dropbox/research/jay/mosaic/pedigree'

# format census data
R
--- BEGIN R CODE FOR FORMATING CENSUS DATA ---
census <- read.csv('/home/tyler/Dropbox/research/jay/mosaic/metadata/20230512_metadata/Longform_Data_05122023.tsv',head=TRUE,sep="\t")
census.sub <- census[which(census$Present == 1),]
write.table(census.sub[,c(1,2,3,4,5,12)],file='/home/tyler/Dropbox/research/jay/mosaic/pedigree/mosaic_census_20230512.tsv',col.names=TRUE,row.names=FALSE,sep="\t",quote=FALSE)
--- END R CODE FOR FORMATTING CENSUS DATA ---

$ cut -f2,3,12 /home/tyler/Dropbox/research/jay/mosaic/metadata/20230512_metadata/CUMULATIVE_NESTING_DATA_FINAL_05122023.tsv | sed -s 's/\t/,/g' > cumulative_nesting_data_20230512.csv
$ cut -f1,2,5,10,16,17 /home/tyler/Dropbox/research/jay/mosaic/metadata/20230512_metadata/JAYID_05122023.tsv | sed -s 's/\t/,/g' > jayid_20230512.csv

## Expected Genetic contribution based on the pedigree

# make pedigree input for nadiv R package

workdir='/home/tyler/Dropbox/research/jay/mosaic/pedigree'

$ ./makePed.pl jayid_20230512.csv cumulative_nesting_data_20230512.csv mosaic_census_20230512.tsv 2> ./troubleshoot/mosaic_ped_20230512_raw_warnings.txt > mosaic_ped_20230512_raw.csv

# manually modified in some instances the following individuals per Lauren's notes:
SR-LK (1063-09904): cohort_last set to 2004 per Lauren's notes "banded as HY august 2004 and never seen again".
OK-OS (1573-41864): Did not change missing survival data as I only see it recorded in Site 18. Luaren's notes "banded June 2004 and not seen on the July 2004 census or thereafter".
GF-SG (1713-54398): set cohort and cohort_last to 2016 per Lauren's notes "banded as immigrant in 2016 and never observed on a census" and this bird nested in DP.
PF-LS (1713-82944): Did not change missing survival data per Lauren's notes "rutland bird - never on census"
GF-AS (1713-82946): Did not change missing surivial data per Lauren's notes "rutland bird - never on census"
LDZ-F (1873-26844): set cohort_last to individuals year class (2021) per Lauren's notes "banded as Hy and never seen again"
BDZ-F (1873-26845): set cohort_last to individuals year class (2021) per Lauren's notes "banded as Hy and never seen again"
WDZ-F (1873-26846): set cohort_last to individuals year class (2021) per Lauren's notes "banded as Hy and never seen again"

# set cohort and population for pedigree individuals to year of translocation and donor patch respectively
R

--- BEGIN R CODE FOR RECONCILING TRANSLOCATION WITH PEDIGREE DATA ---

ped <- read.csv('/home/tyler/Dropbox/research/jay/mosaic/pedigree/mosaic_ped_20230512_raw.csv',head=TRUE, na.strings="*")
trans <- read.csv('/home/tyler/Dropbox/research/jay/mosaic/metadata/Translocated_Jay_Individual_Statistics.tsv',head=TRUE,sep="\t",na.strings="*")
trans$COLOR_ID[which(trans$COLOR_ID == "PK-AS")] <- "PK-OS" # Laurens notes in the cumulative nest data say that "PK-AS and PK-OS are the same bird. Did not have any more orange bands at the time of capture and replaced with azure".
trans$Donor_Patch <- gsub(" ", "_", trans$Donor_Patch)
for (i in 1:nrow(trans)) {
	id <- trans$COLOR_ID[i]
	yr <- trans$Year_Translocated[i]
	patch <- trans$Donor_Patch[i]
	idx <- which(ped$ID == id)
	if (length(idx) > 0) {
		ped$COHORT[idx] = yr
		ped$POPULATION[idx] = patch
	} else {
		print(paste0("Could not find ", id, " in pedigree"))
	}
}

# if last observation year is missing set it to the first observation year to indicate bird was censused once and never seen again
for (i in 1:nrow(ped)) {
	if (!is.na(ped$COHORT[i]) && is.na(ped$COHORT_LAST[i])) ped$COHORT_LAST[i] = ped$COHORT[i]
}

# write full M4 pedigree
write.table(ped,file='/home/tyler/Dropbox/research/jay/mosaic/pedigree/mosaic_ped_20230512.csv',col.names=TRUE,row.names=FALSE,quote=FALSE,na="*",sep=",")
write.table(ped,file='/home/tyler/Dropbox/research/jay/mosaic/pedigree/mosaic_ped_20230512.tsv',col.names=TRUE,row.names=FALSE,quote=FALSE,na="*",sep="\t")

# write core population pedigree
core <- ped[which(!is.na(ped$COHORT)),] # individuals never censused in (i.e. part of) the Core Region will have missing COHORT because this is the first time censused in the Core

write.table(core,file='/home/tyler/Dropbox/research/jay/mosaic/pedigree/cr_ped_20230512.csv',col.names=TRUE,row.names=FALSE,quote=FALSE,na="*",sep=",")
write.table(core,file='/home/tyler/Dropbox/research/jay/mosaic/pedigree/cr_ped_20230512.tsv',col.names=TRUE,row.names=FALSE,quote=FALSE,na="*",sep="\t")

--- END R CODE FOR RECONCILING TRANSLOCATION WITH PEDIGREE DATA ---

# make additive genetic relatedness matrix based on pedigree

--- start R code for pedigree-based relatedness matrix ---

R

# load required packages
library(nadiv)

# read in and format pedigree
# using full M4 pedigree so potentially account for relatdness among CR founders
ped.raw <- read.csv('/home/tyler/Dropbox/research/jay/mosaic/pedigree/mosaic_ped_20230512.csv',head=TRUE)

ped2 <- prepPed(ped.raw[,1:4], gender='SEX', check=TRUE)
ped2 <- ped2[,1:3]

# calculate additive genetic matrix
r_mat <- makeA(ped2)
r_mat2 <- as.matrix(r_mat) # convert sparse dsCMatrix into normal matrix

# ouput full m4 matrix
write.table(r_mat2,file='/home/tyler/Dropbox/research/jay/mosaic/pedigree/mosaic_ped_20230512_relatedness_matrix.txt',col.names=TRUE,row.names=FALSE,quote=FALSE)

# subset matrix down to only Core Region individuals
core <- read.table('/home/tyler/Dropbox/research/jay/mosaic/pedigree/cr_ped_20230512.tsv',head=TRUE)
core.idx <- which(colnames(r_mat2) %in% core$ID == TRUE)
r_mat.core <- r_mat2[core.idx,core.idx]
write.table(r_mat.core,file='/home/tyler/Dropbox/research/jay/mosaic/pedigree/cr_ped_20230512_relatedness_matrix.txt',col.names=TRUE,row.names=FALSE,quote=FALSE)

--- end R code for pedigree-based relatedness matrix ---

## calculate expected genetic contribution in 2021 cohort with relateStats

workdir='/home/tyler/Dropbox/research/jay/mosaic/pedigree'

# make inputs for relateStats
R

--- begin R code for making relateStats inputs ---

jaymeta <- read.csv('~/Dropbox/research/jay/mosaic/metadata/20230512_metadata/JAYID_05122023.tsv',head=TRUE,sep="\t")
jaymeta$COLOR_ID <- toupper(jaymeta$COLOR_ID)
core <- read.table('~/Dropbox/research/jay/mosaic/pedigree/cr_ped_20230512.tsv',head=TRUE) # for screening individuals that were not present in the Core Region
ind.e <- data.frame(ID=c("SW-RK", "SW-OKB", "SW-LK", "SR-WK", "SW-BK", "K-SRB")) # individuals classified as Residents in the genetic data and LR in the jayID metadata


# make file of T and IE ancestors
anc1 <- data.frame(ID=jaymeta$COLOR_ID[which(jaymeta$Biological_Origin_Status == "T" | jaymeta$Biological_Origin_Status == "IE")])
anc1 <- rbind(anc1,ind.e)
anc1.core <- data.frame(ID = anc1$ID[which(anc1$ID %in% core$ID)])
write.table(anc1.core,file='/home/tyler/Dropbox/research/jay/mosaic/pedigree/relateStat_inputs/CR_T_IE_ancestors_20230512.txt',col.names=FALSE,row.names=FALSE,quote=FALSE)

# make file of T, IE, and I ancestors
anc2 <- data.frame(ID=jaymeta$COLOR_ID[which(jaymeta$Biological_Origin_Status == "T" | jaymeta$Biological_Origin_Status == "IE" | jaymeta$Biological_Origin_Status == "I")])
anc2 <- rbind(anc2, ind.e)
anc2.band <- anc2$ID[-grep("UNBAND",anc2$ID)]
anc2.core <- data.frame(ID=anc2.band[-which(anc2.band %in% core$ID == FALSE)])
write.table(anc2.core,file='/home/tyler/Dropbox/research/jay/mosaic/pedigree/relateStat_inputs/CR_T_IE_I_ancestors_20230512.txt',col.names=FALSE,row.names=FALSE,quote=FALSE)

# make file of sequenced contemporary color IDs

seqmeta <- read.table('~/Dropbox/research/jay/mosaic/metadata/M4_sequenced_FSJsamples_metadata.txt',head=TRUE,sep="\t")
c_seq_ids <- unname(sapply(seqmeta$USFWS_ID[which(seqmeta$pop == "Contemporary")],function(x,df){df$COLOR_ID[which(df$FEDERAL_ID == x)]},df=jaymeta))
write.table(data.frame(id=c_seq_ids),file='/home/tyler/Dropbox/research/jay/mosaic/pedigree/relateStat_inputs/CR_sequenced_contemporary_ids_20230512.txt',col.names=FALSE,row.names=FALSE,quote=FALSE)

# make files of local recruits (LR) by year class
jaymeta$YEAR_CLASS[which(jaymeta$YEAR_CLASS == "Unknown_Adult" | jaymeta$YEAR_CLASS == "unknown" | jaymeta$YEAR_CLASS == "*")] <- NA # mask unknown year classes
jaymeta$YEAR_CLASS <- as.numeric(jaymeta$YEAR_CLASS)
lr <- jaymeta[which(jaymeta$Biological_Origin_Status == "LR"),] # subset of local recruits
lr <- lr[which(lr$Natal_Patch == "MW" | lr$Natal_Patch == "DP" | lr$Natal_Patch == "COKER"),] # ensure all individuals were born in Core Region
lr <- lr[-grep("UNBAND|MWUUNB",lr$COLOR_ID),] # remove unbanded individuals

for (i in min(lr$YEAR_CLASS,na.rm=TRUE):max(lr$YEAR_CLASS,na.rm=TRUE)){
	id <- lr$COLOR_ID[which(lr$YEAR_CLASS == i)]
	if (length(id) > 0 ) {
		write.table(data.frame(ID=id),file=paste0('/home/tyler/Dropbox/research/jay/mosaic/pedigree/relateStat_inputs/CR_LR_ids_20230512_',i,'.txt'),col.names=FALSE,row.names=FALSE,quote=FALSE)
	}
}

--- end R code for making relateStats inputs ---

# exclude unbanded individuals from list of ancestors
# grep -i -v UNBANDED ./relateStat_inputs/MW_T_IE_I_ancestors_20230512.txt > ./relateStat_inputs/MW_T_IE_I_banded_ancestors_20230512.txt

# NOTE: All of the following samples except RSW-K, were considered "E" in the genetic analyses were missing from the T, IE, and I ancestors so 
# were manually added to /home/tyler/Dropbox/research/jay/mosaic/pedigree/relateStat_inputs/CR_T_IE_ancestors_20230512.txt and MW_T_IE_I_ancestors_20230512.txt
SW-RK (LR)
SW-OKB (LR)
SW-LK (LR)
SR-WK (LR)
SW-BK (LR)
K-SRB (LR)
RSW-K (Donor Population, T_072 in the genetic data) was not translocated into the Core Region. This bird was from Site 1B and immigrated into Little Manatee State Park (which is not part of the Core)

## calculate contributions from Mosaic pedigree with relateStats

workdir='/home/tyler/Dropbox/research/jay/mosaic/pedigree/'

# Calculate contribution of T, IE, and I ancestors to population from 2002 (oldest cohort) to 2022 (most recent cohort)

$ for i in {2002..2022}; do echo "$i"; ~/code_projects/PopGenomicsTools/relateStats --pedstat 1 --ped cr_ped_20230512.tsv --rmat cr_ped_20230512_relatedness_matrix.txt --anc ./relateStat_inputs/CR_T_IE_I_ancestors_20230512.txt --time2 "$i" --draw --out "./results/pop_temporal/T_IE_I_20230512_${i}_pop_contribution" 2> "./results/pop_temporal/T_IE_I_20230512_${i}_pop_contribution.log"; wait; done

# Calculate contribution of T and IE ancestors to population from 2002 to 2022

$ for i in {2002..2022}; do echo "$i"; ~/code_projects/PopGenomicsTools/relateStats --pedstat 1 --ped cr_ped_20230512.tsv --rmat cr_ped_20230512_relatedness_matrix.txt --anc ./relateStat_inputs/CR_T_IE_ancestors_20230512.txt --time2 "$i" --draw --out "./results/pop_temporal/T_IE_20230512_${i}_pop_contribution" 2> "./results/pop_temporal/T_IE_20230512_${i}_pop_contribution.log"; wait; done

# Calculate contribution of T, IE, and I ancestors to local recruits born in 2004 (first local recruit) to 2022 (latest local recruit cohort)

$ for i in {2004..2022}; do COHORT_FILE="./relateStat_inputs/CR_LR_ids_20230512_${i}.txt"; echo "$COHORT_FILE"; ~/code_projects/PopGenomicsTools/relateStats --pedstat 1 --ped cr_ped_20230512.tsv --rmat cr_ped_20230512_relatedness_matrix.txt --anc ./relateStat_inputs/CR_T_IE_I_ancestors_20230512.txt --cohort "$COHORT_FILE" --draw --out "./results/lr_temporal/T_IE_I_20230512_to_${i}_LR_contribution" 2> "./results/lr_temporal/T_IE_I_20230512_to_${i}_LR_contribution.log"; wait; done

# Calculate contribution of T and IE ancestors to local recruits born in 2004 (first local recruit) to 2022 (latest local recruit cohort)

$ for i in {2004..2022}; do COHORT_FILE="./relateStat_inputs/CR_LR_ids_20230512_${i}.txt"; echo "$COHORT_FILE"; ~/code_projects/PopGenomicsTools/relateStats --pedstat 1 --ped cr_ped_20230512.tsv --rmat cr_ped_20230512_relatedness_matrix.txt --anc ./relateStat_inputs/CR_T_IE_ancestors_20230512.txt --cohort "$COHORT_FILE" --draw --out "./results/lr_temporal/T_IE_20230512_to_${i}_LR_contribution" 2> "./results/lr_temporal/T_IE_20230512_to_${i}_LR_contribution.log"; wait; done

# Calculate contribution of T, IE, and I ancestors to sequenced contemporary individuals

$ ~/code_projects/PopGenomicsTools/relateStats --pedstat 1 --ped cr_ped_20230512.tsv --rmat cr_ped_20230512_relatedness_matrix.txt --anc ./relateStat_inputs/CR_T_IE_I_ancestors_20230512.txt --cohort ./relateStat_inputs/CR_sequenced_contemporary_ids_20230512.txt --draw --out ./results/sequenced_contemporary/T_IE_I_20230512_to_seq_contemporary 2> ./results/sequenced_contemporary/T_IE_I_20230512_to_seq_contemporary.log

# Calculate contribution of T and IE ancestors to sequenced contemporary individuals

$ ~/code_projects/PopGenomicsTools/relateStats --pedstat 1 --ped cr_ped_20230512.tsv --rmat cr_ped_20230512_relatedness_matrix.txt --anc ./relateStat_inputs/CR_T_IE_ancestors_20230512.txt --cohort ./relateStat_inputs/CR_sequenced_contemporary_ids_20230512.txt --draw --out ./results/sequenced_contemporary/T_IE_20230512_to_seq_contemporary 2> ./results/sequenced_contemporary/T_IE_20230512_to_seq_contemporary.log

## calculate contributions to Contemporary sample based on genomic data

workdir='/home/tyler/Dropbox/research/jay/mosaic/popgen/relatedness'

Skew analaysis involving all sequenced individuals

$ ~/code_projects/PopGenomicsTools/relateStats --skewstat 1 --rmat fsj_mosaic_biallelic_snps_main_autosomes_qc_relatedness_matrix_relateStats_input.txt --anc MW_founders_list.txt --cohort MW_contemporary_list.txt --background_r 0.0243058 --out ./skew/T_E_I_M4_to_contemporary_contributions_c0.0243058

$ ~/code_projects/PopGenomicsTools/relateStats --skewstat 3 --rmat fsj_mosaic_biallelic_snps_main_autosomes_qc_relatedness_matrix_relateStats_input.txt --anc MW_founders_list.txt --cohort MW_contemporary_list.txt --background_r 0.0243058 --out ./skew/T_E_I_M4_to_contemporary_contributions_c0.0243058

Skew analysis with only the Core Region individuals

R
--- BEGIN R CODE FOR SUBSETTING GENETIC RELATEDNESS MATRIX ---
rmat <- as.matrix(read.table('/home/tyler/Dropbox/research/jay/mosaic/popgen/relatedness/fsj_mosaic_biallelic_snps_main_autosomes_qc_relatedness_matrix_relateStats_input.txt', head=TRUE))
idmap <- read.csv('/home/tyler/Dropbox/research/jay/mosaic/metadata/jayid_map_20230512.txt',head=TRUE,sep="\t")
core <- read.table('/home/tyler/Dropbox/research/jay/mosaic/pedigree/cr_ped_20230512.tsv',head=TRUE)
core.anc <- read.table('/home/tyler/Dropbox/research/jay/mosaic/pedigree/relateStat_inputs/CR_T_IE_ancestors_20230512.txt',head=FALSE) # T, IE
core.anc2 <- read.table('/home/tyler/Dropbox/research/jay/mosaic/pedigree/relateStat_inputs/CR_T_IE_I_ancestors_20230512.txt',head=FALSE) # T, IE, I
colnames(rmat) <- toupper(unname(sapply(colnames(rmat),function(x,df){df$COLOR_ID[which(df$LAB_ID == x)]},df=idmap))) # convert relatedness IDs to COLOR_IDs
idx <- which(colnames(rmat) %in% core$ID)
rmat.sub <- rmat[idx,idx]
seq.ids <- colnames(rmat)

# write relatedness matrix containing only Core Region individuals
write.table(rmat.sub,file='/home/tyler/Dropbox/research/jay/mosaic/popgen/relatedness/fsj_mosaic_biallelic_snps_main_autosomes_qc_relatedness_matrix_relateStats_input_CR.txt',col.names=TRUE,row.names=FALSE,quote=FALSE)

# Make lists of sequencecd ancestors and contemporary individuals
# T, IE
write.table(data.frame(ID=seq.ids[which(seq.ids %in% core.anc$V1)]),file='/home/tyler/Dropbox/research/jay/mosaic/popgen/relatedness/CR_T_IE_sequenced.txt',col.names=FALSE,row.names=FALSE,quote=FALSE)
# T, IE, I
write.table(data.frame(ID=seq.ids[which(seq.ids %in% core.anc2$V1)]),file='/home/tyler/Dropbox/research/jay/mosaic/popgen/relatedness/CR_T_IE_I_sequenced.txt',col.names=FALSE,row.names=FALSE,quote=FALSE)
--- END R CODE FOR SUBSETTING GNGETIC RELATEDNESS MATRIX ---

# skew stat for CR T, IE, I individuals
$ ~/code_projects/PopGenomicsTools/relateStats --skewstat 3 --rmat fsj_mosaic_biallelic_snps_main_autosomes_qc_relatedness_matrix_relateStats_input_CR.txt --anc CR_T_IE_I_sequenced.txt --cohort /home/tyler/Dropbox/research/jay/mosaic/pedigree/relateStat_inputs/CR_sequenced_contemporary_ids_20230512.txt --background_r 0.0243058 --out ./skew/CR_T_IE_I_to_C_contributions_c0.0243058

# skew stat for CR T and IE individuals
$ ~/code_projects/PopGenomicsTools/relateStats --skewstat 3 --rmat fsj_mosaic_biallelic_snps_main_autosomes_qc_relatedness_matrix_relateStats_input_CR.txt --anc CR_T_IE_sequenced.txt --cohort /home/tyler/Dropbox/research/jay/mosaic/pedigree/relateStat_inputs/CR_sequenced_contemporary_ids_20230512.txt --background_r 0.0243058 --out ./skew/CR_T_IE_to_C_contributions_c0.0243058

## Plot of Average rank-weighted skew

--- BEGIN R CODE FOR PLOTTING INDIVIDUAL AVERAGEE RANK-WEIGHTED SKEW DISTRIBUTION ---

library(scales)

kstat <- read.table('/home/tyler/Dropbox/research/jay/mosaic/popgen/relatedness/skew/CR_T_IE_to_C_contributions_c0.0243058.skewstat3',head=TRUE)
meta <- read.table('/home/tyler/Dropbox/research/jay/mosaic/metadata/M4_sequenced_FSJsamples_metadata.txt',head=TRUE,sep="\t")
idmap <- read.csv('/home/tyler/Dropbox/research/jay/mosaic/metadata/jayid_map_20230512.txt',head=TRUE,sep="\t")
meta$popcol <- popcolor(meta)
meta$COLOR_ID <- unname(sapply(meta$LAB_ID,function(x,df){df$COLOR_ID[which(df$LAB_ID == x)]},df=idmap))
meta$COLOR_ID[which(meta$COLOR_ID == "*")] <- NA

# nonparametric measure of skew
npskew = (mean(kstat$Swtr) - median(kstat$Swtr))/sd(kstat$Swtr)
#> npskew
#[1] 0.252958

kstat.sort <- kstat[order(-kstat$Swtr),] # sort data.frame by descending skew statistics

# plot contribution statistic, K
# png(file='/home/tyler/Dropbox/research/jay/mosaic/figures/k_statistic_distribution.png',width=9, height=7, units='in', res=300)
# png(file='/home/tyler/Dropbox/research/jay/mosaic/figures/k_statistic_distribution_v2.png',width=9, height=7, units='in', res=300) # use italics in axis titles
X11(width=9,height=7)
par(mar=c(5,5.2,4,2)+0.1)
#plot(x=1:nrow(kstat.sort), y=kstat.sort$Swtr, type="l", lwd=4, col="grey60", ylab = "Average weighted relatedness (K)", xlab="", xaxt='n',cex.lab=1.6, cex.axis=1.4)
plot(x=1:nrow(kstat.sort), y=kstat.sort$Swtr, type="l", lwd=4, col="grey60", ylab = expression(paste("Average weighted relatedness (", italic("K"), ")")), xlab="", xaxt='n',cex.lab=1.6, cex.axis=1.4) # v2
axis(1, at=1:nrow(kstat.sort), labels=kstat.sort$ID,cex=1.2,las=2)
# add points
pointcols = meta$popcol[sapply(kstat.sort$ID,function(x,df){which(df$COLOR_ID == x)},df=meta, USE.NAMES=FALSE)]
points(x=1:nrow(kstat.sort), y=kstat.sort$Swtr, pch=19, col=alpha(pointcols,0.8), cex=1.7)
# add vertical bars
lh = kstat.sort$Swtr
#lh[which(lh < 0.008)] = 0
lines(x=1:nrow(kstat.sort), y=lh, type="h", lwd=13.5, col=alpha(pointcols,0.4))
# add point outlines
points(x=1:nrow(kstat.sort), y=kstat.sort$Swtr, pch=1, col=pointcols, cex=1.7, lwd=1.7)

#dev.off()

--- END R CODE FOR PLOTTING INDIVIDUAL AVERAGE RANK-WEIGHTED SKEW DISTRIBUTION ---

## Plots of expected genetic contribution through time to population

--- begin R code for T and IE temporal contributions to population ---

library(scales) # for alpha colors
library(ggplot2)

meta <- read.table("/home/tyler/Dropbox/research/jay/mosaic/metadata/jayid_map_20230512.txt",head=TRUE,sep="\t")
fdir='/home/tyler/Dropbox/research/jay/mosaic/pedigree/results/pop_temporal/'
ped <- read.table('/home/tyler/Dropbox/research/jay/mosaic/pedigree/cr_ped_20230512.tsv', head=TRUE, na.strings='*')

pop.n <- NULL # data frame of number of expected genomic copies
pop.pfocal <- NULL # data frame of contributions normalized by focal ancestors
pop.pmax <- NULL # data frame of contribution normalized by max cohort pop contribution

# read in pedstat files for time points 2002-2022

time.periods = 2002:2022

# subset time periods for plots that follow so that they span years 2003-2022 (exclude 2002)
time.periods2 <- time.periods[2:length(time.periods)]

tidx <- 2:(length(time.periods)+1) # these are the contribution columns in matrix
id <- NULL
for (t in time.periods) {
	df <- read.table(paste0(fdir,'T_IE_20230512_',t,'_pop_contribution.pedstat1'),head=TRUE)
	if (is.null(id)) id <- df[,1]
	pop.n <- cbind(pop.n, df[,2])
	pop.pfocal <- cbind(pop.pfocal, df[,3])
	pop.pmax <- cbind(pop.pmax, df[,4])
}

# mask values of individuals if they weren't born
ped.sub <- ped[which(ped$ID %in% id),c(1,5)]
ped.sub <- ped.sub[match(id,ped.sub$ID),]
for (i in 1:length(time.periods)) {
	t = time.periods[i]
	idx <- which(ped.sub$COHORT > t)
	if (length(idx) > 0) {
		pop.n[idx,i] <- NA
		pop.pfocal[idx,i] <- NA
		pop.pmax[idx,i] <- NA	
	}
}

# NOTE: Recalculating proportions here such that they sum to 1 because KRS- and SR-PK sired translocated individuals
# prior to arriving in the Wellfield in 2005 and 2009, respectively. Counting contributions AFTER existing in 
# the CR makes the total contribution of ancestors <1. Therefore, resumming to count only the contributions
# of individuals after they arrive in the CR (after masking has been applied). Total ancestor contribution will now be 1.

for (i in 1:ncol(pop.pfocal)) {
	pop.pfocal[,i] <- pop.pfocal[,i]/sum(pop.pfocal[,i], na.rm=TRUE)
}

#
#


pop.n <- cbind(data.frame(ID=id),as.data.frame(pop.n)) # add sample names
colnames(pop.n) <- c("ID",paste0("cohort.",time.periods))

pop.pfocal <- cbind(data.frame(ID=id),as.data.frame(pop.pfocal)) # add sample names
colnames(pop.pfocal) <- c("ID",paste0("cohort.",time.periods))

pop.pmax <- cbind(data.frame(ID=id),as.data.frame(pop.pmax)) # add sample names
colnames(pop.pmax) <- c("ID",paste0("cohort.",time.periods))

# proportion with respect to focal ancestors plot

# get ID of top contributors to 2022 cohort
id.sort <- pop.pfocal$ID[order(-pop.pfocal$cohort.2022)] # individuals ordered by contribution in 2022
pop.pfocal$rank.2022 <- match(pop.pfocal$ID,id.sort)

#> id.sort[1:16]
# [1] "RLS-K" "WSA-K" "K-SLA" "OK-RS" "SK-RG" "BK-FS" "K-RSW" "K-SBF" "SR-PK"
# [10] "BK-LS" "K-GSW" "WSF-K" "LK-SG" "BK-AS" "WK-LS" "F-BPS"

# set colors for individuals (lines) of interest: top 16 contributors to 2022 population, which contributed over 75% of ancestry since 2015.
pop.pfocal$color <- "gray30"
pop.pfocal$color[which(pop.pfocal$ID == "RLS-K")] <- "red3"
pop.pfocal$color[which(pop.pfocal$ID == "WSA-K")] <- "blue1"
pop.pfocal$color[which(pop.pfocal$ID == "K-SLA")] <- "cyan"
pop.pfocal$color[which(pop.pfocal$ID == "OK-RS")] <- "steelblue1"
pop.pfocal$color[which(pop.pfocal$ID == "SK-RG")] <- "darkorange"
pop.pfocal$color[which(pop.pfocal$ID == "BK-FS")] <- "indianred4"
pop.pfocal$color[which(pop.pfocal$ID == "K-RSW")] <- "peru"
pop.pfocal$color[which(pop.pfocal$ID == "K-SBF")] <- "tan"
pop.pfocal$color[which(pop.pfocal$ID == "SR-PK")] <- "purple"
pop.pfocal$color[which(pop.pfocal$ID == "BK-LS")] <- "mediumpurple1"
pop.pfocal$color[which(pop.pfocal$ID == "K-GSW")] <- "plum2"
pop.pfocal$color[which(pop.pfocal$ID == "WSF-K")] <- "magenta"
pop.pfocal$color[which(pop.pfocal$ID == "LK-SG")] <- "deeppink3"
pop.pfocal$color[which(pop.pfocal$ID == "BK-AS")] <- "hotpink"
pop.pfocal$color[which(pop.pfocal$ID == "WK-LS")] <- "darkmagenta"
pop.pfocal$color[which(pop.pfocal$ID == "F-BPS")] <- "darkblue"

# set line width for top 16 contributors to 2022
pop.pfocal$lw <- 1
pop.pfocal$lw[which(pop.pfocal$ID == "RLS-K")] <- 2
pop.pfocal$lw[which(pop.pfocal$ID == "WSA-K")] <- 2
pop.pfocal$lw[which(pop.pfocal$ID == "K-SLA")] <- 2
pop.pfocal$lw[which(pop.pfocal$ID == "OK-RS")] <- 2
pop.pfocal$lw[which(pop.pfocal$ID == "SK-RG")] <- 2
pop.pfocal$lw[which(pop.pfocal$ID == "BK-FS")] <- 2
pop.pfocal$lw[which(pop.pfocal$ID == "K-RSW")] <- 2
pop.pfocal$lw[which(pop.pfocal$ID == "K-SBF")] <- 2
pop.pfocal$lw[which(pop.pfocal$ID == "SR-PK")] <- 2
pop.pfocal$lw[which(pop.pfocal$ID == "BK-LS")] <- 2
pop.pfocal$lw[which(pop.pfocal$ID == "K-GSW")] <- 2
pop.pfocal$lw[which(pop.pfocal$ID == "WSF-K")] <- 2
pop.pfocal$lw[which(pop.pfocal$ID == "LK-SG")] <- 2
pop.pfocal$lw[which(pop.pfocal$ID == "BK-AS")] <- 2
pop.pfocal$lw[which(pop.pfocal$ID == "WK-LS")] <- 2
pop.pfocal$lw[which(pop.pfocal$ID == "F-BPS")] <- 2

# color below are deprecated
# set colors for individuals (lines) of interest (top 10 contributors to 2022 cohort)
#pop.pfocal$color <- "gray30" # use for top 10
#pop.pfocal$color <- "black" # use for top 3
#pop.pfocal$color[which(pop.pfocal$ID == "RLS-K")] <- "red"
#pop.pfocal$color[which(pop.pfocal$ID == "WSA-K")] <- "purple"
#pop.pfocal$color[which(pop.pfocal$ID == "K-SLA")] <- "steelblue1" # used for top 3 
#pop.pfocal$color[which(pop.pfocal$ID == "K-SLA")] <- "cyan" # used for top 10
# uncomment individuals below to denote top 10 contributors
#pop.pfocal$color[which(pop.pfocal$ID == "OK-RS")] <- "orange"
#pop.pfocal$color[which(pop.pfocal$ID == "SK-RG")] <- "magenta"
#pop.pfocal$color[which(pop.pfocal$ID == "BK-FS")] <- "royalblue1"
#pop.pfocal$color[which(pop.pfocal$ID == "K-RSW")] <- "turquoise3"
#pop.pfocal$color[which(pop.pfocal$ID == "K-SBF")] <- "palevioletred1"
#pop.pfocal$color[which(pop.pfocal$ID == "SR-PK")] <- "red4"
#pop.pfocal$color[which(pop.pfocal$ID == "BK-LS")] <- "blue"

# set line width
#pop.pfocal$lw = 1
#pop.pfocal$lw[which(pop.pfocal$ID == "RLS-K")] <- 2
#pop.pfocal$lw[which(pop.pfocal$ID == "WSA-K")] <- 2
#pop.pfocal$lw[which(pop.pfocal$ID == "K-SLA")] <- 2
# uncomment individuals below to denote top 10 contributors
#pop.pfocal$lw[which(pop.pfocal$ID == "OK-RS")] <- 2
#pop.pfocal$lw[which(pop.pfocal$ID == "SK-RG")] <- 2
#pop.pfocal$lw[which(pop.pfocal$ID == "BK-FS")] <- 2
#pop.pfocal$lw[which(pop.pfocal$ID == "K-RSW")] <- 2
#pop.pfocal$lw[which(pop.pfocal$ID == "K-SBF")] <- 2
#pop.pfocal$lw[which(pop.pfocal$ID == "SR-PK")] <- 2
#pop.pfocal$lw[which(pop.pfocal$ID == "BK-LS")] <- 2

# set line type according to resident vs translocated
pop.pfocal$ltype <- unname(sapply(id,function(x,df){df$Biological_Origin_Status}[which(df$COLOR_ID == x)],df=meta))
pop.pfocal$ltype[which(pop.pfocal$ltype == "T" | pop.pfocal$ltype == "Donor_Population")] <- 1
pop.pfocal$ltype[which(pop.pfocal$ltype == "IE" | pop.pfocal$ltype == "LR")] <- 2
pop.pfocal$ltype <- as.numeric(pop.pfocal$ltype)

# plot proportion of focal ancestor contributions over time

#pdf(file='/home/tyler/Dropbox/research/jay/mosaic/pedigree/results/pop_temporal/T_IE_20230512_pop_contributions.pdf', width=16, height=7) # deprecated
#png(file='/home/tyler/Dropbox/research/jay/mosaic/figures/T_IE_pop_contribution_pfocal.png',width=16, height=7, units='in', res=300)
#png(file='/home/tyler/Dropbox/research/jay/mosaic/figures/T_IE_pop_contribution_pfocal_v2.png',width=16, height=7, units='in', res=300)
#png(file='/home/tyler/Dropbox/research/jay/mosaic/figures/T_IE_pop_contribution_pfocal_v3.png',width=16, height=7, units='in', res=300)
#par(mgp = c(2.75,1,0))
x11(width=16,height=7)

plot(1, type="n", xlim=c(time.periods[1],time.periods[length(time.periods)]), ylim=c(0,max(pop.pfocal[,tidx],na.rm=TRUE)+0.00),
xlab="Year", ylab="Proportion ancestor contribution to population", main="",xaxt='n', cex.axis=1.3, cex.lab=1.5)
axis(side=1,at=time.periods,labels=time.periods,cex=1.5,cex.axis=1.3)

for (i in 1:nrow(pop.pfocal)) {
	# draw lines
	lines(x=time.periods, y=pop.pfocal[i,tidx],col=alpha(pop.pfocal$color[i],0.6), lty=pop.pfocal$ltype[i], lwd=pop.pfocal$lw[i])
}

# plot mean line (omitted for v3)
#lines(x=time.periods, y=sapply(tidx,function(x,df){mean(df[,x],na.rm=TRUE)},df=pop.pfocal), lty=6, col="black", lwd=2)

# add legend
#grid(nx=110, ny=50, lty=2) # for aligning things

# legend configuration 1
#legend(x=2004, y=0.2625,"Translocated",lty=1,bty='n',cex=1.3, lwd=1.7, seg.len=2.9)
#legend(x=2008, y=0.2625,"Resident",lty=2,bty='n',cex=1.3, lwd=1.7, seg.len=2.9)
#legend(x=2011.4, y=0.2625,"Mean",lty=6,bty='n',cex=1.3, lwd=1.7, seg.len=2.9)

# legend configuration 2 - works best with added nesting annotations
legend('topright',c("Translocated","Resident"),lty=c(1,2),bty='n', lwd=1.7, cex=1.3, seg.len=2.9) # v3
#legend('topright',c("Translocated","Resident","Mean"),lty=c(1,2,6),bty='n', lwd=1.7, cex=1.3, seg.len=2.9) # v2


# legend configuration 3
#legend('topleft',c("Translocated","Resident","Mean"),lty=c(1,2,6),bty='n',cex=1.3)

#dev.off()

# calculate number of ancestors present in the CR that make a genetic contribtuion to the population
anc.contributors <- NULL
for (i in 1:length(time.periods)) {
	j <- i+1
	nexist <- length(which(!is.na(pop.pfocal[,j])))
	n <- length(which(pop.pfocal[,j] > 0))
	anc.contributors <- rbind(anc.contributors, data.frame(year=time.periods[i], N=n, Percent=((n/nexist)*100),N_EXIST=nexist))
}

#> anc.contributors
#   year  N   Percent N_EXIST
#1  2002  4 100.00000       4
#2  2003 20 100.00000      20
#3  2004 29  82.85714      35
#4  2005 20  51.28205      39
#5  2006 11  28.20513      39
#6  2007 14  33.33333      42
#7  2008 27  46.55172      58
#8  2009 28  43.75000      64
#9  2010 35  47.29730      74
#10 2011 32  43.24324      74
#11 2012 32  43.24324      74
#12 2013 30  40.54054      74
#13 2014 30  40.54054      74
#14 2015 29  39.18919      74
#15 2016 29  39.18919      74
#16 2017 26  35.13514      74
#17 2018 25  33.78378      74
#18 2019 25  33.78378      74
#19 2020 25  33.78378      74
#20 2021 25  33.78378      74
#21 2022 25  33.78378      74

# plot number of contributing ancestors out of the potential number of ancestral lineages over time
anc.df <- NULL
for (i in 1:nrow(anc.contributors)) {
	anc.df <- rbind(anc.df, data.frame(year=anc.contributors$year[i], count="total", N=anc.contributors$N_EXIST[i]))
	anc.df <- rbind(anc.df, data.frame(year=anc.contributors$year[i], count="contributors", N=anc.contributors$N[i]))
}

anc.df$count <- factor(anc.df$count, levels=c("total", "contributors"))
anc.df.sub <- anc.df[which(anc.df$year > 2002),] # only plot years 2003+

# stacked area chart

#png(file='/home/tyler/Dropbox/research/jay/mosaic/figures/T_IE_population_number_ancestors_area_chart.png',width=16, height=5, units='in', res=300)
x11(width=16,height=5)

ggplot(anc.df.sub, aes(x=year, y=N, fill=count)) + 

theme_classic() +

geom_vline(xintercept=time.periods2, col="gray80", linetype="dashed") +

geom_hline(yintercept=seq(from=0,to=75,by=5),col="gray90", linetype="dashed") +

geom_area(position="identity") + 

coord_cartesian(xlim=c(2003,2022),ylim=c(0,75)) +

scale_fill_manual(values=c(alpha("gray70",0.6),alpha("gray40",0.6))) +

geom_line() +

scale_x_continuous(breaks=time.periods2) +

scale_y_continuous(name="Number ancestors", breaks=seq(from=0,to=75,by=5)) +

#scale_y_continuous(name="Number ancestors", breaks=seq(from=0,to=75,by=5), sec.axis=) + # use for one axis


theme(legend.position="none", axis.text.x = element_text(size=17,color="black"), axis.ticks.length.x=unit(0.25,"cm"), axis.title.x=element_text(size=20, color="black"),
axis.text.y = element_text(size=17,color="black"), axis.ticks.length.y=unit(0.25,"cm"),axis.title.y=element_text(size=20,color="black", vjust=1.5)) +

xlab("Year")

#dev.off()

########

#png(file='/home/tyler/Dropbox/research/jay/mosaic/figures/T_IE_pop_contribution_pfocal_barplot_2003_2022.png',width=16, height=7, units='in', res=300)
x11(width=16,height=7)
ggplot(pop.pgroup3, aes(fill=ID, y=proportion, x=year)) +

theme_classic() +

geom_bar_pattern(position="stack", stat="identity", pattern=pop.pgroup3$pattern, pattern_fill = "black", fill=pop.pgroup3$color, linewidth=0.5, color="black",
pattern_spacing = 0.012, pattern_density=0.05, pattern_size=0.45, pattern_yoffset=rep(pat.shift,nyears)) +

#geom_bar(position="stack", stat="identity", fill=pop.pgroup3$color, linewidth=0.5, color="black", width=0.83) + # for testing purposes - no pattern

theme(legend.position="none", axis.text.x = element_text(size=17, color="black",vjust=4), axis.text.y = element_text(size=17, color="black"), axis.ticks.x=element_blank(),
axis.title.x=element_text(size = 20, color="black", vjust=2), axis.title.y=element_text(size = 20, color="black",vjust=2), axis.line.x=element_blank(), axis.line.y=element_blank(),
axis.ticks.length.y=unit(0.25, "cm")) +

annotate(x=0, xend=0, y=0, yend=1, colour="black", lwd=0.75, geom="segment") +

xlab("Year") +

ylab("Proportion ancestor contribution to population")

#dev.off()

#######

# average and maximum contributions of specific lineages

# RLKS-K from 2008-2022
mean(as.matrix(pop.pfocal[which(pop.pfocal$ID == "RLS-K"),which(colnames(pop.pfocal) == "cohort.2008"):which(colnames(pop.pfocal) == "cohort.2022")])) # mean
# [1] 0.1339778 # mean
sd(as.matrix(pop.pfocal[which(pop.pfocal$ID == "RLS-K"),which(colnames(pop.pfocal) == "cohort.2008"):which(colnames(pop.pfocal) == "cohort.2022")])) # stanard deviation
# [1] 0.03263044 # standard deviation
max(as.matrix(pop.pfocal[which(pop.pfocal$ID == "RLS-K"),which(colnames(pop.pfocal) == "cohort.2008"):which(colnames(pop.pfocal) == "cohort.2022")])) # max
#[1] 0.1730849 # max

# WSA-K from 2008-2022
mean(as.matrix(pop.pfocal[which(pop.pfocal$ID == "WSA-K"),which(colnames(pop.pfocal) == "cohort.2008"):which(colnames(pop.pfocal) == "cohort.2022")])) # mean
# [1] 0.1041607 # mean
sd(as.matrix(pop.pfocal[which(pop.pfocal$ID == "WSA-K"),which(colnames(pop.pfocal) == "cohort.2008"):which(colnames(pop.pfocal) == "cohort.2022")])) # standard deviation
# [1] 0.03203001 # standard deviation
max(as.matrix(pop.pfocal[which(pop.pfocal$ID == "WSA-K"),which(colnames(pop.pfocal) == "cohort.2008"):which(colnames(pop.pfocal) == "cohort.2022")])) # max
# [1] 0.149241 # max

# mean contribution for all individuals since 2008
avg.contribution <- NULL
for (id in pop.pfocal$ID) {
	val <- mean(as.matrix(pop.pfocal[which(pop.pfocal$ID == id),which(colnames(pop.pfocal) == "cohort.2008"):which(colnames(pop.pfocal) == "cohort.2022")]), na.rm=TRUE)
	avg.contribution <- rbind(avg.contribution, data.frame(ID=id, AVG_PROPORTION=val))
}

avg.contribution <- avg.contribution[order(-avg.contribution$AVG_PROPORTION),]

#> head(avg.contribution, n=16)
#      ID AVG_PROPORTION
#44 RLS-K     0.13397785
#5  WSA-K     0.10416071
#46 OK-RS     0.05648191
#22 K-SLA     0.05161644
#60 SK-RG     0.04947236
#53 BK-FS     0.04824063
#45 BK-AS     0.04575711
#1  SR-PK     0.04531992
#8  K-RSW     0.03753052
#40 BK-LS     0.03660300
#4  WSF-K     0.03217750
#23 K-SBF     0.02936139
#14 LK-SG     0.02834174
#17 AK-SP     0.02629410
#7  K-GSW     0.02488999
#66 F-BPS     0.02471368

# average collective contribution of RLS-K and WSA-K since 2008
rlsk.idx = which(pop.pfocal$ID == "RLS-K")
wsak.idx = which(pop.pfocal$ID == "WSA-K")
comb.contribution <- NULL
for (tidx in which(colnames(pop.pfocal) == "cohort.2008"):which(colnames(pop.pfocal) == "cohort.2022")) {
	comb.contribution = c(comb.contribution,pop.pfocal[rlsk.idx,tidx] + pop.pfocal[wsak.idx,tidx])
}
mean(comb.contribution)
# [1] 0.2381386 # mean
sd(comb.contribution)
#[1] 0.06403289 # standard deviation
max(comb.contribution)
#[1] 0.322263 # max

# assess relationship between RLS-K and K-SLA
rmat <- read.table('/home/tyler/Dropbox/research/jay/mosaic/pedigree/cr_ped_20230512_relatedness_matrix.txt',head=TRUE)
rmat[which(colnames(rmat) == "RLS.K"),which(colnames(rmat) == "K.SLA")]
# [1] 0.125 # r between RLS-K and K-SLA

# find all translocated relatives of RLS-K
trans <- read.csv('/home/tyler/Dropbox/research/jay/mosaic/metadata/Translocated_Jay_Individual_Statistics.tsv',head=TRUE,sep="\t")
rlsk.relatives <- colnames(rmat)[which(rmat[which(colnames(rmat) == "RLS.K"),] > 0)]
trans.id <- gsub("-",".",trans$COLOR_ID)
rlsk.relatives.trans <- rlsk.relatives[rlsk.relatives %in% trans.id]
#> rlsk.relatives.trans
#[1] "RLS.K" "SK.RG" "SK.RB" "SK.RP" "SRR.K" "K.SAP" "K.SLA" "K.SPR" "K.SAG"

# Proportion of genomic copies contributed by the top 16 contributors in 2022

ntop = 16
# pop.pfocal row indices of the top contributors in 2022 
topidx = unname(sapply(pop.pfocal[order(-pop.pfocal$cohort.2022),1][1:ntop],function(x,df){which(df$ID == x)},df=pop.pfocal))
# calculate the sum of the top contributor's genomic contribution for each year
top.contribution <- NULL
for (i in 1:length(time.periods)) {
	top.contribution <- rbind(top.contribution, data.frame(YEAR=time.periods[i], PROPORTION_GENOMIC_COPIES = sum(pop.pfocal[topidx,i+1], na.rm=TRUE)))
}

#> top.contribution
#   YEAR PROPORTION_GENOMIC_COPIES
#1  2002                 0.2500000
#2  2003                 0.2000000
#3  2004                 0.1707317
#4  2005                 0.3076927
#5  2006                 0.4999996
#6  2007                 0.5270272
#7  2008                 0.6368874
#8  2009                 0.7583543
#9  2010                 0.6504852
#10 2011                 0.6963268
#11 2012                 0.6982892
#12 2013                 0.6773675
#13 2014                 0.7156768
#14 2015                 0.7716050
#15 2016                 0.7612648
#16 2017                 0.7900778
#17 2018                 0.8003363
#18 2019                 0.8580870
#19 2020                 0.8346470
#20 2021                 0.8618459
#21 2022                 0.8802618

# minimum contribution since 2015
min(top.contribution[which(top.contribution$YEAR == 2015):nrow(top.contribution),2])
# [1] 0.7612648

## Stacked barplot of contribution to population relative to other ancestors

# color top 10 contributors

topN = 10
grp.idx <- list()
grp.id <- NULL
member.id <- list()

for (i in id.sort[1:topN]) {
	member.id <- c(member.id, i)
	grp.id <- c(grp.id, i)
	grp.idx <- c(grp.idx, which(pop.pfocal$ID == i))
}

# get index of all other translocated and resident individuals
grp.id <- c(grp.id,"other_translocated")
grp.idx[[topN+1]] <- which(pop.pfocal$ltype == 1 & pop.pfocal$ID %in% id.sort[1:topN] == FALSE)
member.id[[topN+1]] <- pop.pfocal$ID[grp.idx[[topN+1]]]

grp.id <- c(grp.id,"other_resident")
grp.idx[[topN+2]] <- which(pop.pfocal$ltype == 2 & pop.pfocal$ID %in% id.sort[1:topN] == FALSE)
member.id[[topN+2]] <- pop.pfocal$ID[grp.idx[[topN+2]]]

# calculate proportion group contribution to population
pop.pgroup <- NULL
for (j in 2:((ncol(pop.pfocal))-4)) {
	x <- NULL
	for (i in 1:length(grp.idx)) {
		x <- c(x,sum(pop.pfocal[grp.idx[[i]],j],na.rm=TRUE))
	}
	x.df <- data.frame(x)
	if (is.null(pop.pgroup) == TRUE) pop.pgroup = x.df else pop.pgroup <- cbind(pop.pgroup, x.df)
}
colnames(pop.pgroup) <- colnames(pop.pfocal)[2:((ncol(pop.pfocal))-4)]
pop.pgroup <- cbind(data.frame(ID=grp.id),pop.pgroup)

# stacked barplot of group contributions
barcol <- c(unname(sapply(pop.pgroup$ID[1:topN],function(x,df){df$color[which(df$ID == x)]},df=pop.pfocal)), "gray40", "gray70")

#png(file='/home/tyler/Dropbox/research/jay/mosaic/figures/T_IE_pop_contribution_pfocal_barplot.png',width=16, height=7, units='in', res=300)
x11(width=16,height=7)
par(mgp = c(2.8,1,0))
barplot(as.matrix(pop.pgroup[2:ncol(pop.pgroup)]), names.arg=time.periods, border=NA, col=barcol, xlab="Year", ylab="Proportion ancestor contribution", cex.names=1.27, cex.axis=1.3, cex.lab=1.5)
#dev.off()

# alternatively, make stacked barplot where each individual is a box and color by group using gradients and distinct colors
topid <- pop.pfocal$ID[topidx] # these are the individuals that contributed >75% ancestry to the CR population since 2015
#topid
# [1] "RLS-K" "WSA-K" "K-SLA" "OK-RS" "SK-RG" "BK-FS" "K-RSW" "K-SBF" "SR-PK"
# [10] "BK-LS" "K-GSW" "WSF-K" "LK-SG" "BK-AS" "WK-LS" "F-BPS

# set groups for barplot coloring

pop.pgroup2 <- pop.pfocal[,1:22]
pop.pgroup2$biotype = unname(sapply(pop.pgroup2$ID, function(x,df){idx=which(df$COLOR_ID == x); btype=df$Biological_Origin_Status[idx];ifelse(btype == "T", "Trans", "Res")},df=meta))

pop.pgroup2$bargrp <- pop.pgroup2$biotype
pop.pgroup2$bargrp[which(pop.pgroup2$ID %in% topid == TRUE)] <- "top"

# sort by descending contribution to 2022 within groups
pop.pgroup2$bargrp <- factor(pop.pgroup2$bargrp,levels=c("top","Trans","Res"),ordered=TRUE)
pop.pgroup2 <- pop.pgroup2[order(pop.pgroup2$bargrp,-pop.pgroup2$cohort.2022),]

# color top individuals

pop.pgroup2$barcol <- pop.pfocal$ID
pop.pgroup2$barcol[which(pop.pgroup2$ID == "RLS-K")] <- "red3"
pop.pgroup2$barcol[which(pop.pgroup2$ID == "WSA-K")] <- "blue1"
pop.pgroup2$barcol[which(pop.pgroup2$ID == "K-SLA")] <- "cyan"
pop.pgroup2$barcol[which(pop.pgroup2$ID == "OK-RS")] <- "steelblue1"
pop.pgroup2$barcol[which(pop.pgroup2$ID == "SK-RG")] <- "darkorange"
pop.pgroup2$barcol[which(pop.pgroup2$ID == "BK-FS")] <- "indianred4"
pop.pgroup2$barcol[which(pop.pgroup2$ID == "K-RSW")] <- "peru"
pop.pgroup2$barcol[which(pop.pgroup2$ID == "K-SBF")] <- "tan"
pop.pgroup2$barcol[which(pop.pgroup2$ID == "SR-PK")] <- "purple"
pop.pgroup2$barcol[which(pop.pgroup2$ID == "BK-LS")] <- "mediumpurple1"
pop.pgroup2$barcol[which(pop.pgroup2$ID == "K-GSW")] <- "plum2"
pop.pgroup2$barcol[which(pop.pgroup2$ID == "WSF-K")] <- "magenta"
pop.pgroup2$barcol[which(pop.pgroup2$ID == "LK-SG")] <- "deeppink3"
pop.pgroup2$barcol[which(pop.pgroup2$ID == "BK-AS")] <- "hotpink"
pop.pgroup2$barcol[which(pop.pgroup2$ID == "WK-LS")] <- "darkmagenta"
pop.pgroup2$barcol[which(pop.pgroup2$ID == "F-BPS")] <- "darkblue"

# gradient color remaining translocated individuals
trans.col.vec = NULL
trans.col="gold2"
trans.idx <- which(pop.pgroup2$bargrp == "Trans")
step = 1/(length(trans.idx)+10)
c = 1;
for (i in trans.idx) {
	pop.pgroup2$barcol[i] <- alpha(trans.col,c)
	trans.col.vec <- c(trans.col.vec,pop.pgroup2$barcol[i])
	c = c-step
}

# gradient color for remaining resident individuals
res.col.vec = NULL
res.col="gray30"
res.idx <- which(pop.pgroup2$bargrp == "Res")
step = 1/(length(res.idx)+5)
c = 1;
for (i in res.idx) {
        pop.pgroup2$barcol[i] <- alpha(res.col,c)
	res.col.vec <- c(res.col.vec,pop.pgroup2$barcol[i])
        c = c-step
}

# convert data.frame into matrix for plotting
#pop.pgroup2.mat <- as.matrix(pop.pgroup2[,2:22])
pop.pgroup2.mat <- as.matrix(pop.pgroup2[,3:22]) # excludes 2002
pop.pgroup2.mat[which(is.na(pop.pgroup2.mat))] <- 0

# barplot
x11(width=16,height=7)
par(mgp = c(2.8,1,0))
#barplot(pop.pgroup2.mat, names.arg=time.periods, border="black", col=pop.pgroup2$barcol, xlab="Year", ylab="Proportion ancestor contribution", cex.names=1.27, cex.axis=1.3, cex.lab=1.5)
barplot(pop.pgroup2.mat, names.arg=time.periods2, border="black", col=pop.pgroup2$barcol, xlab="Year", ylab="Proportion ancestor contribution", cex.names=1.27, cex.axis=1.3, cex.lab=1.5) # exclude 2002

# gradient color box for legend

trans.col.width = seq(from=0,to=1,by=(1/length(trans.col.vec)))
res.col.width = seq(from=0,to=1,by=(1/length(res.col.vec)))

X11()
#png(file='/home/tyler/Dropbox/research/jay/mosaic/figures/T_IE_pop_contribution_pfocal_barplot_key.png', width=7, height=7, units='in', res=300)
#pdf(file='/home/tyler/Dropbox/research/jay/mosaic/figures/T_IE_pop_contribution_pfocal_barplot_key.pdf', width=7, height=7)
#plot.new()

yb = 0.1
yt = 0.3
plot(1, type="n", xlab="", ylab="", xlim=c(-0.05,1.05), ylim=c(-0.05,1.05))
for (i in 1:(length(trans.col.width)-1)) {
	xs = trans.col.width[i]
	xe = trans.col.width[i+1]
	rect(xleft=xs, xright=xe, ybottom=yb, ytop=yt, border="gray50", lwd=0.3, col=trans.col.vec[i])
}
rect(xleft=trans.col.width[1], xright=trans.col.width[length(trans.col.width)], ybottom=yb, ytop=yt, border="gray20", lwd=1, col=NA)

res.col.width = seq(from=0,to=1,by=(1/length(res.col.vec)))
yb = 0.5
yt = 0.7
for (i in 1:(length(res.col.width)-1)) {
        xs = res.col.width[i]
        xe = res.col.width[i+1]
        rect(xleft=xs, xright=xe, ybottom=yb, ytop=yt, border="gray10", lwd=0.3, col=res.col.vec[i])
}
rect(xleft=res.col.width[1], xright=res.col.width[length(res.col.width)], ybottom=yb, ytop=yt, border="gray20", lwd=1, col=NA)

#dev.off()

# ggplot stacked barplot version to accommodate pattern
library(ggpattern)

#nyears = length(time.periods)
nyears = length(time.periods2)

years.vec <- NULL
#for (i in time.periods) { years.vec <- c(years.vec,rep(i,nrow(pop.pgroup2))) }
for (i in time.periods2) { years.vec <- c(years.vec,rep(i,nrow(pop.pgroup2))) }

contribution.p = NULL
for (i in 1:ncol(pop.pgroup2.mat)) {contribution.p <- c(contribution.p, unname(pop.pgroup2.mat[,i]))}

pat <- replace(pop.pgroup2$biotype, which(pop.pgroup2$biotype == "Res"), "stripe")
pat <- replace(pat, which(pat != "stripe"), "none")

pop.pgroup3 <- data.frame(year=years.vec, ID=rep(pop.pgroup2$ID,nyears), proportion=contribution.p, color=rep(pop.pgroup2$barcol,nyears), pattern=rep(pat,nyears))
pop.pgroup3$year <- as.factor(pop.pgroup3$year) # need to do this for proper x-axis labels

pat.shift = NULL
xshift=0
pstep = 1/length(which(pat=="stripe"))
for (i in pat) {
	if (i == "stripe") {
		xshift = xshift + pstep
		pat.shift = c(pat.shift,xshift)
	} else pat.shift = c(pat.shift,0)
}

# begin plot
#png(file='/home/tyler/Dropbox/research/jay/mosaic/figures/T_IE_pop_contribution_pfocal_barplot.png',width=16, height=7, units='in', res=300)
#png(file='/home/tyler/Dropbox/research/jay/mosaic/figures/T_IE_pop_contribution_pfocal_barplot_2003_2022.png',width=16, height=7, units='in', res=300)
x11(width=16,height=7)
ggplot(pop.pgroup3, aes(fill=ID, y=proportion, x=year)) +

theme_classic() +

geom_bar_pattern(position="stack", stat="identity", pattern=pop.pgroup3$pattern, pattern_fill = "black", fill=pop.pgroup3$color, linewidth=0.5, color="black",
pattern_spacing = 0.012, pattern_density=0.05, pattern_size=0.45, pattern_yoffset=rep(pat.shift,nyears)) +

#geom_bar(position="stack", stat="identity", fill=pop.pgroup3$color, linewidth=0.5, color="black", width=0.83) + # for testing purposes - no pattern

theme(legend.position="none", axis.text.x = element_text(size=17, color="black",vjust=4), axis.text.y = element_text(size=17, color="black"), axis.ticks.x=element_blank(),
axis.title.x=element_text(size = 20, color="black", vjust=2), axis.title.y=element_text(size = 20, color="black",vjust=2), axis.line.x=element_blank(), axis.line.y=element_blank(), 
axis.ticks.length.y=unit(0.25, "cm")) +

annotate(x=0, xend=0, y=0, yend=1, colour="black", lwd=0.75, geom="segment") +

xlab("Year") +

ylab("Proportion ancestor contribution to population")

#dev.off()

# stacked area chart of contributing ancestors with individual ancestor lines (ignore warnings)

pop.pfocal$lstr <- replace(pop.pfocal$ltype,which(pop.pfocal$ltype == 1), "solid")
pop.pfocal$lstr <- replace(pop.pfocal$lstr,which(pop.pfocal$ltype == "2"), "dashed")
pop.pfocal$lw2 <- replace(pop.pfocal$lw,which(pop.pfocal$lw == 2), 0.75)
pop.pfocal$lw2 <- replace(pop.pfocal$lw2,which(pop.pfocal$lw2 == 1), 0.50)


#png(file='/home/tyler/Dropbox/research/jay/mosaic/figures/T_IE_population_number_ancestors_area_chart_v2.png',width=16, height=7, units='in', res=300)
#png(file='/home/tyler/Dropbox/research/jay/mosaic/figures/T_IE_population_number_ancestors_area_chart_v3.png',width=16, height=7, units='in', res=300) # offset x-axis title
x11(width=16,height=7)

gg.pop <- ggplot(anc.df.sub, aes(x=year, y=N, fill=count)) +

theme_classic() +

geom_area(position="identity") +

coord_cartesian(xlim=c(2003,2022),ylim=c(0,75)) +

scale_fill_manual(values=c(alpha("gray70",0.6),alpha("gray40",0.6))) +

scale_x_continuous(breaks=time.periods2) +

scale_y_continuous(name="Number ancestors", breaks=seq(from=0,to=75,by=5), sec.axis=sec_axis(~./75*prop.cutoff, name="Proportion ancestor contribution to population", 
breaks=seq(from=0,to=prop.cutoff,by=0.02), )) +

theme(legend.position="none", axis.text.x = element_text(size=17,color="black"), axis.ticks.length.x=unit(0.25,"cm"), axis.title.x=element_text(size=20, color="black", hjust=0.8),
axis.text.y = element_text(size=17,color="black"), axis.ticks.length.y=unit(0.25,"cm"),axis.title.y=element_text(size=20,color="black", vjust=1.5),
axis.title.y.right = element_text(size=20, color="black", vjust=1.5)) +

xlab("Year")

for (k in 1:nrow(pop.pfocal)) {
	tmpvec <- NULL
	for (j in 3:22) { tmpvec <- c(tmpvec,c(pop.pfocal[k,j],NA)) }
	gg.pop <- gg.pop + geom_line(aes_string(y=tmpvec*(75/prop.cutoff)), color=pop.pfocal$color[k], linetype=pop.pfocal$lstr[k], lwd=pop.pfocal$lw2[k])
}

gg.pop

#dev.off()

# proportion with respect to maximum ancestor pop contribution (Hunter normalization) plot

# get ID of top contributors to 2022 cohort
id.sort.hunter <- pop.pmax$ID[order(-pop.pmax$cohort.2022)] # individuals ordered by contribution in 2022
pop.pmax$rank.2022 <- match(pop.pmax$ID,id.sort.hunter)

#> id.sort.hunter[1:10]
# [1] "BK-LS" "RLS-K" "OK-RS" "K-RSW" "WSA-K" "K-SLA" "BK-AS" "SK-RG" "BK-FS"
#[10] "WK-LS"

# set colors for individuals (lines) of interest (top 10 contributors to 2022 cohort)
pop.pmax$color <- "gray30"
pop.pmax$color[which(pop.pmax$ID == "RLS-K")] <- "red"
pop.pmax$color[which(pop.pmax$ID == "WSA-K")] <- "purple"
pop.pmax$color[which(pop.pmax$ID == "K-SLA")] <- "cyan"
pop.pmax$color[which(pop.pmax$ID == "OK-RS")] <- "orange"
pop.pmax$color[which(pop.pmax$ID == "SK-RG")] <- "magenta"
pop.pmax$color[which(pop.pmax$ID == "BK-FS")] <- "royalblue1"
pop.pmax$color[which(pop.pmax$ID == "K-RSW")] <- "turquoise3"
pop.pmax$color[which(pop.pmax$ID == "BK-AS")] <- "yellow3"
pop.pmax$color[which(pop.pmax$ID == "BK-LS")] <- "blue"
pop.pmax$color[which(pop.pmax$ID == "WK-LS")] <- "salmon2" # individual not among top 10 in focal ancestor normalization

# set line width
pop.pmax$lw = 1
pop.pmax$lw[which(pop.pmax$ID == "RLS-K")] <- 2
pop.pmax$lw[which(pop.pmax$ID == "WSA-K")] <- 2
pop.pmax$lw[which(pop.pmax$ID == "K-SLA")] <- 2
pop.pmax$lw[which(pop.pmax$ID == "OK-RS")] <- 2
pop.pmax$lw[which(pop.pmax$ID == "SK-RG")] <- 2
pop.pmax$lw[which(pop.pmax$ID == "BK-FS")] <- 2
pop.pmax$lw[which(pop.pmax$ID == "K-RSW")] <- 2
pop.pmax$lw[which(pop.pmax$ID == "BK-AS")] <- 2
pop.pmax$lw[which(pop.pmax$ID == "BK-LS")] <- 2
pop.pmax$lw[which(pop.pmax$ID == "WK-LS")] <- 2

# set line type according to resident vs translocated
pop.pmax$ltype <- unname(sapply(id,function(x,df){df$Biological_Origin_Status}[which(df$COLOR_ID == x)],df=meta))
pop.pmax$ltype[which(pop.pmax$ltype == "T" | pop.pmax$ltype == "Donor_Population")] <- 1
pop.pmax$ltype[which(pop.pmax$ltype == "IE" | pop.pmax$ltype == "LR")] <- 2
pop.pmax$ltype <- as.numeric(pop.pmax$ltype)

# plot proportion of focal ancestor contributions over time

#png(file='/home/tyler/Dropbox/research/jay/mosaic/figures/T_IE_pop_contribution_pmax.png',width=16, height=7, units='in', res=300)
x11(width=16,height=7)
par(mgp = c(2.75,1,0))
plot(1, type="n", xlim=c(time.periods[1],time.periods[length(time.periods)]), ylim=c(0,max(pop.pmax[,tidx],na.rm=TRUE)+0.01),
xlab="Year", ylab="Proportion ancestor contribution relative to pop max", main="",xaxt='n', cex.axis=1.3, cex.lab=1.5)
axis(side=1,at=time.periods,labels=time.periods,cex=1.5,cex.axis=1.3)

for (i in 1:nrow(pop.pmax)) {
	# draw lines
	lines(x=time.periods, y=pop.pmax[i,tidx],col=alpha(pop.pmax$color[i],0.6), lty=pop.pmax$ltype[i], lwd=pop.pmax$lw[i])
}
# plot mean line
lines(x=time.periods, y=sapply(tidx,function(x,df){mean(df[,x],na.rm=TRUE)},df=pop.pmax), lty=6, col="black", lwd=2)

# add legend
legend('topleft',c("Translocated","Resident","Mean"),lty=c(1,2,6),bty='n',cex=1.3, lwd=1.7, seg.len=2.9)

#dev.off()

--- end R code for T and IE temporal contributions to population ---

--- begin R code for T, IE, and I temporal contributions to population (TODO: RERUN ON NEW DATA) ---

library(scales) # for alpha colors

meta <- read.table("/home/tyler/Dropbox/research/jay/mosaic/metadata/jayid_map_20230512.txt",head=TRUE,sep="\t")
fdir='/home/tyler/Dropbox/research/jay/mosaic/pedigree/results/pop_temporal/'
ped <- read.table('/home/tyler/Dropbox/research/jay/mosaic/pedigree/cr_ped_20230512.tsv', head=TRUE, na.strings='*')

pop.n <- NULL # data frame of number of expected genomic copies
pop.pfocal <- NULL # data frame of contributions normalized by focal ancestors
pop.pmax <- NULL # data frame of contribution normalized by max cohort pop contribution

# read in pedstat files for time points 2002-2022
time.periods = 2002:2022
tidx <- 2:(length(time.periods)+1) # these are the contribution columns in matrix
id <- NULL
for (t in time.periods) {
	df <- read.table(paste0(fdir,'T_IE_I_20230512_',t,'_pop_contribution.pedstat1'),head=TRUE)
	if (is.null(id)) id <- df[,1]
	pop.n <- cbind(pop.n, df[,2])
	pop.pfocal <- cbind(pop.pfocal, df[,3])
	pop.pmax <- cbind(pop.pmax, df[,4])
}

# mask values of individuals if they weren't born
ped.sub <- ped[which(ped$ID %in% id),c(1,5)]
ped.sub <- ped.sub[match(id,ped.sub$ID),]
for (i in 1:length(time.periods)) {
	t = time.periods[i]
	idx <- which(ped.sub$COHORT > t)
	if (length(idx) > 0) {
		pop.n[idx,i] <- NA
		pop.pfocal[idx,i] <- NA
		pop.pmax[idx,i] <- NA	
	}
}

pop.n <- cbind(data.frame(ID=id),as.data.frame(pop.n)) # add sample names
colnames(pop.n) <- c("ID",paste0("cohort.",time.periods))

pop.pfocal <- cbind(data.frame(ID=id),as.data.frame(pop.pfocal)) # add sample names
colnames(pop.pfocal) <- c("ID",paste0("cohort.",time.periods))

pop.pmax <- cbind(data.frame(ID=id),as.data.frame(pop.pmax)) # add sample names
colnames(pop.pmax) <- c("ID",paste0("cohort.",time.periods))

# proportion with respect to focal ancestors plot

# get ID of top contributors to 2022 cohort
id.sort <- pop.pfocal$ID[order(-pop.pfocal$cohort.2022)] # individuals ordered by contribution in 2022
pop.pfocal$rank.2022 <- match(pop.pfocal$ID,id.sort)

# set colors for individuals (lines) of interest (top 10 contributors to 2022 cohort)
pop.pfocal$color <- "gray30"
pop.pfocal$color[which(pop.pfocal$ID == "RLS-K")] <- "red"
pop.pfocal$color[which(pop.pfocal$ID == "WSA-K")] <- "purple"
pop.pfocal$color[which(pop.pfocal$ID == "K-SLA")] <- "cyan"
pop.pfocal$color[which(pop.pfocal$ID == "OK-RS")] <- "orange"
pop.pfocal$color[which(pop.pfocal$ID == "PK-SG")] <- "cornflowerblue"
pop.pfocal$color[which(pop.pfocal$ID == "PF-SH")] <- "darkcyan"
pop.pfocal$color[which(pop.pfocal$ID == "SK-RG")] <- "magenta"
pop.pfocal$color[which(pop.pfocal$ID == "BK-FS")] <- "royalblue1"
pop.pfocal$color[which(pop.pfocal$ID == "RF-SF")] <- "burlywood3"
pop.pfocal$color[which(pop.pfocal$ID == "K-RSW")] <- "turquoise3"

# set line type according to resident vs translocated
pop.pfocal$ltype <- unname(sapply(id,function(x,df){df$Biological_Origin_Status}[which(df$COLOR_ID == x)],df=meta))
pop.pfocal$ltype[which(pop.pfocal$ltype == "T" | pop.pfocal$ltype == "Donor_Population")] <- 1
pop.pfocal$ltype[which(pop.pfocal$ltype == "IE" | pop.pfocal$ltype == "LR")] <- 2
pop.pfocal$ltype[which(pop.pfocal$ltype == "I")] <- 3
pop.pfocal$ltype <- as.numeric(pop.pfocal$ltype)

# set line width
pop.pfocal$lw = 1
pop.pfocal$lw[which(pop.pfocal$ltype == 3)] <- 1.8 # need to increase size of dots for visibility
isize = 2.8
pop.pfocal$lw[which(pop.pfocal$ID == "RLS-K")] <- 1.8
pop.pfocal$lw[which(pop.pfocal$ID == "WSA-K")] <- 1.8
pop.pfocal$lw[which(pop.pfocal$ID == "K-SLA")] <- 1.8
pop.pfocal$lw[which(pop.pfocal$ID == "OK-RS")] <- 1.8
pop.pfocal$lw[which(pop.pfocal$ID == "PK-SG")] <- isize # immigrant
pop.pfocal$lw[which(pop.pfocal$ID == "PF-SH")] <- isize # immigrant
pop.pfocal$lw[which(pop.pfocal$ID == "SK-RG")] <- 1.8
pop.pfocal$lw[which(pop.pfocal$ID == "BK-FS")] <- 1.8
pop.pfocal$lw[which(pop.pfocal$ID == "RF-SF")] <- isize # immigrant
pop.pfocal$lw[which(pop.pfocal$ID == "K-RSW")] <- 1.8

# plot proportion of focal ancestor contributions over time

#pdf(file='/home/tyler/Dropbox/research/jay/mosaic/pedigree/results/pop_temporal/T_IE_I_20230512_pop_contributions.pdf', width=16, height=7)
x11(width=16,height=7)
par(mgp = c(2.75,1,0))
plot(1, type="n", xlim=c(time.periods[1],time.periods[length(time.periods)]), ylim=c(0,max(pop.pfocal[,tidx],na.rm=TRUE)+0.05),
xlab="Year", ylab="Proportion ancestor contribution to population", main="",xaxt='n', cex.axis=1.3, cex.lab=1.5)
axis(side=1,at=time.periods,labels=time.periods,cex=1.5,cex.axis=1.3)

for (i in 1:nrow(pop.pfocal)) {
	# draw lines
	lines(x=time.periods, y=pop.pfocal[i,tidx],col=alpha(pop.pfocal$color[i],0.6), lty=pop.pfocal$ltype[i], lwd=pop.pfocal$lw[i])
}
# plot mean line
lines(x=time.periods, y=sapply(tidx,function(x,df){mean(df[,x],na.rm=TRUE)},df=pop.pfocal), lty=6, col="black", lwd=1.8)

# add legend
legend('topleft',c("Translocated","Resident","Immigrant","Mean"),lty=c(1,2,3,6),bty='n',cex=1.2)

# proportion with respect to maximum ancestor pop contribution (Hunter normalization) plot

# get ID of top contributors to 2022 cohort
id.sort.hunter <- pop.pmax$ID[order(-pop.pmax$cohort.2022)] # individuals ordered by contribution in 2022
pop.pmax$rank.2022 <- match(pop.pmax$ID,id.sort.hunter)

# set colors for individuals (lines) of interest (top 10 contributors to 2022 cohort)
pop.pmax$color <- "gray30"
pop.pmax$color[which(pop.pmax$ID == "RLS-K")] <- "red"
pop.pmax$color[which(pop.pmax$ID == "WSA-K")] <- "purple"
pop.pmax$color[which(pop.pmax$ID == "OK-RS")] <- "orange"
pop.pmax$color[which(pop.pmax$ID == "BK-LS")] <- "blue"
pop.pmax$color[which(pop.pmax$ID == "K-SLA")] <- "cyan"
pop.pmax$color[which(pop.pmax$ID == "SK-RG")] <- "magenta"
pop.pmax$color[which(pop.pmax$ID == "BK-FS")] <- "royalblue1"
pop.pmax$color[which(pop.pmax$ID == "PK-SG")] <- "cornflowerblue"
pop.pmax$color[which(pop.pmax$ID == "SR-PK")] <- "red4"
pop.pmax$color[which(pop.pmax$ID == "WK-LS")] <- "salmon2"

# set line type according to resident vs translocated
pop.pmax$ltype <- unname(sapply(id,function(x,df){df$Biological_Origin_Status}[which(df$COLOR_ID == x)],df=meta))
pop.pmax$ltype[which(pop.pmax$ltype == "T" | pop.pmax$ltype == "Donor_Population")] <- 1
pop.pmax$ltype[which(pop.pmax$ltype == "IE" | pop.pmax$ltype == "LR")] <- 2
pop.pmax$ltype[which(pop.pmax$ltype == "I")] <- 3
pop.pmax$ltype <- as.numeric(pop.pmax$ltype)

# set line width
pop.pmax$lw = 1
pop.pmax$lw[which(pop.pmax$ltype == 3)] <- 1.8 # need to increase size of dots for visibility
pop.pmax$lw[which(pop.pmax$ID == "RLS-K")] <- 1.8
pop.pmax$lw[which(pop.pmax$ID == "WSA-K")] <- 1.8
pop.pmax$lw[which(pop.pmax$ID == "OK-RS")] <- 1.8
pop.pmax$lw[which(pop.pmax$ID == "BK-LS")] <- 1.8
pop.pmax$lw[which(pop.pmax$ID == "K-SLA")] <- 1.8
pop.pmax$lw[which(pop.pmax$ID == "SK-RG")] <- 1.8
pop.pmax$lw[which(pop.pmax$ID == "BK-FS")] <- 1.8
pop.pmax$lw[which(pop.pmax$ID == "PK-SG")] <- isize # immigrant
pop.pmax$lw[which(pop.pmax$ID == "SR-PK")] <- 1.8
pop.pmax$lw[which(pop.pmax$ID == "WK-LS")] <- 1.8

# plot proportion of focal ancestor contributions over time

x11(width=16,height=7)
par(mgp = c(2.75,1,0))
plot(1, type="n", xlim=c(time.periods[1],time.periods[length(time.periods)]), ylim=c(0,max(pop.pmax[,tidx],na.rm=TRUE)+0.05),
xlab="Year", ylab="Proportion ancestor contribution relative to pop max", main="",xaxt='n', cex.axis=1.3, cex.lab=1.5)
axis(side=1,at=time.periods,labels=time.periods,cex=1.5,cex.axis=1.3)

for (i in 1:nrow(pop.pmax)) {
	# draw lines
	lines(x=time.periods, y=pop.pmax[i,tidx],col=alpha(pop.pmax$color[i],0.6), lty=pop.pmax$ltype[i], lwd=pop.pmax$lw[i])
}
# plot mean line
lines(x=time.periods, y=sapply(tidx,function(x,df){mean(df[,x],na.rm=TRUE)},df=pop.pmax), lty=6, col="black", lwd=1.8)

# add legend
legend('topleft',c("Translocated","Resident","Immigrant","Mean"),lty=c(1,2,3,6),bty='n',cex=1.2)

--- end R code for T, IE, and I temporal contributions to population ---

## Plots of expected genetic contribution through time to individuals born in a cohort

--- begin R code for T and IE temporal contributions to cohort ---

library(scales) # for alpha colors

meta <- read.table("/home/tyler/Dropbox/research/jay/mosaic/metadata/jayid_map_20230512.txt",head=TRUE,sep="\t")
fdir='/home/tyler/Dropbox/research/jay/mosaic/pedigree/results/lr_temporal/'
ped <- read.table('/home/tyler/Dropbox/research/jay/mosaic/pedigree/cr_ped_20230512.tsv', head=TRUE, na.strings='*')

cohort.n <- NULL # data frame of number of expected genomic copies
cohort.pfocal <- NULL # data frame of contributions normalized by focal ancestors
cohort.pmax <- NULL # data frame of contribution normalized by max ancestral cohort pop contribution

# read in pedstat files for time points 2004-2022
time.periods = 2004:2022
tidx <- 2:(length(time.periods)+1) # these are the contribution columns in matrix
id <- NULL
for (t in time.periods) {
	df <- read.table(paste0(fdir,'T_IE_20230512_to_',t,'_LR_contribution.pedstat1'),head=TRUE)
	if (is.null(id)) id <- df[,1]
	cohort.n <- cbind(cohort.n, df[,2])
	cohort.pfocal <- cbind(cohort.pfocal, df[,3])
	cohort.pmax <- cbind(cohort.pmax, df[,4])
}

# mask values of individuals if they weren't born
ped.sub <- ped[which(ped$ID %in% id),c(1,5)]
ped.sub <- ped.sub[match(id,ped.sub$ID),]
for (i in 1:length(time.periods)) {
	t = time.periods[i]
	idx <- which(ped.sub$COHORT > t)
	if (length(idx) > 0) {
		cohort.n[idx,i] <- NA
		cohort.pfocal[idx,i] <- NA
		cohort.pmax[idx,i] <- NA	
	}
}

cohort.n <- cbind(data.frame(ID=id),as.data.frame(cohort.n)) # add sample names
colnames(cohort.n) <- c("ID",paste0("cohort.",time.periods))

cohort.pfocal <- cbind(data.frame(ID=id),as.data.frame(cohort.pfocal)) # add sample names
colnames(cohort.pfocal) <- c("ID",paste0("cohort.",time.periods))

cohort.pmax <- cbind(data.frame(ID=id),as.data.frame(cohort.pmax)) # add sample names
colnames(cohort.pmax) <- c("ID",paste0("cohort.",time.periods))

# proportion with respect to focal ancestors plot

# get ID of top contributors to 2022 cohort
id.sort <- cohort.pfocal$ID[order(-cohort.pfocal$cohort.2022)] # individuals ordered by contribution in 2022
cohort.pfocal$rank.2022 <- match(cohort.pfocal$ID,id.sort)

#> id.sort[1:10]
# [1] "RLS-K" "WSA-K" "K-SLA" "OK-RS" "BK-FS" "SK-RG" "SR-PK" "K-RSW" "K-SBF"
#[10] "BK-LS"


# set colors for individuals (lines) of interest: top 16 contributors to 2022 population, which contributed over 75% of ancestry since 2015.
cohort.pfocal$color <- "gray30"
cohort.pfocal$color[which(cohort.pfocal$ID == "RLS-K")] <- "red3"
cohort.pfocal$color[which(cohort.pfocal$ID == "WSA-K")] <- "blue1"
cohort.pfocal$color[which(cohort.pfocal$ID == "K-SLA")] <- "cyan"
cohort.pfocal$color[which(cohort.pfocal$ID == "OK-RS")] <- "steelblue1"
cohort.pfocal$color[which(cohort.pfocal$ID == "SK-RG")] <- "darkorange"
cohort.pfocal$color[which(cohort.pfocal$ID == "BK-FS")] <- "indianred4"
cohort.pfocal$color[which(cohort.pfocal$ID == "K-RSW")] <- "peru"
cohort.pfocal$color[which(cohort.pfocal$ID == "K-SBF")] <- "tan"
cohort.pfocal$color[which(cohort.pfocal$ID == "SR-PK")] <- "purple"
cohort.pfocal$color[which(cohort.pfocal$ID == "BK-LS")] <- "mediumpurple1"
cohort.pfocal$color[which(cohort.pfocal$ID == "K-GSW")] <- "plum2"
cohort.pfocal$color[which(cohort.pfocal$ID == "WSF-K")] <- "magenta"
cohort.pfocal$color[which(cohort.pfocal$ID == "LK-SG")] <- "deeppink3"
cohort.pfocal$color[which(cohort.pfocal$ID == "BK-AS")] <- "hotpink"
cohort.pfocal$color[which(cohort.pfocal$ID == "WK-LS")] <- "darkmagenta"
cohort.pfocal$color[which(cohort.pfocal$ID == "F-BPS")] <- "darkblue"

# set line width
cohort.pfocal$lw <- 1
cohort.pfocal$lw[which(cohort.pfocal$ID == "RLS-K")] <- 2
cohort.pfocal$lw[which(cohort.pfocal$ID == "WSA-K")] <- 2
cohort.pfocal$lw[which(cohort.pfocal$ID == "K-SLA")] <- 2
cohort.pfocal$lw[which(cohort.pfocal$ID == "OK-RS")] <- 2
cohort.pfocal$lw[which(cohort.pfocal$ID == "SK-RG")] <- 2
cohort.pfocal$lw[which(cohort.pfocal$ID == "BK-FS")] <- 2
cohort.pfocal$lw[which(cohort.pfocal$ID == "K-RSW")] <- 2
cohort.pfocal$lw[which(cohort.pfocal$ID == "K-SBF")] <- 2
cohort.pfocal$lw[which(cohort.pfocal$ID == "SR-PK")] <- 2
cohort.pfocal$lw[which(cohort.pfocal$ID == "BK-LS")] <- 2
cohort.pfocal$lw[which(cohort.pfocal$ID == "K-GSW")] <- 2
cohort.pfocal$lw[which(cohort.pfocal$ID == "WSF-K")] <- 2
cohort.pfocal$lw[which(cohort.pfocal$ID == "LK-SG")] <- 2
cohort.pfocal$lw[which(cohort.pfocal$ID == "BK-AS")] <- 2
cohort.pfocal$lw[which(cohort.pfocal$ID == "WK-LS")] <- 2
cohort.pfocal$lw[which(cohort.pfocal$ID == "F-BPS")] <- 2

# set colors for individuals (lines) of interest (top 10 contributors to 2022 cohort) # deprecated
#cohort.pfocal$color <- "gray30" # use for top 10
#cohort.pfocal$color <- "black" # use for top 3
#cohort.pfocal$color[which(cohort.pfocal$ID == "RLS-K")] <- "red"
#cohort.pfocal$color[which(cohort.pfocal$ID == "WSA-K")] <- "purple"
#cohort.pfocal$color[which(cohort.pfocal$ID == "K-SLA")] <- "steelblue1" # use for top 3
#cohort.pfocal$color[which(cohort.pfocal$ID == "K-SLA")] <- "cyan" # use for top 10
# uncomment individuals below to denote top 10 contributors
#cohort.pfocal$color[which(cohort.pfocal$ID == "OK-RS")] <- "orange"
#cohort.pfocal$color[which(cohort.pfocal$ID == "BK-FS")] <- "royalblue1"
#cohort.pfocal$color[which(cohort.pfocal$ID == "SK-RG")] <- "magenta"
#cohort.pfocal$color[which(cohort.pfocal$ID == "SR-PK")] <- "red4"
#cohort.pfocal$color[which(cohort.pfocal$ID == "K-RSW")] <- "turquoise3"
#cohort.pfocal$color[which(cohort.pfocal$ID == "K-SBF")] <- "palevioletred1"
#cohort.pfocal$color[which(cohort.pfocal$ID == "BK-LS")] <- "blue"

# set line width # deprecated
#cohort.pfocal$lw = 1
#cohort.pfocal$lw[which(cohort.pfocal$ID == "RLS-K")] <- 2
#cohort.pfocal$lw[which(cohort.pfocal$ID == "WSA-K")] <- 2
#cohort.pfocal$lw[which(cohort.pfocal$ID == "K-SLA")] <- 2
# uncomment individuals below to denote top 10 contributors
#cohort.pfocal$lw[which(cohort.pfocal$ID == "OK-RS")] <- 2
#cohort.pfocal$lw[which(cohort.pfocal$ID == "BK-FS")] <- 2
#cohort.pfocal$lw[which(cohort.pfocal$ID == "SK-RG")] <- 2
#cohort.pfocal$lw[which(cohort.pfocal$ID == "SR-PK")] <- 2
#cohort.pfocal$lw[which(cohort.pfocal$ID == "K-RSW")] <- 2
#cohort.pfocal$lw[which(cohort.pfocal$ID == "K-SBF")] <- 2
#cohort.pfocal$lw[which(cohort.pfocal$ID == "BK-LS")] <- 2

# set line type according to resident vs translocated
cohort.pfocal$ltype <- unname(sapply(id,function(x,df){df$Biological_Origin_Status}[which(df$COLOR_ID == x)],df=meta))
cohort.pfocal$ltype[which(cohort.pfocal$ltype == "T" | cohort.pfocal$ltype == "Donor_Population")] <- 1
cohort.pfocal$ltype[which(cohort.pfocal$ltype == "IE" | cohort.pfocal$ltype == "LR")] <- 2
cohort.pfocal$ltype <- as.numeric(cohort.pfocal$ltype)

# plot proportion of focal ancestor contributions over time

#pdf(file='/home/tyler/Dropbox/research/jay/mosaic/pedigree/results/lr_temporal/T_IE_20230512_LR_contributions.pdf', width=16, height=7) #deprecated
#png(file='/home/tyler/Dropbox/research/jay/mosaic/figures/T_IE_cohort_contribution_pfocal.png',width=16, height=7, units='in', res=300)
#png(file='/home/tyler/Dropbox/research/jay/mosaic/figures/T_IE_cohort_contribution_pfocal_v2.png',width=16, height=7, units='in', res=300)
png(file='/home/tyler/Dropbox/research/jay/mosaic/figures/T_IE_cohort_contribution_pfocal_v3.png',width=16, height=7, units='in', res=300)
x11(width=16,height=7)
par(mgp = c(2.75,1,0))
plot(1, type="n", xlim=c(time.periods[1],time.periods[length(time.periods)]), ylim=c(0,max(cohort.pfocal[,tidx],na.rm=TRUE)+0.0),
xlab="Year", ylab="Proportion ancestor contribution to cohort", main="",xaxt='n', cex.axis=1.3, cex.lab=1.5)
axis(side=1,at=time.periods,labels=time.periods,cex=1.5,cex.axis=1.3)

for (i in 1:nrow(cohort.pfocal)) {
	# draw lines
	lines(x=time.periods, y=cohort.pfocal[i,tidx],col=alpha(cohort.pfocal$color[i],0.6), lty=cohort.pfocal$ltype[i], lwd=cohort.pfocal$lw[i])
}

# plot mean line
#lines(x=time.periods, y=sapply(tidx,function(x,df){mean(df[,x],na.rm=TRUE)},df=cohort.pfocal), lty=6, col="black", lwd=2) # THIS MEAN SHOULD EXCLUDE 0/NA

# add legend
#legend('topright',c("Translocated","Resident","Mean"),lty=c(1,2,6),bty='n',cex=1.3,seg.len=2.9,lwd=1.7)
legend('topright',c("Translocated","Resident"),lty=c(1,2),bty='n',cex=1.3,seg.len=2.9,lwd=1.7)

# dev.off()

# proportion with respect to maximum ancestor pop contribution (Hunter normalization) plot

# get ID of top contributors to 2022 cohort
id.sort.hunter <- cohort.pmax$ID[order(-cohort.pmax$cohort.2022)] # individuals ordered by contribution in 2022
cohort.pmax$rank.2022 <- match(cohort.pmax$ID,id.sort.hunter)

#> id.sort.hunter[1:10]
# [1] "BK-LS" "RLS-K" "OK-RS" "K-RSW" "WSA-K" "K-SLA" "BK-AS" "BK-FS" "SK-RG"
#[10] "WK-LS"

# set colors for individuals (lines) of interest (top 10 contributors to 2022 cohort)
cohort.pmax$color <- "gray30"
cohort.pmax$color[which(cohort.pmax$ID == "BK-LS")] <- "blue"
cohort.pmax$color[which(cohort.pmax$ID == "RLS-K")] <- "red"
cohort.pmax$color[which(cohort.pmax$ID == "OK-RS")] <- "orange"
cohort.pmax$color[which(cohort.pmax$ID == "K-RSW")] <- "turquoise3"
cohort.pmax$color[which(cohort.pmax$ID == "WSA-K")] <- "purple"
cohort.pmax$color[which(cohort.pmax$ID == "K-SLA")] <- "cyan"
cohort.pmax$color[which(cohort.pmax$ID == "BK-AS")] <- "yellow3"
cohort.pmax$color[which(cohort.pmax$ID == "BK-FS")] <- "royalblue1"
cohort.pmax$color[which(cohort.pmax$ID == "SK-RG")] <- "magenta"
cohort.pmax$color[which(cohort.pmax$ID == "WK-LS")] <- "salmon2"

# set line width
cohort.pmax$lw = 1
cohort.pmax$lw[which(cohort.pmax$ID == "BK-LS")] <- 2
cohort.pmax$lw[which(cohort.pmax$ID == "RLS-K")] <- 2
cohort.pmax$lw[which(cohort.pmax$ID == "OK-RS")] <- 2
cohort.pmax$lw[which(cohort.pmax$ID == "K-RSW")] <- 2
cohort.pmax$lw[which(cohort.pmax$ID == "WSA-K")] <- 2
cohort.pmax$lw[which(cohort.pmax$ID == "K-SLA")] <- 2
cohort.pmax$lw[which(cohort.pmax$ID == "BK-AS")] <- 2
cohort.pmax$lw[which(cohort.pmax$ID == "BK-FS")] <- 2
cohort.pmax$lw[which(cohort.pmax$ID == "SK-RG")] <- 2
cohort.pmax$lw[which(cohort.pmax$ID == "WK-LS")] <- 2

# set line type according to resident vs translocated
cohort.pmax$ltype <- unname(sapply(id,function(x,df){df$Biological_Origin_Status}[which(df$COLOR_ID == x)],df=meta))
cohort.pmax$ltype[which(cohort.pmax$ltype == "T" | cohort.pmax$ltype == "Donor_Population")] <- 1
cohort.pmax$ltype[which(cohort.pmax$ltype == "IE" | cohort.pmax$ltype == "LR")] <- 2
cohort.pmax$ltype <- as.numeric(cohort.pmax$ltype)

# plot proportion of focal ancestor contributions over time

png(file='/home/tyler/Dropbox/research/jay/mosaic/figures/T_IE_cohort_contribution_pmax.png',width=16, height=7, units='in', res=300)
x11(width=16,height=7)
par(mgp = c(2.75,1,0))
plot(1, type="n", xlim=c(time.periods[1],time.periods[length(time.periods)]), ylim=c(0,max(cohort.pmax[,tidx],na.rm=TRUE)+0.08),
xlab="Year", ylab="Proportion ancestor contribution relative to pop max", main="",xaxt='n', cex.axis=1.3, cex.lab=1.5)
axis(side=1,at=time.periods,labels=time.periods,cex=1.5,cex.axis=1.3)

for (i in 1:nrow(cohort.pmax)) {
	# draw lines
	lines(x=time.periods, y=cohort.pmax[i,tidx],col=alpha(cohort.pmax$color[i],0.6), lty=cohort.pmax$ltype[i], lwd=cohort.pmax$lw[i])
}
# plot mean line
lines(x=time.periods, y=sapply(tidx,function(x,df){mean(df[,x],na.rm=TRUE)},df=cohort.pmax), lty=6, col="black", lwd=2) # THIS MEAN SHOULD EXCLUDE 0/NA

# add legend

# legend configuration 1
# legend(x=2019.5, y=0.9,c("Translocated","Resident","Mean"),lty=c(1,2,6),bty='n',cex=1.3,lwd=1.7,seg.len=2.9)

# legend configuration 2
legend(x=2004, y=1.15,"Translocated",lty=1,bty='n',cex=1.3, lwd=1.7, seg.len=2.9)
legend(x=2008, y=1.15,"Resident",lty=2,bty='n',cex=1.3, lwd=1.7, seg.len=2.9)
legend(x=2011.4, y=1.15,"Mean",lty=6,bty='n',cex=1.3, lwd=1.7, seg.len=2.9)

#dev.off()

--- end R code for T and IE temporal contributions to cohort ---

--- begin R code for T, IE, and I temporal contributions to cohort ---

library(scales) # for alpha colors

meta <- read.table("/home/tyler/Dropbox/research/jay/mosaic/metadata/jayid_map_20230512.txt",head=TRUE,sep="\t")
fdir='/home/tyler/Dropbox/research/jay/mosaic/pedigree/results/lr_temporal/'
ped <- read.table('/home/tyler/Dropbox/research/jay/mosaic/pedigree/mosaic_ped_20230512.tsv', head=TRUE, na.strings='*')

cohort.n <- NULL # data frame of number of expected genomic copies
cohort.pfocal <- NULL # data frame of contributions normalized by focal ancestors
cohort.pmax <- NULL # data frame of contribution normalized by max cohort pop contribution

# read in pedstat files for time points 2004-2022
time.periods = 2004:2022
tidx <- 2:(length(time.periods)+1) # these are the contribution columns in matrix
id <- NULL
for (t in time.periods) {
	df <- read.table(paste0(fdir,'T_IE_I_20230512_to_',t,'_LR_contribution.pedstat1'),head=TRUE)
	if (is.null(id)) id <- df[,1]
	cohort.n <- cbind(cohort.n, df[,2])
	cohort.pfocal <- cbind(cohort.pfocal, df[,3])
	cohort.pmax <- cbind(cohort.pmax, df[,4])
}

# mask values of individuals if they weren't born
ped.sub <- ped[which(ped$ID %in% id),c(1,5)]
ped.sub <- ped.sub[match(id,ped.sub$ID),]
for (i in 1:length(time.periods)) {
	t = time.periods[i]
	idx <- which(ped.sub$COHORT > t)
	if (length(idx) > 0) {
		cohort.n[idx,i] <- NA
		cohort.pfocal[idx,i] <- NA
		cohort.pmax[idx,i] <- NA	
	}
}

cohort.n <- cbind(data.frame(ID=id),as.data.frame(cohort.n)) # add sample names
colnames(cohort.n) <- c("ID",paste0("cohort.",time.periods))

cohort.pfocal <- cbind(data.frame(ID=id),as.data.frame(cohort.pfocal)) # add sample names
colnames(cohort.pfocal) <- c("ID",paste0("cohort.",time.periods))

cohort.pmax <- cbind(data.frame(ID=id),as.data.frame(cohort.pmax)) # add sample names
colnames(cohort.pmax) <- c("ID",paste0("cohort.",time.periods))

# proportion with respect to focal ancestors plot

# get ID of top contributors to 2022 cohort
id.sort <- cohort.pfocal$ID[order(-cohort.pfocal$cohort.2022)] # individuals ordered by contribution in 2022
cohort.pfocal$rank.2022 <- match(cohort.pfocal$ID,id.sort)

# set colors for individuals (lines) of interest (top 10 contributors to 2022 cohort)
cohort.pfocal$color <- "gray30"
cohort.pfocal$color[which(cohort.pfocal$ID == "RLS-K")] <- "red"
cohort.pfocal$color[which(cohort.pfocal$ID == "WSA-K")] <- "purple"
cohort.pfocal$color[which(cohort.pfocal$ID == "K-SLA")] <- "cyan"
cohort.pfocal$color[which(cohort.pfocal$ID == "PF-SH")] <- "darkcyan"
cohort.pfocal$color[which(cohort.pfocal$ID == "PK-SG")] <- "cornflowerblue"
cohort.pfocal$color[which(cohort.pfocal$ID == "OK-RS")] <- "orange"
cohort.pfocal$color[which(cohort.pfocal$ID == "BK-FS")] <- "royalblue1"
cohort.pfocal$color[which(cohort.pfocal$ID == "SK-RG")] <- "magenta"
cohort.pfocal$color[which(cohort.pfocal$ID == "GF-SG")] <- "royalblue4"
cohort.pfocal$color[which(cohort.pfocal$ID == "SR-PK")] <- "red4"


# set line type according to resident vs translocated
cohort.pfocal$ltype <- unname(sapply(id,function(x,df){df$Biological_Origin_Status}[which(df$COLOR_ID == x)],df=meta))
cohort.pfocal$ltype[which(cohort.pfocal$ltype == "T" | cohort.pfocal$ltype == "Donor_Population")] <- 1
cohort.pfocal$ltype[which(cohort.pfocal$ltype == "IE" | cohort.pfocal$ltype == "LR")] <- 2
cohort.pfocal$ltype[which(cohort.pfocal$ltype == "I")] <- 3
cohort.pfocal$ltype <- as.numeric(cohort.pfocal$ltype)

# set line width
cohort.pfocal$lw = 1
cohort.pfocal$lw[which(cohort.pfocal$ltype == 3)] <- 1.8 # need to increase size of dots for visibility
isize=2.8
cohort.pfocal$lw[which(cohort.pfocal$ID == "RLS-K")] <- 1.8
cohort.pfocal$lw[which(cohort.pfocal$ID == "WSA-K")] <- 1.8
cohort.pfocal$lw[which(cohort.pfocal$ID == "K-SLA")] <- 1.8
cohort.pfocal$lw[which(cohort.pfocal$ID == "PF-SH")] <- isize # immigrant
cohort.pfocal$lw[which(cohort.pfocal$ID == "PK-SG")] <- isize # immigrant
cohort.pfocal$lw[which(cohort.pfocal$ID == "OK-RS")] <- 1.8
cohort.pfocal$lw[which(cohort.pfocal$ID == "BK-FS")] <- 1.8
cohort.pfocal$lw[which(cohort.pfocal$ID == "SK-RG")] <- 1.8
cohort.pfocal$lw[which(cohort.pfocal$ID == "GF-SG")] <- isize # immigrant
cohort.pfocal$lw[which(cohort.pfocal$ID == "SR-PK")] <- 1.8

# plot proportion of focal ancestor contributions over time

#pdf(file='/home/tyler/Dropbox/research/jay/mosaic/pedigree/results/lr_temporal/T_IE_I_20230512_LR_cohort_contributions.pdf', width=16, height=7)
x11(width=16,height=7)
par(mgp = c(2.75,1,0))
plot(1, type="n", xlim=c(time.periods[1],time.periods[length(time.periods)]), ylim=c(0,max(cohort.pfocal[,tidx],na.rm=TRUE)+0.05),
xlab="Year", ylab="Proportion ancestor contribution to cohort", main="",xaxt='n', cex.axis=1.3, cex.lab=1.5)
axis(side=1,at=time.periods,labels=time.periods,cex=1.5,cex.axis=1.3)

for (i in 1:nrow(cohort.pfocal)) {
	# draw lines
	lines(x=time.periods, y=cohort.pfocal[i,tidx],col=alpha(cohort.pfocal$color[i],0.6), lty=cohort.pfocal$ltype[i], lwd=cohort.pfocal$lw[i])
}
# plot mean line
lines(x=time.periods, y=sapply(tidx,function(x,df){mean(df[,x],na.rm=TRUE)},df=cohort.pfocal), lty=6, col="black", lwd=1.8)

# add legend
legend('topright',c("Translocated","Resident","Immigrant","Mean"),lty=c(1,2,3,6),bty='n',cex=1.2)

# proportion with respect to maximum ancestor pop contribution (Hunter normalization) plot

# get ID of top contributors to 2022 cohort
id.sort.hunter <- cohort.pmax$ID[order(-cohort.pmax$cohort.2022)] # individuals ordered by contribution in 2022
cohort.pmax$rank.2022 <- match(cohort.pmax$ID,id.sort.hunter)

# set colors for individuals (lines) of interest (top 10 contributors to 2022 cohort)
cohort.pmax$color <- "gray30"
cohort.pmax$color[which(cohort.pmax$ID == "RLS-K")] <- "red"
cohort.pmax$color[which(cohort.pmax$ID == "WSA-K")] <- "purple"
cohort.pmax$color[which(cohort.pmax$ID == "OK-RS")] <- "orange"
cohort.pmax$color[which(cohort.pmax$ID == "K-SLA")] <- "cyan"
cohort.pmax$color[which(cohort.pmax$ID == "BK-FS")] <- "royalblue1"
cohort.pmax$color[which(cohort.pmax$ID == "SK-RG")] <- "magenta"
cohort.pmax$color[which(cohort.pmax$ID == "BK-LS")] <- "blue"
cohort.pmax$color[which(cohort.pmax$ID == "SR-PK")] <- "red4"
cohort.pmax$color[which(cohort.pmax$ID == "WK-LS")] <- "salmon2"
cohort.pmax$color[which(cohort.pmax$ID == "K-RSW")] <- "turquoise3"

# set line type according to resident vs translocated
cohort.pmax$ltype <- unname(sapply(id,function(x,df){df$Biological_Origin_Status}[which(df$COLOR_ID == x)],df=meta))
cohort.pmax$ltype[which(cohort.pmax$ltype == "T" | cohort.pmax$ltype == "Donor_Population")] <- 1
cohort.pmax$ltype[which(cohort.pmax$ltype == "IE" | cohort.pmax$ltype == "LR")] <- 2
cohort.pmax$ltype[which(cohort.pmax$ltype == "I")] <- 3
cohort.pmax$ltype <- as.numeric(cohort.pmax$ltype)

# set line width
cohort.pmax$lw = 1
cohort.pmax$lw[which(cohort.pmax$ltype == 3)] <- 1.8 # need to increase size of dots for visibility
cohort.pmax$lw[which(cohort.pmax$ID == "RLS-K")] <- 1.8
cohort.pmax$lw[which(cohort.pmax$ID == "WSA-K")] <- 1.8
cohort.pmax$lw[which(cohort.pmax$ID == "OK-RS")] <- 1.8
cohort.pmax$lw[which(cohort.pmax$ID == "K-SLA")] <- 1.8
cohort.pmax$lw[which(cohort.pmax$ID == "BK-FS")] <- 1.8
cohort.pmax$lw[which(cohort.pmax$ID == "SK-RG")] <- 1.8
cohort.pmax$lw[which(cohort.pmax$ID == "BK-LS")] <- 1.8
cohort.pmax$lw[which(cohort.pmax$ID == "SR-PK")] <- 1.8
cohort.pmax$lw[which(cohort.pmax$ID == "WK-LS")] <- 1.8
cohort.pmax$lw[which(cohort.pmax$ID == "K-RSW")] <- 1.8

# plot proportion of focal ancestor contributions over time

x11(width=16,height=7)
par(mgp = c(2.75,1,0))
plot(1, type="n", xlim=c(time.periods[1],time.periods[length(time.periods)]), ylim=c(0,max(cohort.pmax[,tidx],na.rm=TRUE)+0.05),
xlab="Year", ylab="Proportion ancestor contribution relative to pop max", main="",xaxt='n', cex.axis=1.3, cex.lab=1.5)
axis(side=1,at=time.periods,labels=time.periods,cex=1.5,cex.axis=1.3)

for (i in 1:nrow(cohort.pmax)) {
	# draw lines
	lines(x=time.periods, y=cohort.pmax[i,tidx],col=alpha(cohort.pmax$color[i],0.6), lty=cohort.pmax$ltype[i], lwd=cohort.pmax$lw[i])
}
# plot mean line
lines(x=time.periods, y=sapply(tidx,function(x,df){mean(df[,x],na.rm=TRUE)},df=cohort.pmax), lty=6, col="black", lwd=1.8)

# add legend
legend('topright',c("Translocated","Resident","Immigrant","Mean"),lty=c(1,2,3,6),bty='n',cex=1.2)

--- end R code for T, IE, and I temporal contributions to cohort ---

### COMPARE PEDIGREE VS GENOMIC-BASED CONTRIBUTIONS

workdir='/home/tyler/Dropbox/research/jay/mosaic/pedigree/contribution'

--- begin R code for comparing contributions ---

#gendat <- read.table('/home/tyler/Dropbox/research/jay/mosaic/popgen/relatedness/skew/T_E_I_M4_to_contemporary_contributions_c0.0243058.skewstat3',head=TRUE)
#ped1 <- read.table('/home/tyler/Dropbox/research/jay/mosaic/pedigree/results/sequenced_contemporary/T_IE_I_20230512_to_seq_contemporary.pedstat1',head=TRUE)
ped1 <- read.table('/home/tyler/Dropbox/research/jay/mosaic/pedigree/results/sequenced_contemporary/T_IE_20230512_to_seq_contemporary.pedstat1',head=TRUE)
gendat <- read.table('/home/tyler/Dropbox/research/jay/mosaic/popgen/relatedness/skew/CR_T_IE_to_C_contributions_c0.0243058.skewstat3',head=TRUE)
genmeta <- read.table('~/Dropbox/research/jay/mosaic/metadata/M4_sequenced_FSJsamples_metadata.txt',head=TRUE)
jayid <- read.csv('/home/tyler/Dropbox/research/jay/mosaic/metadata/jayid_map_20230512.txt',head=TRUE,na.strings = "*",sep="\t")
jayid$COLOR_ID <- toupper(jayid$COLOR_ID)

# translate color band, federal, and lab IDs
ped1$FED_ID <- unname(sapply(ped1$ID,function(x,df){ifelse(length(grep("UNBAND",x))>0,NA,df$FEDERAL_ID[which(df$COLOR_ID == x)])},df=jayid))
gendat$FED_ID = unname(sapply(gendat$ID,function(x,df){df$FEDERAL_ID[which(df$COLOR_ID == x)]},df=jayid))
ped1$LAB_ID = unname(sapply(ped1$ID,function(x,df){df$LAB_ID[which(df$COLOR_ID == x)]},df=jayid))

# assign ranks based on contribution (equal values will have equal rank)
gendat.sort <- gendat[order(-gendat$Swtr),] # sort by Swtr
swtr.unique <- unique(gendat.sort$Swtr)
gendat.sort$swtr.rank = NA
for (i in 1:length(swtr.unique)) {gendat.sort$swtr.rank[which(gendat.sort$Swtr == swtr.unique[i])] = i}

ped1.sort <- ped1[order(-ped1$P_ANC_FOCAL),]
p_focal.unique = unique(ped1.sort$P_ANC_FOCAL)
ped1.sort$ped.rank = NA
for (i in 1:length(p_focal.unique)) {ped1.sort$ped.rank[which(ped1.sort$P_ANC_FOCAL == p_focal.unique[i])] = i}

ped1.sort$gen.rank = unname(sapply(ped1.sort$ID,function(x,df){ifelse(is.na(x),NA,df$swtr.rank[which(df$ID == x)])},df=gendat.sort))
ped1.sort$Swtr = unname(sapply(ped1.sort$ID,function(x,df){ifelse(is.na(x),NA,df$Swtr[which(df$ID == x)])},df=gendat.sort))

# add M4 samples that were not in pedigree analysis - not necessary for core region only (T and IE) analysis
#m4_labid <- gendat.sort$ID[grep("M4_", gendat.sort$ID)]
#m4_missing <- NULL
#for (id in m4_labid) {
#	colid <- jayid$COLOR_ID[which(jayid$LAB_ID == id)]
#	fedid <- jayid$FEDERAL_ID[which(jayid$LAB_ID == id)]
#	idx = which(gendat.sort$ID == id)
#	if (fedid %in% ped1.sort$FED_ID == FALSE) {
#		m4_missing <- rbind(m4_missing, m4_missing <- data.frame(ID = colid, N_GENOME_COPIES = NA, P_ANC_FOCAL = NA, P_ANC_MAX = NA, FED_ID = fedid, LAB_ID = id,
#		   ped.rank = NA, gen.rank = gendat.sort$swtr.rank[idx], Swtr = gendat.sort$Swtr[idx]))
#	}
#}

#ped1.sort <- rbind(ped1.sort, m4_missing)

# subset of ancestors in pedigree and genetic analysis
share <- ped1.sort[which(!is.na(ped1.sort$ped.rank) & !is.na(ped1.sort$gen.rank)),]

# test for correlation between K statistic and the the number of genomic copies for individuals common to both datasets
> cor.test(x=share$Swtr, y=share$N_GENOME_COPIES, method="kendall")
#
#	Kendall's rank correlation tau
#
#data:  share$Swtr and share$N_GENOME_COPIES
#z = 3.3456, p-value = 0.000821
#alternative hypothesis: true tau is not equal to 0
#sample estimates:
#      tau 
#0.4194696 
#
#Warning message:
#In cor.test.default(x = share$Swtr, y = share$N_GENOME_COPIES, method = "kendall") :
#  Cannot compute exact p-value with ties

# line plot

library(scales)

# set point colors according to biological origin (grey indicates no contribution)

rescol = "cyan3"
transcol = "darkorange2"
ped1.sort$biotype_col = unname(sapply(ped1.sort$ID,function(x,df){df$Biological_Origin_Status[which(df$COLOR_ID==x)]},df=jayid))
ped1.sort$biotype_col <- replace(ped1.sort$biotype_col, which(ped1.sort$biotype_col == "IE" | ped1.sort$biotype_col == "LR"),rescol)
ped1.sort$biotype_col <- replace(ped1.sort$biotype_col, which(ped1.sort$biotype_col == "T"),transcol)

ped.cutoff = (ped1.sort$ped.rank[which(ped1.sort$N_GENOME_COPIES == 0)])[1] # pedigree individuals at this rank or above did not contribute
gen.cutoff = ped1.sort$gen.rank[which(ped1.sort$Swtr == 0)][1] # individuals at this rank or above did not make contribution based K-statistic

pedcol.bg <- alpha(ped1.sort$biotype_col,0.65)
#pedcol.bg[which(is.na(ped1.sort$gen.rank))] <- alpha("grey40",0) # makes totally tranparent (i.e. no colored background)
pedcol.bg[which(ped1.sort$ped.rank >= ped.cutoff)] <- alpha("grey40",0)

pedcol <- alpha(ped1.sort$biotype_col,0.65)
pedcol[which(ped1.sort$ped.rank >= ped.cutoff)] <- alpha("grey40",0.65)

gencol.bg <- alpha(ped1.sort$biotype_col,0.65)
#gencol.bg[which(is.na(ped1.sort$ped.rank))] <- alpha("grey40",0) # makes totally tranparent (i.e. no colored background)
gencol.bg[which(ped1.sort$gen.rank >= gen.cutoff)] <- alpha("grey40",0)

gencol <- alpha(ped1.sort$biotype_col,0.65)
gencol[which(ped1.sort$gen.rank >= gen.cutoff)] <- alpha("grey40",0.65)

# set point sizes according to contribution
ped.scale <- ped1.sort$P_ANC_FOCAL/max(ped1.sort$P_ANC_FOCAL)
ped.scale[which(ped.scale == 0)] <- min(ped.scale[which(ped.scale > 0)])

gen.scale <- ped1.sort$Swtr/max(ped1.sort$Swtr,na.rm=TRUE)
gen.scale[which(gen.scale == 0)] <- min(gen.scale[which(gen.scale > 0)])

# use x-axis jitter to show individuals with tied ranks
xa = 0.3
xb = 0.8

# jitter for pedigree ranks
xa.jitter <- rep(xa,nrow(ped1.sort))
urank.ped <- unique(ped1.sort$ped.rank)
urank.ped.naidx <- which(is.na(urank.ped))
if (length(urank.ped.naidx) > 0) urank.ped <- urank.ped[-urank.ped.naidx]
for (i in urank.ped) {
        n = 1                                     
        xshift = 0 
        for (idx in which(ped1.sort$ped.rank == i)) {
                if (n %% 2) {
                        xa.jitter[idx] = xa + xshift
                } else {
                        xa.jitter[idx] = xa - xshift
                        xshift = xshift + 0.005
                }
                n = n+1
        }
}

# jitter for genetic ranks
xb.jitter <- rep(xb,nrow(ped1.sort))
urank.gen <- unique(ped1.sort$gen.rank)
urank.gen.naidx <- which(is.na(urank.gen))
if (length(urank.gen.naidx) > 0) urank.gen <- urank.gen[-urank.gen.naidx]
for (i in urank.gen) {
        n = 1
        xshift = 0
        for (idx in which(ped1.sort$gen.rank == i)) {
                if (n %% 2) {
                        xb.jitter[idx] = xb + xshift
                } else {
                        xb.jitter[idx] = xb - xshift
                        xshift = xshift + 0.005
                }
                n = n+1
        }
}


# make canvas and plot
#pdf(file='/home/tyler/Dropbox/research/jay/mosaic/pedigree/results/sequenced_contemporary/pedigree_vs_genetic_skew_rank.pdf') #deprecated
#png(file='/home/tyler/Dropbox/research/jay/mosaic/figures/ped_vs_genetic_skew_comparison.png',width=6, height=7, units='in', res=300)

x11(width=6,height=7)
maxrank = max(ped1.sort$ped.rank, ped1.sort$gen.rank, na.rm=TRUE)
y.marks = c(1,seq(from=5,to=2*round(maxrank/2),by=5))
plot(1,type="n", xlab="", ylab="Contribution rank", ylim=c(maxrank, -1), xlim=c(0,1),xaxt='n', yaxt='n', cex.lab=1.3) # blank canvas
axis(side=1,at=c(xa,xb),labels=c("Pedigree","Genetic"),cex.axis=1.3) # x-axis
axis(side=2,at=y.marks,labels=y.marks,cex.axis=1.3) # y-axis

# add points

point.width=1
points(x=xa.jitter,y=ped1.sort$ped.rank, pch=21, col=pedcol, bg=pedcol.bg, lwd=point.width, cex=3.5*ped.scale)
points(x=xb.jitter,y=ped1.sort$gen.rank, pch=21, col=gencol, bg=gencol.bg, lwd=point.width, cex=3.5*gen.scale)
for (i in 1:nrow(share)) {
	lcol = "black"
	lwidth = 1.3
	if (share$ped.rank[i] >= ped.cutoff) {
		# mask lines from pedigree individuals that did not contribute
		lcol = alpha("grey20",0.3)
		lwidth = 1
	}
	lines(x=c(xa,xb),y=c(share$ped.rank[i],share$gen.rank[i]), col=lcol, lwd=lwidth)
}

# add annotations
text(x=xa,y=-1.2,paste0("n=",length(which(!is.na(ped1.sort$ped.rank)))),cex=1.2)
text(x=xb,y=-1.2,paste0("n=",length(which(!is.na(ped1.sort$gen.rank)))),cex=1.2)
legend('bottomleft',c("Resident","Translocated", "No contribution"),pch=21,col=c(rescol,transcol,alpha("grey40",0.65)),pt.bg=c(rescol,transcol,alpha("grey40",0)),bty='n', cex=1, pt.cex=1.3)

#dev.off()

# print top ten contributors based on pedigree
#ped1.sort$ID[order(ped1.sort$ped.rank)][1:10]
# [1] "RLS-K" "WSA-K" "OK-RS" "K-SLA" "K-RSW" "SK-RG" "BK-FS" "SR-PK" "F-BPS"
#[10] "BK-LS"


# print top ten contributors based on genetic (k-statistic) analysis
#> ped1.sort$ID[order(ped1.sort$gen.rank)][1:10]
# [1] "WSA-K" "K-RSW" "GK-YS" "SR-PK" "K-SBF" "K-SLA" "SK-WB" "K-SAG" "RK-YS"
#[10] "BK-FS"

--- end R code for comparing contributions ---

--- begin R code for comparing temporal contributions by ancestral type (translocated or resident) ---

meta <- read.table("/home/tyler/Dropbox/research/jay/mosaic/metadata/jayid_map_20230512.txt",head=TRUE,sep="\t")
popdir='/home/tyler/Dropbox/research/jay/mosaic/pedigree/results/pop_temporal/'
lrdir='/home/tyler/Dropbox/research/jay/mosaic/pedigree/results/lr_temporal/'
ped <- read.table('/home/tyler/Dropbox/research/jay/mosaic/pedigree/mosaic_ped_20230512.tsv', head=TRUE, na.strings='*')

pop.n <- NULL # data frame of number of expected genomic copies in population
cohort.n <- NULL # data frame of number of expecteed genomic copies

# read in pedstat files for time points 2002-2022
time.periods = 2002:2022
tidx <- 2:(length(time.periods)+1) # these are the contribution columns in matrix
id <- NULL
n.anc = 76
for (t in time.periods) {
	fname.pop = paste0(popdir,'T_IE_20230512_',t,'_pop_contribution.pedstat1')
	if (file.exists(fname.pop)) {
		df <- read.table(fname.pop,head=TRUE)
		if (is.null(id)) id <- df[,1]
		pop.n <- cbind(pop.n, df[,2])
	} else pop.n <- cbind(pop.n,rep(NA,n.anc))

	fname.lr = paste0(lrdir,'T_IE_20230512_to_',t,'_LR_contribution.pedstat1')
	if (file.exists(fname.lr)) {
		df <- read.table(fname.lr,head=TRUE)
		if (is.null(id)) id <- df[,1]
		cohort.n <- cbind(cohort.n, df[,2])
	} else cohort.n <- cbind(cohort.n,rep(NA,n.anc))
}

# mask values of individuals if they weren't born
ped.sub <- ped[which(ped$ID %in% id),c(1,5)]
ped.sub <- ped.sub[match(id,ped.sub$ID),]
for (i in 1:length(time.periods)) {
	t = time.periods[i]
	idx <- which(ped.sub$COHORT > t)
	if (length(idx) > 0) {
		pop.n[idx,i] <- NA
		cohort.n[idx,i] <- NA
	}
}


# collect biological origin info
meta.sub <- meta[which(meta$COLOR_ID %in% id),]
meta.sub <- meta.sub[match(id, meta.sub$COLOR_ID),]
biotype <- replace(meta.sub$Biological_Origin_Status, which(meta.sub$Biological_Origin_Status == "Donor_Population"), "T")
biotype <- replace(biotype, which(biotype == "IE" | biotype == "LR"), "R")

# add annotations
pop.n <- cbind(data.frame(ID=id, BIOTYPE=biotype),as.data.frame(pop.n)) # add sample names
colnames(pop.n) <- c("ID","BIOTYPE",paste0("cohort.",time.periods))

cohort.n <- cbind(data.frame(ID=id, BIOTYPE=biotype),as.data.frame(cohort.n)) # add sample names
colnames(cohort.n) <- c("ID","BIOTYPE",paste0("cohort.",time.periods))

# make biotype data.frame of proportions
r.idx = which(biotype=="R")
t.idx = which(biotype=="T")
pop.p <- NULL # dataframe of contribution by Resident vs translocated to population
cohort.p <- NULL # dataframe of contribution by Resident vs translocated to cohort

for (i in 3:ncol(pop.n)) {
	total.copies = sum(pop.n[,i],na.rm=TRUE)
	res.copies = sum(pop.n[r.idx,i],na.rm=TRUE)
	trans.copies = sum(pop.n[t.idx,i],na.rm=TRUE)
	if (total.copies > 0) {
		res.p = res.copies/total.copies
		trans.p = trans.copies/total.copies
	} else {
		res.p = NA
		trans.p = NA	
	}
	pop.p <- rbind(pop.p, data.frame(YEAR=time.periods[i-2], RESIDENT=res.p, TRANSLOCATED=trans.p))

	total.copies.cohort = sum(cohort.n[,i],na.rm=TRUE)
	res.copies.cohort = sum(cohort.n[r.idx,i],na.rm=TRUE)
	trans.copies.cohort = sum(cohort.n[t.idx,i],na.rm=TRUE)
	if (total.copies.cohort > 0) {
		res.p.cohort = res.copies.cohort/total.copies.cohort
		trans.p.cohort = trans.copies.cohort/total.copies.cohort
	} else {
		res.p.cohort = NA
		trans.p.cohort = NA	
	}
	cohort.p <- rbind(cohort.p, data.frame(YEAR=time.periods[i-2], RESIDENT=res.p.cohort, TRANSLOCATED=trans.p.cohort))
}

# plot proportions over time

#pdf(file='/home/tyler/Dropbox/research/jay/mosaic/pedigree/results/figures/pedigree_biotype_temporal_contributions.pdf', width=16, height=7)
#png(file='/home/tyler/Dropbox/research/jay/mosaic/pedigree/results/figures/pedigree_biotype_temporal_contributions.png', width=16, height=7, units='in', res=300)
x11(width=16,height=7)
par(mgp = c(2.75,1,0))
plot(1, type="n", xlim=c(time.periods[1],time.periods[length(time.periods)]), ylim=c(0,1),
xlab="Year", ylab="Expected genetic contribution proportion", main="",xaxt='n', cex.axis=1.3, cex.lab=1.5)
axis(side=1,at=time.periods,labels=time.periods,cex=1.5,cex.axis=1.3)

lines(x=pop.p$YEAR, y=pop.p$RESIDENT, col="plum3", lwd=3, lty=1) # resident contribution to population
lines(x=pop.p$YEAR, y=pop.p$TRANSLOCATED, col="black", lwd=3, lty=1) # translocated contribution to population
lines(x=cohort.p$YEAR, y=cohort.p$RESIDENT, col="plum3", lwd=3, lty=2) # resident contribution to cohort
lines(x=cohort.p$YEAR, y=cohort.p$TRANSLOCATED, col="black", lwd=3, lty=2) # translocated contribution to cohort

# add legend

legend(x=2003,y=1.05, "Resident to population", col="plum3", lty=1, lwd=3, bty='n', cex=1.1)
legend(x=2007.5,y=1.05, "Resident to cohort", col="plum3", lty=2, lwd=3, bty='n', cex=1.1)
legend(x=2011.5,y=1.05, "Translocated to population", col="black", lty=1, lwd=3, bty='n', cex=1.1)
legend(x=2016.5,y=1.05, "Translocated to cohort", col="black", lty=2, lwd=3, bty='n', cex=1.1)

#dev.off()

--- end R code for comparing temporal contributions by ancestral type (translocated or resident) ---

--- begin R code for comparing temporal contributions by ancestral type (translocated, resident, immigrant) ---

meta <- read.table("/home/tyler/Dropbox/research/jay/mosaic/metadata/jayid_map_20230512.txt",head=TRUE,sep="\t")
popdir='/home/tyler/Dropbox/research/jay/mosaic/pedigree/results/pop_temporal/'
lrdir='/home/tyler/Dropbox/research/jay/mosaic/pedigree/results/lr_temporal/'
ped <- read.table('/home/tyler/Dropbox/research/jay/mosaic/pedigree/mosaic_ped_20230512.tsv', head=TRUE, na.strings='*')

pop.n <- NULL # data frame of number of expected genomic copies in population
cohort.n <- NULL # data frame of number of expecteed genomic copies

# read in pedstat files for time points 2002-2022
time.periods = 2002:2022
tidx <- 2:(length(time.periods)+1) # these are the contribution columns in matrix
id <- NULL
n.anc = 131
for (t in time.periods) {
	fname.pop = paste0(popdir,'T_IE_I_20230512_',t,'_pop_contribution.pedstat1')
	if (file.exists(fname.pop)) {
		df <- read.table(fname.pop,head=TRUE)
		if (is.null(id)) id <- df[,1]
		pop.n <- cbind(pop.n, df[,2])
	} else pop.n <- cbind(pop.n,rep(NA,n.anc))

	fname.lr = paste0(lrdir,'T_IE_I_20230512_to_',t,'_LR_contribution.pedstat1')
	if (file.exists(fname.lr)) {
		df <- read.table(fname.lr,head=TRUE)
		if (is.null(id)) id <- df[,1]
		cohort.n <- cbind(cohort.n, df[,2])
	} else cohort.n <- cbind(cohort.n,rep(NA,n.anc))
}

# mask values of individuals if they weren't born
ped.sub <- ped[which(ped$ID %in% id),c(1,5)]
ped.sub <- ped.sub[match(id,ped.sub$ID),]
for (i in 1:length(time.periods)) {
	t = time.periods[i]
	idx <- which(ped.sub$COHORT > t)
	if (length(idx) > 0) {
		pop.n[idx,i] <- NA
		cohort.n[idx,i] <- NA
	}
}


# collect biological origin info
meta.sub <- meta[which(meta$COLOR_ID %in% id),]
meta.sub <- meta.sub[match(id, meta.sub$COLOR_ID),]
biotype <- replace(meta.sub$Biological_Origin_Status, which(meta.sub$Biological_Origin_Status == "Donor_Population"), "T")
biotype <- replace(biotype, which(biotype == "IE" | biotype == "LR"), "R")

# add annotations
pop.n <- cbind(data.frame(ID=id, BIOTYPE=biotype),as.data.frame(pop.n)) # add sample names
colnames(pop.n) <- c("ID","BIOTYPE",paste0("cohort.",time.periods))

cohort.n <- cbind(data.frame(ID=id, BIOTYPE=biotype),as.data.frame(cohort.n)) # add sample names
colnames(cohort.n) <- c("ID","BIOTYPE",paste0("cohort.",time.periods))

# make biotype data.frame of proportions
r.idx = which(biotype=="R")
t.idx = which(biotype=="T")
i.idx = which(biotype=="I")
pop.p <- NULL # dataframe of contribution by Resident vs translocated vs immigrant to population
cohort.p <- NULL # dataframe of contribution by Resident vs translocated vs immigrant to cohort

for (i in 3:ncol(pop.n)) {
	total.copies = sum(pop.n[,i],na.rm=TRUE)
	res.copies = sum(pop.n[r.idx,i],na.rm=TRUE)
	trans.copies = sum(pop.n[t.idx,i],na.rm=TRUE)
	immi.copies = sum(pop.n[i.idx,i],na.rm=TRUE)
	if (total.copies > 0) {
		res.p = res.copies/total.copies
		trans.p = trans.copies/total.copies
		immi.p = immi.copies/total.copies
	} else {
		res.p = NA
		trans.p = NA
		immi.p = NA
	}
	pop.p <- rbind(pop.p, data.frame(YEAR=time.periods[i-2], RESIDENT=res.p, TRANSLOCATED=trans.p, IMMIGRANT=immi.p))

	total.copies.cohort = sum(cohort.n[,i],na.rm=TRUE)
	res.copies.cohort = sum(cohort.n[r.idx,i],na.rm=TRUE)
	trans.copies.cohort = sum(cohort.n[t.idx,i],na.rm=TRUE)
	immi.copies.cohort = sum(cohort.n[i.idx,i],na.rm=TRUE)
	if (total.copies.cohort > 0) {
		res.p.cohort = res.copies.cohort/total.copies.cohort
		trans.p.cohort = trans.copies.cohort/total.copies.cohort
		immi.p.cohort = immi.copies.cohort/total.copies.cohort
	} else {
		res.p.cohort = NA
		trans.p.cohort = NA
		immi.p.cohort = NA
	}
	cohort.p <- rbind(cohort.p, data.frame(YEAR=time.periods[i-2], RESIDENT=res.p.cohort, TRANSLOCATED=trans.p.cohort, IMMIGRANT=immi.p.cohort))
}

# plot proportions over time

#pdf(file='/home/tyler/Dropbox/research/jay/mosaic/pedigree/results/figures/pedigree_biotype_temporal_contributions_T_IE_I.pdf', width=16, height=7)
#png(file='/home/tyler/Dropbox/research/jay/mosaic/pedigree/results/figures/pedigree_biotype_temporal_contributions_T_IE_I.png', width=16, height=7, units='in', res=300)
x11(width=16,height=7)
par(mgp = c(2.75,1,0))
plot(1, type="n", xlim=c(time.periods[1],time.periods[length(time.periods)]), ylim=c(0,1),
xlab="Year", ylab="Expected genetic contribution proportion", main="",xaxt='n', cex.axis=1.3, cex.lab=1.5)
axis(side=1,at=time.periods,labels=time.periods,cex=1.5,cex.axis=1.3)

lines(x=pop.p$YEAR, y=pop.p$RESIDENT, col="plum3", lwd=3, lty=1) # resident contribution to population
lines(x=pop.p$YEAR, y=pop.p$TRANSLOCATED, col="black", lwd=3, lty=1) # translocated contribution to population
lines(x=pop.p$YEAR, y=pop.p$IMMIGRANT, col="paleturquoise3", lwd=3, lty=1) # immigrant contribution to population
lines(x=cohort.p$YEAR, y=cohort.p$RESIDENT, col="plum3", lwd=3, lty=2) # resident contribution to cohort
lines(x=cohort.p$YEAR, y=cohort.p$TRANSLOCATED, col="black", lwd=3, lty=2) # translocated contribution to cohort
lines(x=cohort.p$YEAR, y=cohort.p$IMMIGRANT, col="paleturquoise3", lwd=3, lty=2) # immigrant contribution to cohort

# add legend

legend(x=2014.5,y=1.05, "Resident to population", col="plum3", lty=1, lwd=3, bty='n', cex=1.1)
legend(x=2019,y=1.05, "Resident to cohort", col="plum3", lty=2, lwd=3, bty='n', cex=1.1)
legend(x=2014.5,y=1, "Translocated to population", col="black", lty=1, lwd=3, bty='n', cex=1.1)
legend(x=2019,y=1, "Translocated to cohort", col="black", lty=2, lwd=3, bty='n', cex=1.1)
legend(x=2014.5,y=0.95, "Immigrant to population", col="paleturquoise3", lty=1, lwd=3, bty='n', cex=1.1)
legend(x=2019,y=0.95, "Immigrant to cohort", col="paleturquoise3", lty=2, lwd=3, bty='n', cex=1.1)

#dev.off()

--- end R code for comparing temporal contributions by ancestral type (translocated, resident, immigrant) ---

--- begin R code for number of T and IE contributing to each cohort and demographic expansion ---

library(scales)
library(TeachingDemos) # for shadowtext
library(shape) # for arrows

meta <- read.table("/home/tyler/Dropbox/research/jay/mosaic/metadata/jayid_map_20230512.txt",head=TRUE,sep="\t")
popdir='/home/tyler/Dropbox/research/jay/mosaic/pedigree/results/pop_temporal/'
lrdir='/home/tyler/Dropbox/research/jay/mosaic/pedigree/results/lr_temporal/'
ped <- read.table('/home/tyler/Dropbox/research/jay/mosaic/pedigree/cr_ped_20230512.tsv', head=TRUE, na.strings='*')
census <- read.csv('/home/tyler/Dropbox/research/jay/mosaic/metadata/20230512_metadata/Longform_Data_05122023.tsv', head=TRUE, sep="\t")
trans_data <- read.table('/home/tyler/Dropbox/research/jay/mosaic/metadata/Translocated_Jay_Individual_Statistics.tsv',head=TRUE,sep="\t")

pop.n <- NULL # data frame of number of expected genomic copies in population
cohort.n <- NULL # data frame of number of expecteed genomic copies contributed to cohort
cohort.n.adj <- NULL # data frame of number of expected genomic copies contributed to cohort minus self-contribution (due to LR ancestors)

# read in pedstat files for time points 2002-2022
time.periods = 2002:2022
tidx <- 2:(length(time.periods)+1) # these are the contribution columns in matrix
id <- NULL
n.anc = 74
for (t in time.periods) {
	fname.pop = paste0(popdir,'T_IE_20230512_',t,'_pop_contribution.pedstat1')
	if (file.exists(fname.pop)) {
		df <- read.table(fname.pop,head=TRUE)
		if (is.null(id)) id <- df[,1]
		pop.n <- cbind(pop.n, df[,2])
	} else pop.n <- cbind(pop.n,rep(NA,n.anc))

	fname.lr = paste0(lrdir,'T_IE_20230512_to_',t,'_LR_contribution.pedstat1')
	if (file.exists(fname.lr)) {
		df <- read.table(fname.lr,head=TRUE)
		if (is.null(id)) id <- df[,1]
		cohort.n <- cbind(cohort.n, df[,2])
		# mask self contribution
		vals <- df[,2]
		for (i in 1:length(vals)) {
			ind.id = df[i,1]
			pedidx = which(ped$ID == ind.id)
			if (length(pedidx) > 0) {
				if (ped$COHORT[pedidx] == t) vals[i] = vals[i]-1 # substract one genomic copy			
			}
		}
		cohort.n.adj = cbind(cohort.n.adj, vals)
	} else {
		cohort.n <- cbind(cohort.n,rep(NA,n.anc))
		cohort.n.adj <- cbind(cohort.n.adj,rep(NA,n.anc))
	}
}

# mask values of individuals if they weren't born
ped.sub <- ped[which(ped$ID %in% id),c(1,5)]
ped.sub <- ped.sub[match(id,ped.sub$ID),]
for (i in 1:length(time.periods)) {
	t = time.periods[i]
	idx <- which(ped.sub$COHORT > t)
	if (length(idx) > 0) {
		pop.n[idx,i] <- NA
		cohort.n[idx,i] <- NA
		cohort.n.adj[idx,i] <- NA
	}
}

# add annotations
pop.n <- cbind(data.frame(ID=id),as.data.frame(pop.n)) # add sample names
colnames(pop.n) <- c("ID",paste0("cohort.",time.periods))

cohort.n <- cbind(data.frame(ID=id),as.data.frame(cohort.n)) # add sample names
colnames(cohort.n) <- c("ID",paste0("cohort.",time.periods))

cohort.n.adj <- cbind(data.frame(ID=id),as.data.frame(cohort.n.adj)) # add sample names
colnames(cohort.n.adj) <- c("ID",paste0("cohort.",time.periods))

# find Resident and translocated indices
meta.sub <- meta[meta$COLOR_ID %in% cohort.n$ID,]
meta.sub <- meta.sub[match(cohort.n$ID,meta.sub$COLOR_ID),]

tidx <- which(meta.sub$Biological_Origin_Status == "T")
ridx <- which(meta.sub$Biological_Origin_Status == "IE" | meta.sub$Biological_Origin_Status == "LR")

# counts contributors to cohorts

n.contributors <- NULL
for (j in 4:ncol(cohort.n)) {
	anc.n <- length(which(!is.na(cohort.n[,j]) & cohort.n[,j] > 0))
	trans.n <- length(which(!is.na(cohort.n[tidx,j]) & cohort.n[tidx,j] > 0))
	res.n <- length(which(!is.na(cohort.n[ridx,j]) & cohort.n[ridx,j] > 0))
	n.contributors <- rbind(n.contributors, data.frame(YEAR=time.periods[j-1], N_CONTRIBUTORS = anc.n, N_RES = res.n, N_TRANS = trans.n))
}

#> n.contributors # This is the the number of ancestral lineages present among cohorts born each year
#   YEAR N_CONTRIBUTORS N_RES N_TRANS
#1  2004             15    14       1
#2  2005              2     1       1
#3  2006              2     1       1
#4  2007              4     2       2
#5  2008              9     4       5
#6  2009              9     3       6
#7  2010             16     4      12
#8  2011             22     3      19
#9  2012             18     3      15
#10 2013             23     4      19
#11 2014              9     3       6
#12 2015             11     3       8
#13 2016             24     3      21
#14 2017             23     3      20
#15 2018             21     3      18
#16 2019             22     3      19
#17 2020             23     3      20
#18 2021             25     3      22
#19 2022             24     3      21

n.contributors.adj <- NULL
for (j in 4:ncol(cohort.n.adj)) {
	anc.n <- length(which(!is.na(cohort.n.adj[,j]) & cohort.n.adj[,j] > 0))
	trans.n <- length(which(!is.na(cohort.n.adj[tidx,j]) & cohort.n.adj[tidx,j] > 0))
	res.n <- length(which(!is.na(cohort.n.adj[ridx,j]) & cohort.n.adj[ridx,j] > 0))
	n.contributors.adj <- rbind(n.contributors.adj, data.frame(YEAR=time.periods[j-1], N_CONTRIBUTORS = anc.n, N_RES = res.n, N_TRANS = trans.n))
}


# count ancestral lineages present in the population

n.pop.lineages <- NULL
for (j in 2:ncol(pop.n)) {
	anc.n <- length(which(!is.na(pop.n[,j]) & pop.n[,j] > 0))
	trans.n <- length(which(!is.na(pop.n[tidx,j]) & pop.n[tidx,j] > 0))
	res.n <- length(which(!is.na(pop.n[ridx,j]) & pop.n[ridx,j] > 0))
	n.pop.lineages <- rbind(n.pop.lineages, data.frame(YEAR=time.periods[j-1], N_CONTRIBUTORS = anc.n, N_RES = res.n, N_TRANS = trans.n))
}

#> n.pop.lineages
#   YEAR N_CONTRIBUTORS N_RES N_TRANS
#1  2002              4     4       0
#2  2003             20    13       7
#3  2004             29    21       8
#4  2005             20    11       9
#5  2006             11     6       5
#6  2007             14     6       8
#7  2008             27     7      20
#8  2009             28     4      24
#9  2010             35     4      31
#10 2011             32     4      28
#11 2012             32     4      28
#12 2013             30     4      26
#13 2014             30     4      26
#14 2015             29     4      25
#15 2016             29     4      25
#16 2017             26     3      23
#17 2018             25     3      22
#18 2019             25     3      22
#19 2020             25     3      22
#20 2021             25     3      22
#21 2022             25     3      22


# translocations through time

trans.df <- NULL
for (t in sort(unique(trans_data$Year_Translocated))) {
	n = length(which(trans_data$Year_Translocated == t))
	site1.n <- length(which(trans_data$Year_Translocated == t & trans_data$Donor_Patch == "SITE 1"))
	site12.n <- length(which(trans_data$Year_Translocated == t & trans_data$Donor_Patch == "SITE 12"))
	site13.n <- length(which(trans_data$Year_Translocated == t & trans_data$Donor_Patch == "SITE 13"))
	site18.n <- length(which(trans_data$Year_Translocated == t & trans_data$Donor_Patch == "SITE 18"))
	tex.n <- length(which(trans_data$Year_Translocated == t & trans_data$Donor_Patch == "TEXACO"))
	trans.df <- rbind(trans.df, data.frame(YEAR=t, N_MOVED=n, SITE1_N = site1.n, SITE12_N = site12.n, SITE13_N = site13.n, SITE18_N = site18.n, TEXACO_N = tex.n))
}

#> trans.df
#  YEAR N_MOVED SITE1_N SITE12_N SITE13_N SITE18_N TEXACO_N
#1 2003       7       1        1        4        1        0
#2 2004       6       2        2        2        0        0
#3 2005       4       2        2        0        0        0
#4 2007       3       0        0        0        3        0
#5 2008      15       1        0       14        0        0
#6 2009       6       0        0        6        0        0
#7 2010      10       0        0        0        0       10

# population census size through time

# format census data

census.sub <- census[which(census$PROPERTY == "MW" | census$PROPERTY == "COKER" | census$PROPERTY == "DUETTE PRESERVE"),] # restrict census to Mosaic Wellfield, Duette Preserve, and the Coker Tract
census.sub <- census.sub[which(census.sub$Present == 1),] # remove individuals not seen
census.sub$COLOR_ID <- toupper(census.sub$COLOR_ID)
#census.sub <- census.sub[-grep("UNBAND",census.sub$COLOR_ID),] # exclude unbanded individuals

popsize <- NULL
for (t in sort(unique(census.sub$CENSUS_YEAR))) {
	n = length(unique(census.sub$COLOR_ID[which(census.sub$CENSUS_YEAR == t)]))
	popsize <- rbind(popsize, data.frame(YEAR=t, CENSUS_N = n))
}

#> popsize
#   YEAR CENSUS_N
#1  2002        4
#2  2003       20
#3  2004       33
#4  2005       20
#5  2006       14
#6  2007       18
#7  2008       32
#8  2009       41
#9  2010       56
#10 2011       82
#11 2012       89
#12 2013       79
#13 2014       70
#14 2015       69
#15 2016       75
#16 2017      103
#17 2018      129
#18 2019      143
#19 2020      137
#20 2021      144
#21 2022      134


# plot census data

# limit data to years 2003+ for plotting
time.periods2 <- time.periods[2:length(time.periods)]
popsize.sub <- popsize[which(popsize$YEAR > 2002),]

#pdf(file='/home/tyler/Dropbox/research/jay/mosaic/pedigree/results/figures/temporal_census_size.pdf', width=16, height=7) # deprecated
#png(file='/home/tyler/Dropbox/research/jay/mosaic/pedigree/results/figures/temporal_census_size.png', width=16, height=7, units='in', res=300) # deprecated
#png(file='/home/tyler/Dropbox/research/jay/mosaic/figures/temporal_census_size.png', width=16, height=7, units='in', res=300) # counts self-contribution
#pdf(file='/home/tyler/Dropbox/research/jay/mosaic/figures/temporal_census_size.pdf', width=16, height=7) # counts self-contribution
#png(file='/home/tyler/Dropbox/research/jay/mosaic/figures/temporal_census_size_adjusted.png', width=16, height=7, units='in', res=300) # does not count self-contribution
#pdf(file='/home/tyler/Dropbox/research/jay/mosaic/figures/temporal_census_size_adjusted.pdf', width=16, height=7) # does not count self-contribution
#png(file='/home/tyler/Dropbox/research/jay/mosaic/figures/temporal_census_size_adjusted_2003_2022.png', width=16, height=7, units='in', res=300) # does not count self-contribution
x11(width=16,height=7)
par(mgp = c(2.75,1,0))
#plot(1, type="n", xlim=c(time.periods[1],time.periods[length(time.periods)]), ylim=c(0,max(popsize$CENSUS_N)+5),xlab="Year", ylab="Number individuals", main="",xaxt='n', cex.axis=1.3, cex.lab=1.5)
plot(1, type="n", xlim=c(time.periods2[1]-0.5,time.periods2[length(time.periods2)]), ylim=c(0,max(popsize.sub$CENSUS_N)+5),xlab="Year", ylab="Number individuals", 
main="",xaxt='n', cex.axis=1.3, cex.lab=1.5, xaxt='n')
#axis(side=1,at=time.periods,labels=time.periods,cex=1.5,cex.axis=1.3)
axis(side=1,at=time.periods2,labels=time.periods2,cex=1.5,cex.axis=1.3)
axis(side=2,at=seq(from=0,to=150,by=25),labels=seq(from=0,to=150,by=25),cex=1.5,cex.axis=1.3)

#lines(x=popsize$YEAR, y=popsize$CENSUS_N, lwd=2)
#points(x=popsize$YEAR, y=popsize$CENSUS_N, pch=21, bg=alpha("black",0.5), col="black", cex=1.7, lwd=2)
lines(x=popsize.sub$YEAR, y=popsize.sub$CENSUS_N, lwd=2)
points(x=popsize.sub$YEAR, y=popsize.sub$CENSUS_N, pch=21, bg=alpha("black",0.5), col="black", cex=1.7, lwd=2)

# add arrows for translocations
for (t in trans.df$YEAR) {
	#idx = which(popsize$YEAR == t)
	#y = popsize$CENSUS_N[idx]
	idx = which(popsize.sub$YEAR == t)
	y = popsize.sub$CENSUS_N[idx]
	n = trans.df$N_MOVED[which(trans.df$YEAR == t)]
	Arrows(x0=t, x1=t, y0=y+35, y1=y+10, col="black", lwd=2, arr.type="triangle", arr.width=0.25)
	text(x=t, y=y+42, labels=n, cex=1.5)
}

#rect(xleft=2001.6, ybottom=42, xright=2003.6, ytop=48.5, col="white", border=NA)
#text(x=2002.29, y=52, labels="Number", cex=1.3)
#text(x=2002.6, y=46, labels="translocated", cex=1.3)

rect(xleft=2002.6, ybottom=38, xright=2003.6, ytop=50, col="white", border=NA)
text(x=2002.8, y=47, labels="Number", cex=1.3)
text(x=2002.8, y=41, labels="translocated", cex=1.3)

# add number of unadjusted Residents contributing to cohorts
#res.offset= -0.75
#lines(x=n.contributors$YEAR, y=n.contributors$N_RES, col=alpha("palevioletred3",0.6), lwd=2, lty=5)
#text(x=n.contributors$YEAR, y=n.contributors$N_RES+res.offset, labels=n.contributors$N_RES, col="palevioletred3", cex=1.5, font=2) # use font=2 for bold

# add number unadjusted Translocaed contributing to cohort
#trans.offset = 0.75
#lines(x=n.contributors$YEAR, y=n.contributors$N_TRANS, col=alpha("royalblue",0.6), lwd=2, lty=5)
#text(x=n.contributors$YEAR, y=n.contributors$N_TRANS+trans.offset, labels=n.contributors$N_TRANS, col="royalblue",cex=1.5, font=2) # use font=2 for bold

# add number of adjusted Residents contributing to cohorts (discounts self-contribution)
res.offset= -0.75
lines(x=n.contributors.adj$YEAR, y=n.contributors.adj$N_RES, col=alpha("palevioletred3",0.6), lwd=2, lty=5)
text(x=n.contributors.adj$YEAR, y=n.contributors.adj$N_RES+res.offset, labels=n.contributors.adj$N_RES, col="palevioletred3", cex=1.5, font=2) # use font=2 for bold

# add number adjusted Translocaed contributing to cohort (discounts self contribution)
trans.offset = 0.75
lines(x=n.contributors.adj$YEAR, y=n.contributors.adj$N_TRANS, col=alpha("royalblue",0.6), lwd=2, lty=5)
text(x=n.contributors.adj$YEAR, y=n.contributors.adj$N_TRANS+trans.offset, labels=n.contributors.adj$N_TRANS, col="royalblue",cex=1.5, font=2) # use font=2 for bold

# add legend
#grid(nx=110, ny=50, lty=2) # for aligning things
#legend(x=2001.2,y=157, legend="Population size", lty=1, lwd=2, col="black", bty='n', cex=1.3)
#points(x=2001.76, y=149, pch=21, bg=alpha("black",0.5), col="black", cex=1.7, lwd=2)
#legend(x=2005.2,y=157, legend="Resident contributors", lty=5, lwd=2, col="palevioletred3", bty='n', cex=1.3)
#legend(x=2010.15,y=157, legend="Translocated contributors", lty=5, lwd=2, col="royalblue", bty='n', cex=1.3)

legend(x=2002,y=157, legend="Population size", lty=1, lwd=2, col="black", bty='n', cex=1.3)
points(x=2002.56, y=149, pch=21, bg=alpha("black",0.5), col="black", cex=1.7, lwd=2)
legend(x=2006,y=157, legend="Resident contributors", lty=5, lwd=2, col="palevioletred3", bty='n', cex=1.3)
legend(x=2010.95,y=157, legend="Translocated contributors", lty=5, lwd=2, col="royalblue", bty='n', cex=1.3)

#dev.off()

--- end R code for number of T and IE contributing to each cohort and demographic expansion ---

--- begin R code for 2022 population contribution stats ---

x2022 <- read.table('/home/tyler/Dropbox/research/jay/mosaic/pedigree/results/pop_temporal/T_IE_20230512_2022_pop_contribution.pedstat1',head=TRUE)

mean(x2022$P_ANC_FOCAL)
#[1] 0.0131579 # average relative ancestral contribution

length(which(x2022$P_ANC_FOCAL > mean(x2022$P_ANC_FOCAL)))
[1] 22 # number of ancestors contributinig more than the average relative contribution 

length(which(x2022$P_ANC_FOCAL > 2*mean(x2022$P_ANC_FOCAL)))
[1] 11 # number of ancestors providing more than twice the average contribution
 
mean(x2022$N_GENOME_COPIES)
[1] 1.565867 # expected number of genomic copies per ancestor in the 2022 cohort (average number of expected genomic copies) 

x2022$N_GENOME_COPIES[which(x2022$ID == "RLS-K")]/mean(x2022$N_GENOME_COPIES)
[1] 11.18588 # contribution of RLK-K relative to the average ancestral contribution

x2022$N_GENOME_COPIES[which(x2022$ID == "WSA-K")]/mean(x2022$N_GENOME_COPIES)
[1] 8.12253 # contribution of WSA-K relative to the average ancestal contribution

length(which(x2022$N_GENOME_COPIES > 5*mean(x2022$N_GENOME_COPIES)))
[1] 4 # number of ancestors providing more than 5x the average ancestral contribution

x2022$N_GENOME_COPIES[which(x2022$ID == "K-SLA")]
[1] 10.4531 # number expected genomic copies provided by K-SLA

x2022$N_GENOME_COPIES[which(x2022$ID == "K-SLA")]/mean(x2022$N_GENOME_COPIES)
[1] 6.6756 # contribution of SLA-K relative to the average ancestral contribution

x2022$N_GENOME_COPIES[which(x2022$ID == "OK-RS")]/mean(x2022$N_GENOME_COPIES)
[1] 5.807487 # contribution of OK-RS relative to the average ancestral contribution

--- end R code for 2022 population contribution stats ---

--- begin R code for relatedness between breeding pairs ---

library(scales)

ped <- read.table('/home/tyler/Dropbox/research/jay/mosaic/pedigree/mosaic_ped_20230512.tsv', head=TRUE, na.strings='*')
nesting <- read.table('/home/tyler/Dropbox/research/jay/mosaic/metadata/20230512_metadata/CUMULATIVE_NESTING_DATA_FINAL_05122023.tsv',head=TRUE,sep="\t")
rmat.ped <- as.matrix(read.table('/home/tyler/Dropbox/research/jay/mosaic/pedigree/mosaic_ped_20230512_relatedness_matrix.txt',head=TRUE))
rmat.gen <- as.matrix(read.table('/home/tyler/Dropbox/research/jay/mosaic/popgen/relatedness/fsj_mosaic_biallelic_snps_main_autosomes_qc_relatedness_matrix_relateStats_input.txt', head=TRUE))
jayid <- read.table('/home/tyler/Dropbox/research/jay/mosaic/metadata/jayid_map_20230512.txt', head=TRUE, sep="\t")

# format nesting data
nesting$Property <- toupper(nesting$Property)
nesting$Breeding_Male <- toupper(nesting$Breeding_Male)
nesting$Breeding_Female <- toupper(nesting$Breeding_Female)
exidx <- c(grep(paste(c("NONE","UNBAND","UNBD","UNB","NOBAND","UNKNOWN"),collapse="|"), nesting$Breeding_Male), grep(paste(c("NONE","UNBAND","UNBD","UNB","NOBAND","UNKNOWN"),collapse="|"), nesting$Breeding_Female))
nest.sub <- nesting[-exidx,]
nest.sub <- nest.sub[-which(nest.sub$ERROR_FLAG == 1),]
nest.sub <- nest.sub[which(nest.sub$Property == "MW" | nest.sub$Property == "COKER" | nest.sub$Property == "DUETTE"),]
nest.sub$Number_Fledged[which(nest.sub$Number_Fledged == "FAILED" | nest.sub$Number_Fledged == "ABANDONED")] <- 0
nest.sub$Number_Fledged[which(nest.sub$Number_Fledged == "UNKNOWN")] <- NA
nest.sub$Number_Fledged <- as.numeric(nest.sub$Number_Fledged)

# format pedigree relatedness matrix
colnames(rmat.ped) <- gsub(".","-",colnames(rmat.ped), fixed=TRUE)
rownames(rmat.ped) <- colnames(rmat.ped)

# format genetic relatedness matrix
colnames(rmat.gen) <- unname(sapply(colnames(rmat.gen),function(x,df){id = df$COLOR_ID[which(df$LAB_ID == x)]; ifelse(id == "*", x, id)},df=jayid))
rownames(rmat.gen) <- colnames(rmat.gen)

# make dataframe of relatedness between pairs and the number of offspring fledged each year

breeder.r <- NULL

for (i in 1:nrow(nest.sub)) {
	male <- nest.sub$Breeding_Male[i]
	female <- nest.sub$Breeding_Female[i]
	year <- nest.sub$YEAR[i]
	nfledge <- nest.sub$Number_Fledged[i]
	idx <- which(breeder.r$FATHER == male & breeder.r$MOTHER == female & breeder.r$YEAR == year)
	if (length(idx) > 0) {
		# pair attempt for current year has already been logged
		if (nfledge > 0) {
			if (is.na(breeder.r$NUM_FLEDGE[idx])) breeder.r$NUM_FLEDGE[idx] = nfledge else breeder.r$NUM_FLEDGE[idx] = breeder.r$NUM_FLEDGE[idx] + nfledge
 
		}
	} else {
		# first recorded attempt for pair in current year
		# check if parent information exists for pair
		father.idx <- which(ped$ID == male)
		mother.idx <- which(ped$ID == female)
		if (length(father.idx) == 0 || length(mother.idx) == 0) next
		ff <- ped$SIRE_ID[father.idx]
		fm <- ped$DAM_ID[father.idx]
		mf <- ped$SIRE_ID[mother.idx]
		mm <- ped$DAM_ID[mother.idx]
		r = NA
		if (is.na(ff) || is.na(fm) || is.na(mf) || is.na(mm)) {
			# parental information for breeding pair is missing, so will use genetic relatedness
			idx.f = which(rownames(rmat.gen) == male)
			idx.m = which(colnames(rmat.gen) == female)
			if (length(idx.f) > 0 && length(idx.m) > 0) r = rmat.gen[idx.f,idx.m]
		} else {
			idx.f = which(rownames(rmat.ped) == male)
			idx.m = which(rownames(rmat.ped) == female)
			if (length(idx.f) > 0 && length(idx.m) > 0) r = rmat.ped[idx.f,idx.m]		
		}
		# record pair
		breeder.r <- rbind(breeder.r, data.frame(YEAR=year, MALE=male, FEMALE=female, RELATEDNESS=r, NUM_FLEDGE=nfledge))
	}
}

# subset of breeders that fledge offspring
breeder.r.fledge <- breeder.r[which(!is.na(breeder.r$NUM_FLEDGE) & breeder.r$NUM_FLEDGE > 0),]

# data.frame of relatedness stats by year
breeder.stats <- NULL
for (t in sort(unique(breeder.r$YEAR))) {
	breeder.sub <- breeder.r[which(breeder.r$YEAR == t),]
	all_breeders = nrow(breeder.sub)
	avg_r_all = mean(breeder.sub$RELATEDNESS,na.rm=TRUE)
	var_r_all = var(breeder.sub$RELATEDNESS,na.rm=TRUE)
	breeders.sub.fledge <- breeder.sub[which(!is.na(breeder.sub$NUM_FLEDGE) & breeder.sub$NUM_FLEDGE > 0),]
	n_fledgers = nrow(breeders.sub.fledge)
	avg_r_fledge = mean(breeders.sub.fledge$RELATEDNESS, na.rm=TRUE)
	var_r_fledge = var(breeders.sub.fledge$RELATEDNESS, na.rm=TRUE)
	breeder.stats <- rbind(breeder.stats, data.frame(YEAR=t, N_PAIRS=all_breeders, AVG_R_ALL = avg_r_all, VAR_R_ALL = var_r_all, N_FLEDGING_PAIRS=n_fledgers, AVG_R_FLEDGE = avg_r_fledge, VAR_R_FLEDGE = var_r_fledge))
}

# plot

time.periods=sort(unique(breeder.r.fledge$YEAR))

nf <- NULL # number of fledging pairs in each time period
for (t in time.periods) {
	n = length(which(breeder.r$YEAR == t & !is.na(breeder.r$RELATEDNESS) & !is.na(breeder.r$NUM_FLEDGE) & breeder.r$NUM_FLEDGE > 0))
	nf <- c(nf,n)
}

set.seed(5329875)
#png(file='/home/tyler/Dropbox/research/jay/mosaic/pedigree/results/figures/temporal_fledging_pair_relatedness.png', width=17, height=7, units='in', res=300)
x11(width=17,height=7)
par(mgp = c(2.75,1,0))
plot(1, type="n", xlim=c(min(time.periods),max(time.periods)), ylim=c(0,max(breeder.r.fledge$RELATEDNESS,na.rm=TRUE)),xlab="", ylab="Breeding pair relatedness", main="",xaxt='n', cex.axis=1.3, cex.lab=1.5)
title(xlab="Year and number of pairs that fledged offspring", line=3.5, cex.lab=1.5)
axis(side=1,at=time.periods,labels=paste(time.periods,"\nn = ",nf,sep=""),cex=1.5,cex.axis=1.3, padj=0.5)
abline(v=time.periods, col="gray85", lty=2)
abline(h=seq(from=0,to=signif(max(breeder.r.fledge$RELATEDNESS,na.rm=TRUE),1),by=0.1), col="gray90", lty=2)
points(x=jitter(breeder.r.fledge$YEAR,0.5),y=breeder.r.fledge$RELATEDNESS, pch=21, bg=alpha("grey20",0.4), col="black", lwd=1.1, cex=1.7)

# add trend line
linear.fit <- lm(breeder.r.fledge$RELATEDNESS~breeder.r.fledge$YEAR)
abline(linear.fit, lwd=1.3,col=alpha("black",0.8))
text(x=2007,y=0.12,labels=bquote(beta == .(signif(linear.fit$coefficients[2],1))),cex=1.3)

#dev.off()

--- end R code for relatedness between breeding pairs ---
