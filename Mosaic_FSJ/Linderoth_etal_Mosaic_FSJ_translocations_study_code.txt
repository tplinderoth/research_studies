#############################################################################################
# This document contains code for analyzing data in the Linderoth et al. study              #
# titled "translocations spur population growth but exacerbate inbreeding in an imperiled   #
# species".                                                                                 #
#                                                                                           #
# Author contact: lindero1@msu.edu                                                          #
#                                                                                           #
# Accompanying data are available at https://doi.org/10.5061/dryad.z612jm6j0                #
#############################################################################################

Bash code ran interactively (for launching jobs, etc.) is prefixed with '$'.

## ---------- UNIVERSAL R FUNCTIONS ---------- ##

pointcodes <- function(df = NULL) {
  site_code <- replace(as.character(df$site),which(df$site == "Wellfield"), "119") # W
  site_code <- replace(site_code, which(site_code == "SITE_1"), "0") # open square
  site_code <- replace(site_code,which(site_code == "SITE_13"), "1") # open circle
  site_code <- replace(site_code,which(site_code == "SITE_12"), "2") # open upwards triangle
  site_code <- replace(site_code,which(site_code == "SITE_18"), "5") # open diamond
  site_code <- replace(site_code,which(site_code == "TEXACO"), "6") # open downward triangle
  site_code <- replace(site_code,which(site_code == "Golden_Aster_Scrub"), "3") # plus
  site_code <- replace(site_code,which(site_code == "Brigman"), "4") # cross
  site_code <- replace(site_code,which(site_code == "Duette_headwaters"), "8") # asterisk
  site_code <- replace(site_code,which(site_code == "Sun_City"), "35") # pound
  site_code <- replace(site_code,which(site_code == "W.Balm"), "38") # ampersand
  site_code <- replace(site_code,which(site_code == "missing"), "36") # dollar
  return(as.numeric(site_code))
}

pointletters <- function(df = NULL) {
  site_code <- replace(as.character(df$site),which(df$site == "Wellfield"), "W")
  site_code <- replace(site_code, which(site_code == "SITE_1"), "1")
  site_code <- replace(site_code,which(site_code == "SITE_13"), "3")
  site_code <- replace(site_code,which(site_code == "SITE_12"), "2")
  site_code <- replace(site_code,which(site_code == "SITE_18"), "8")
  site_code <- replace(site_code,which(site_code == "TEXACO"), "X")
  site_code <- replace(site_code,which(site_code == "Golden_Aster_Scrub"), "G")
  site_code <- replace(site_code,which(site_code == "Brigman"), "B")
  site_code <- replace(site_code,which(site_code == "Duette_headwaters"), "D")
  site_code <- replace(site_code,which(site_code == "Sun_City"), "S")
  site_code <- replace(site_code,which(site_code == "W.Balm"), "A")
  #site_code <- replace(site_code,which(site_code == "missing"), "M")
  site_code <- replace(site_code,which(site_code == "missing"), "U") # unbanded birds have missing locations
  return(site_code)
}

popletters <- function(df = NULL) {
  pop_code <- replace(as.character(df$pop),which(df$pop == "Resident"), "R")
  pop_code <- replace(pop_code,which(pop_code == "Contemporary"), "C")
  pop_code <- replace(pop_code, which(pop_code == "SITE_1"), "1")
  pop_code <- replace(pop_code,which(pop_code == "SITE_13"), "3")
  pop_code <- replace(pop_code,which(pop_code == "SITE_12"), "2")
  pop_code <- replace(pop_code,which(pop_code == "SITE_18"), "8")
  pop_code <- replace(pop_code,which(pop_code == "TEXACO"), "X")
  pop_code <- replace(pop_code,which(pop_code == "Golden_Aster_Scrub"), "G")
  pop_code <- replace(pop_code,which(pop_code == "Brigman"), "B")
  pop_code <- replace(pop_code,which(pop_code == "Duette_headwaters"), "D")
  pop_code <- replace(pop_code,which(pop_code == "Sun_City"), "S")
  pop_code <- replace(pop_code,which(pop_code == "W.Balm"), "A")
  return(pop_code)
}

popnames <- function(df = NULL) {
  pop_names <- replace(as.character(df$pop),which(df$pop == "Resident"), "Resident")
  pop_names <- replace(pop_names,which(pop_names == "Contemporary"), "Contemporary")
  pop_names <- replace(pop_names, which(pop_names == "SITE_1"), "Site 1")
  pop_names <- replace(pop_names,which(pop_names == "SITE_13"), "Site 13")
  pop_names <- replace(pop_names,which(pop_names == "SITE_12"), "Site 12")
  pop_names <- replace(pop_names,which(pop_names == "SITE_18"), "Site 18")
  pop_names <- replace(pop_names,which(pop_names == "TEXACO"), "Texaco")
  pop_names <- replace(pop_names,which(pop_names == "Golden_Aster_Scrub"), "Golden Aster Scrub")
  pop_names <- replace(pop_names,which(pop_names == "Brigman"), "Brigman")
  pop_names <- replace(pop_names,which(pop_names == "Duette_headwaters"), "Duette headwaters")
  pop_names <- replace(pop_names,which(pop_names == "Sun_City"), "Sun City")
  pop_names <- replace(pop_names,which(pop_names == "W.Balm"), "W. Balm")
  return(pop_names)
}


pntcol <- function(x = NULL) {
  if (length(grep("scales",(.packages()))) == 0) library(scales)
  color = NULL
  if (class(x) == "data.frame") {
    color = as.character(x$type)
  } else if (class(x) == "character") {
    color = x
  } else {
    stop("Invalid input type")
  }
  #color <- replace(color,which(color == "C"),"red")
  color <- replace(color,which(color == "C"),"violet")
  #color <- replace(color,which(color == "E"),"lightseagreen")
  color <- replace(color,which(color == "E"),"slateblue4")
  #color <- replace(color,which(color == "I"),"gold4")
  color <- replace(color,which(color == "I"),"tomato")
  #color <- replace(color,which(color == "M4"),"purple")
  color <- replace(color,which(color == "M4"),"royalblue1")	
  #color <- replace(color,which(color == "T"),"navy")
  color <- replace(color,which(color == "T"),"seagreen")
  return(color)
}

sitecol <- function(x = NULL) {
  #if (length(grep("scales",(.packages()))) == 0) library(scales)
  type.loc = paste0(x$type,"_",x$site)
  color = type.loc
  color <- replace(color, which(color == "C_Wellfield"), "violet")
  color <- replace(color, which(color == "E_Wellfield"), "slateblue4")
  color <- replace(color, which(color == "T_SITE_1"), "limegreen")
  #color <- replace(color, which(color == "T_SITE_13"), "yellow2")
  color <- replace(color, which(color == "T_SITE_13"), "gold2")
  #color <- replace(color, which(color == "T_SITE_12"), "magenta3")
  color <- replace(color, which(color == "T_SITE_12"), "maroon4")
  color <- replace(color, which(color == "T_SITE_18"), "dodgerblue1")
  color <- replace(color, which(color == "T_TEXACO"), "darkslategrey")
  color <- replace(color, which(color == "I_missing" | color == "U_missing"), "tomato")
  color <- replace(color, which(color == "M4_Duette_headwaters"), "black")
  color <- replace(color, which(color == "M4_Brigman"), "sienna")
  color <- replace(color, which(color == "M4_Golden_Aster_Scrub"), "olivedrab")
  color <- replace(color, which(color == "M4_W.Balm"), "red3")
  color <- replace(color, which(color == "M4_Sun_City"), "purple1")
}

popcolor <- function(x = NULL) {
  #if (length(grep("scales",(.packages()))) == 0) library(scales)
  color = x$pop
  color <- replace(color, which(color == "Contemporary"), "violet")
  color <- replace(color, which(color == "Resident"), "slateblue4")
  color <- replace(color, which(color == "SITE_1"), "limegreen")
  color <- replace(color, which(color == "SITE_13"), "gold2")
  color <- replace(color, which(color == "SITE_12"), "maroon4")
  color <- replace(color, which(color == "SITE_18"), "dodgerblue1")
  color <- replace(color, which(color == "TEXACO"), "darkslategrey")
  color <- replace(color, which(color == "Duette_headwaters"), "tomato")
  color <- replace(color, which(color == "Brigman"), "sienna")
  color <- replace(color, which(color == "Golden_Aster_Scrub"), "olivedrab")
  color <- replace(color, which(color == "W.Balm"), "red3")
  color <- replace(color, which(color == "Sun_City"), "purple1")
}

biopoint <- function(x = NULL) {
	ptcode = replace(x,which(x == "Contemporary" | x == "Resident"),"21")
	ptcode = replace(ptcode,which(ptcode == "SITE_1" | ptcode == "SITE_12" | ptcode == "SITE_13" | ptcode == "SITE_18" | ptcode == "TEXACO"), "24")
	ptcode = replace(ptcode,which(ptcode == "Golden_Aster_Scrub" | ptcode == "Brigman" | ptcode == "W.Balm" | ptcode == "Duette_headwaters" | ptcode == "Sun_City"), "22")
	return(as.numeric(ptcode))
}

bioclass_col <- function(x = NULL) {
	x = replace(x,which(x == "contemporary_Core_Region"),"hotpink2")
	x = replace(x,which(x == "resident_Core_Region"),"purple2")
	x = replace(x,which(x == "Site_1" | x == "Site_12" | x == "Site_13" | x == "Site_18" | x == "Texaco"), "dodgerblue2")
	x = replace(x,which(x == "Golden_Aster_Scrub" | x == "Brigman" | x == "West_Balm" | x == "Duette_Headwaters" | x == "Sun_City"),"gold2")
	return(x)
}

h_boxplot3 <- function(x=NULL, n=NULL, lev=grplevels, ylabel="Heterozygosity", pntlab=NULL, seed=10287, color=NULL, ylimits=NULL, idlabels=NULL, labpos=NULL) {
        if (length(grep("TeachingDemos",(.packages()))) == 0) library(TeachingDemos) # for shadowtext()
        nlevel = length(lev)

        par(mar=c(5,5,2,2))
        boxplot(x[,n] ~ group, data=x, outline=FALSE, names=c(rep("",nlevel)), xlab="", ylab=ylabel, main="", col="gray80", cex.axis=1.5, cex.lab=1.5, lwd=2, ylim=ylimits)
        #mtext(lev,1,at=1:nlevel, padj=1, cex=1.5)
	if (is.null(labpos)) labpos=1:nlevel 
        mtext(c(lev[1:3],paste("Other","M4",sep="\n")), 1,at=labpos, padj=1, cex=1.5)
        #mtext("Group",1,at=3,padj=2.5, cex=1.5)

        # add points
        for (i in lev) {
                idx = which(as.character(x$group) == i)
                set.seed(seed)
                xjitter = jitter(rep(which(lev == i),length(idx)), amount=0.2)
                ptcol = NULL
                for (j in 1:length(idx)) {
                        if (is.null(color)) ptcol = alpha("maroon",0.5) else ptcol = alpha(color[idx[j]],0.5)
                        if (is.null(pntlab) || is.na(pntlab[idx[j]])) {
                                if (!is.null(idlabels)) {
                                  text(y=x[idx[j],n], x=xjitter[j],idlabels[idx[j]],cex=0.5,col="red")
                                } else {
                                  points(y=x[idx[j],n], x=xjitter[j], pch=1, cex=1.2)
                                  points(y=x[idx[j],n], x=xjitter[j], pch=16, cex=1.2, col=ptcol)
                                }
                        } else if (class(pntlab) == "numeric") {
                                points(y=x[idx[j],n], x=xjitter[j], pch=pntlab[idx[j]], col="black", bg=alpha(color[idx[j]],0.65),lwd=1.3,cex=1.5)
                        }  else if (class(pntlab) == "character") {
                                shadowtext(y=x[idx[j],n], x=xjitter[j], labels=pntlab[idx[j]], col=color[idx[j]], bg=alpha("black",0.5), r=0.07, cex=1.2)       
                        } else stop("Unknown argument to pntlab")
                }
        }

}

h_boxplot_mask <- function(x=NULL, n=NULL, lev=grplevels, ylabel="Heterozygosity", pntlab=NULL, seed=10287, color=NULL, ylimits=NULL, idlabels=NULL) {
        if (length(grep("TeachingDemos",(.packages()))) == 0) library(TeachingDemos) # for shadowtext()
        nlevel = length(lev)

        par(mar=c(5,5,2,2))
        boxplot(x[,n] ~ group, data=x, outline=FALSE, names=c(rep("",nlevel)), xlab="", ylab=ylabel, main="", col="gray80", cex.axis=1.5, cex.lab=1.5, lwd=2, ylim=ylimits)
        #mtext(lev,1,at=1:nlevel, padj=1, cex=1.5)
        mtext(c(lev[1:3],paste("Other","M4",sep="\n")), 1,at=1:nlevel, padj=1, cex=1.5)
        #mtext("Group",1,at=3,padj=2.5, cex=1.5)

        # add points
        for (i in lev) {
                idx = which(as.character(x$group) == i)
                set.seed(seed)
                xjitter = jitter(rep(which(lev == i),length(idx)), amount=0.2)
                ptcol = NULL
                for (j in 1:length(idx)) {
                        if (is.null(color)) ptcol = alpha("maroon",0.5) else ptcol = color[idx[j]]
                        if (is.null(pntlab) || is.na(pntlab[idx[j]])) {
                                if (!is.null(idlabels)) {
                                  text(y=x[idx[j],n], x=xjitter[j],idlabels[idx[j]],cex=0.5,col="red")
                                } else {
                                  points(y=x[idx[j],n], x=xjitter[j], pch=1, cex=1.2)
                                  points(y=x[idx[j],n], x=xjitter[j], pch=16, cex=1.2, col=ptcol)
                                }
                        } else if (class(pntlab) == "numeric") {
                                points(y=x[idx[j],n], x=xjitter[j], pch=pntlab[idx[j]], col=alpha("grey70",0.5), bg=color[idx[j]],lwd=1.3,cex=1.5)
                        }  else if (class(pntlab) == "character") {
                                shadowtext(y=x[idx[j],n], x=xjitter[j], labels=pntlab[idx[j]], col=color[idx[j]], bg=alpha("black",0.5), r=0.07, cex=1.2)       
                        } else stop("Unknown argument to pntlab")
                }
        }

}

getBeta1 <- function(df=NULL, idx) {
        # df should be a dataframe with column 1 predictor and column 2 response
        return(unname((lm(df[idx,2] ~ df[idx,1]))$coefficients[2]))
}


#
#
#


## ---------- RAW READ COUNTS ---------- ##

Calculate basic summary statistics for the amount of sequencing data generated for individuals.

--- start R code ---

dat <- read.table('/home/tyler/Dropbox/research/jay/mosaic/raw_data/report/X202SC21114224-Z01-F003_final_20220407122035/src/tables/qc_summary_for_R.csv',head=TRUE)

dat$clean_reads = dat$Raw_reads*(dat$Effective_percent/100)
dat$clean_data = dat$clean_reads*150


df <- NULL
for (id in unique(dat$Sample)) {
        idx = which(dat$Sample == id)
        df <- rbind(df,data.frame(ID = id, clean_reads = sum(dat$clean_reads[idx]), clean_data = sum(dat$clean_data[idx])))
}

# clean read stats
range(df$clean_reads)
#[1]  77607781 148867965

mean(df$clean_reads)
#[1] 88722304

median(df$clean_reads)
#[1] 83997279

# clean data stats

range(df$clean_data)
#[1] 11641167213 22330194777

mean(df$clean_data)
#[1] 13308345544

median(df$clean_data)
#[1] 12599591808

---- end R code ---


#
#
#


## ---------- RAW FASTQ QUALITY CONTROL ---------- ##

## Assess quality of raw fastq files

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/fastq/raw_data/qc/fastqc_array.sh
implements:

--- start bash code ---

EXEC='fastqc'
ADAPTERFILE='/mnt/research/Fitz_Lab/projects/mosaic/raw_data/qc/novogene_adapter_file.txt'
FQLIST='/mnt/research/Fitz_Lab/projects/mosaic/raw_data/raw_fastq_list.txt'
FQFILE=$(sed -n "${SLURM_ARRAY_TASK_ID}p" "$FQLIST")
OUTDIR='/mnt/research/Fitz_Lab/projects/mosaic/raw_data/qc'

CMD="$EXEC -o $OUTDIR -f fastq -a $ADAPTERFILE $FQFILE"

printf "\n%s\n\n" "$CMD"

eval $CMD

--- end bash code ---

## Perform quality control of raw reads

# Collate each samples reads that were produced across multiple lanes

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/fastq/process_reads/cat_runs/cat_fastq_array.sh
implements:

--- start bash code ---

EXEC='/mnt/research/Fitz_Lab/projects/mosaic/processed_reads/cat_runs/catFastq.sh'
DIRLIST='/mnt/research/Fitz_Lab/projects/mosaic/processed_reads/cat_runs/fastq_dirs.txt'
FQDIR=$(sed -n "${SLURM_ARRAY_TASK_ID}p" "$DIRLIST")

CMD="$EXEC $FQDIR /mnt/gs18/scratch/users/lindero1/mosaic/cat_reads"

printf "\n%s\n\n" "$CMD"

eval $CMD

--- end bash code ---


# Remove duplicate reads

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/fastq/process_reads/deduplicate/deduplicate_reads_array.sh
implements:

--- start bash code ---

EXEC='hts_SuperDeduper'
FQLIST='/mnt/research/Fitz_Lab/projects/mosaic/processed_reads/deduplicate/fastq_prefixes.txt'
FQPREFIX=$(sed -n "${SLURM_ARRAY_TASK_ID}p" "$FQLIST")
FQFWD="${FQPREFIX}_1.fq.gz"
FQREV="${FQPREFIX}_2.fq.gz"
LIBPREFIX=$(echo $FQPREFIX | perl -e '$line = <>; print $1 if $line =~ /([^\/]+)$/')
OUTPREFIX="/mnt/gs18/scratch/users/lindero1/mosaic/deduplicated_reads/${LIBPREFIX}"
LOGFILE="/mnt/research/Fitz_Lab/projects/mosaic/processed_reads/deduplicate/logs/${LIBPREFIX}_stats.log"

CMD="$EXEC -L $LOGFILE -1 $FQFWD -2 $FQREV -f $OUTPREFIX -s 12 -l 10 -q 30 -a 5"

printf "\n%s\n\n" "$CMD"

eval $CMD

--- end bash code ---


# Trim adapters and remove excessively short reads after trimming

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/fastq/process_reads/adapter_trim/rmv_adapters_array.sh
implements:

--- start bash code ---

EXEC='cutadapt'
FQLIST='/mnt/research/Fitz_Lab/projects/mosaic/mosiac_samples.txt'
FQDIR='/mnt/gs18/scratch/users/lindero1/mosaic/deduplicated_reads'
FQPREFIX=$(sed -n "${SLURM_ARRAY_TASK_ID}p" "$FQLIST")
FQFWD="${FQDIR}/${FQPREFIX}_R1.fastq.gz"
FQREV="${FQDIR}/${FQPREFIX}_R2.fastq.gz"
OUTDIR="/mnt/gs18/scratch/users/lindero1/mosaic/adapter_trim"
OUTFWD="${OUTDIR}/${FQPREFIX}_R1.fastq.gz"
OUTREV="${OUTDIR}/${FQPREFIX}_R2.fastq.gz"

CMD="$EXEC -a AGATCGGAAGAGCACACGTCTGAACTCCAGTCA -A AGATCGGAAGAGCGTCGTGTAGGGAAAGAGTGT --overlap 3 --trim-n --minimum-length 70 -o $OUTFWD -p $OUTREV $FQFWD $FQREV"

printf "\n%s\n\n" "$CMD"

eval $CMD

--- end bash code ---


# Merge overlapping read pairs

$ /mnt/research/Fitz_Lab/projects/mosaic/fastq/process_reads/merge/merge_reads_array.sh
implements:

--- start bash code ---

EXEC='pear'
FQLIST='/mnt/research/Fitz_Lab/projects/mosaic/mosiac_samples.txt'
FQDIR='/mnt/gs18/scratch/users/lindero1/mosaic/adapter_trim'
FQPREFIX=$(sed -n "${SLURM_ARRAY_TASK_ID}p" "$FQLIST")
FQFWD="${FQDIR}/${FQPREFIX}_R1.fastq.gz"
FQREV="${FQDIR}/${FQPREFIX}_R2.fastq.gz"
OUTPREFIX="/mnt/gs18/scratch/users/lindero1/mosaic/merged_reads/${FQPREFIX}"

CMD="$EXEC -f $FQFWD -r $FQREV -o $OUTPREFIX -p 0.001 -v 10 -m 299 -n 70 -g 1 -s 2 -k"

printf "\n%s\n\n" "$CMD"

eval $CMD

--- end bash code ---

## Evaulate the effectiveness of quality control by comparing quality metrics of raw fastqs (after merging reads from multiple lanes for a sample)
## to those of cleaned fastqs

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/fastq/process_reads/clean_eval/eval_array.sh
implements:

--- start bash code ---

EXEC='/mnt/research/Fitz_Lab/projects/mosaic/fastq/process_reads/clean_eval/evalLibs.pl'
FQLIST='/mnt/research/Fitz_Lab/projects/mosaic/mosiac_samples.txt'
CLEAN_FQDIR='/mnt/research/Fitz_Lab/projects/mosaic/fastq/clean_reads'
RAW_FQDIR='/mnt/gs18/scratch/users/lindero1/mosaic/cat_reads'
FQPREFIX=$(sed -n "${SLURM_ARRAY_TASK_ID}p" "$FQLIST")
RAW_FQFWD="${RAW_FQDIR}/${FQPREFIX}_1.fq.gz"
RAW_FQREV="${RAW_FQDIR}/${FQPREFIX}_2.fq.gz"
CLEAN_FQFWD="${CLEAN_FQDIR}/${FQPREFIX}_R1.fastq.gz"
CLEAN_FQREV="${CLEAN_FQDIR}/${FQPREFIX}_R2.fastq.gz"
OUTFILE="/mnt/research/Fitz_Lab/projects/mosaic/fastq/process_reads/clean_eval/clean/${FQPREFIX}_eval.txt"

CMD="$EXEC --raw $RAW_FQFWD $RAW_FQREV --clean $CLEAN_FQFWD $CLEAN_FQREV --library $FQPREFIX > $OUTFILE"

printf "\n%s\n\n" "$CMD"

eval $CMD

--- end bash code ---

## Split reads for individuals back into respective lanes so that lane information for read groups can be tracked when mapping

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/fastq/process_reads/split_reads_array.sh
implements:

--- start bash code ---

EXEC='/mnt/research/Fitz_Lab/projects/mosaic/fastq/process_reads/splitFastqLanes.pl'
FQLIST='/mnt/research/Fitz_Lab/projects/mosaic/mosiac_samples.txt'
FQDIR='/mnt/research/Fitz_Lab/projects/mosaic/fastq/clean_reads'
OUTDIR='/mnt/gs18/scratch/users/lindero1/mosaic/split_reads'
FQPREFIX=$(sed -n "${SLURM_ARRAY_TASK_ID}p" "$FQLIST")

CMD="$EXEC $FQPREFIX $FQDIR $OUTDIR"
printf "\n%s\n" "$CMD"
eval $CMD

--- end bash code ---


#
#
#


## ---------- MAP READS TO REFERENCE GENOME ---------- ##

## Map clean reads to the FSJ V3 reference genome

This step also marks residual duplicate reads.

$ /mnt/research/Fitz_Lab/projects/mosaic/map/map_reads_array.sh
implements:

--- start bash code ---

EXEC='/mnt/research/Fitz_Lab/projects/mosaic/map/map_reads.sh'
REF='/mnt/research/Fitz_Lab/ref/bird/FSJ_V3/FSJ.V3.fa'
FQLIST='/mnt/research/Fitz_Lab/projects/mosaic/mosiac_ids.txt'
FQDIR='/mnt/gs18/scratch/users/lindero1/mosaic/split_reads'
OUTDIR='/mnt/gs18/scratch/users/lindero1/mosaic/map'
SAMPID=$(sed -n "${SLURM_ARRAY_TASK_ID}p" "$FQLIST")
NTHREAD=9

CMD="$EXEC $REF $SAMPID $FQDIR $OUTDIR $NTHREAD"
printf "\n%s\n" "$CMD"
eval $CMD

--- end bash code ---

# Trim residual overlapping portions of read pairs using mapping information (retain data from highest quality read)

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/map/clip_overlaps_array.sh
implements:

--- start bash code ---

EXEC='bam clipOverlap'
FQLIST='/mnt/research/Fitz_Lab/projects/mosaic/mosiac_ids.txt'
SAMPID=$(sed -n "${SLURM_ARRAY_TASK_ID}p" "$FQLIST")
INBAM="/mnt/gs18/scratch/users/lindero1/mosaic/map/${SAMPID}_untrimmed.bam"
OUTBAM="/mnt/research/Fitz_Lab/projects/mosaic/map/bam/${SAMPID}.bam"

CMD="$EXEC --in $INBAM --out $OUTBAM --stats --excludeFlags 0x20C --params --poolSize 1000000000 --noPhoneHome"
printf "\n%s\n" "$CMD"
eval $CMD

CMD2="samtools index $OUTBAM"
printf "\n%s\n" "$CMD2"
eval $CMD2

--- end bash code ---


#
#
#


## ---------- EVALUATE COVERAGE ---------- ##

# Calculate coverage statistics for each individual for the entire genome

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/map/coverage/coverage_array.sh

--- start bash code ---

EXEC='samtools coverage'
FQLIST='/mnt/research/Fitz_Lab/projects/mosaic/mosiac_ids.txt'
SAMPID=$(sed -n "${SLURM_ARRAY_TASK_ID}p" "$FQLIST")
BAM="/mnt/research/Fitz_Lab/projects/mosaic/map/bam/${SAMPID}.bam"
OUTFILE="/mnt/research/Fitz_Lab/projects/mosaic/map/coverage/${SAMPID}_coverage.txt"

CMD="$EXEC --ff UNMAP,SECONDARY,QCFAIL,DUP -d 0 $BAM > $OUTFILE"
printf "\n%s\n" "$CMD"
eval $CMD

--- end bash code ---

# Calculate the average autosomal depth for each indivdiual

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/map/main_chr_depth/depth_array.sh
implements:

--- start bash code ---

FQLIST='/mnt/research/Fitz_Lab/projects/mosaic/mosiac_ids.txt'
SAMPID=$(sed -n "${SLURM_ARRAY_TASK_ID}p" "$FQLIST")
BAM="/mnt/research/Fitz_Lab/projects/mosaic/map/bam/${SAMPID}.bam"
OUTFILE="/mnt/research/Fitz_Lab/projects/mosaic/map/main_chr_depth/${SAMPID}_depth.txt"
BED='/mnt/research/Fitz_Lab/ref/bird/FSJ_V3/FSJ_V3_main_chr.bed'

CMD="samtools depth -b $BED $BAM | cut -f3 | perl -ne '(\$sum, \$n) = (0,1); \$sum+=\$_; while(<>){\$sum+=\$_; \$n++};\$avg = sprintf(\"%.3f\", \$sum/\$n); print \"NSITES\tAVG_DEPTH\n\$n\t\$avg\n\"' > $OUTFILE"
printf "\n%s\n" "$CMD"
eval $CMD

--- end bash code ---

# Calculate Z chromosome to autosome depth ratio for each individual with zchr_depth_ratio.R in order 
# to assign sex to unsexed individuals.

zchr_depth_ratio.R implements

--- start R code ---

homolog_file = '/mnt/research/Fitz_Lab/ref/bird/FSJ_V3/FSJV3_convert.short.txt'
homolog = read.table(homolog_file,head=TRUE)
autosome = homolog$FSJV3_SCAFFOLD[which(homolog$ZEBRA_FINCH_CHR != "Z")]
zchr = homolog$FSJV3_SCAFFOLD[which(homolog$ZEBRA_FINCH_CHR == "Z")]

samples = read.table('/mnt/research/Fitz_Lab/projects/mosaic/mosiac_ids.txt',head=FALSE)

df = NULL
for (i in 1:nrow(samples)) {
        id = samples$V1[i]
        coverage = read.table(paste0('/mnt/research/Fitz_Lab/projects/mosaic/map/coverage/',id,'_coverage.txt'),head=FALSE)
        autoset = coverage[which(coverage$V1 %in% autosome),]
        zset = coverage[which(coverage$V1 %in% zchr),]
        len_total = sum(autoset$V3)
        autocov = sum(autoset$V7 * autoset$V3/len_total) # chromosome length weighted average
        zcov = zcov = zset$V7
        dratio = zcov/autocov # ratio of Z chr coverage to autosome coverage
        df = rbind(df, data.frame(SAMPLE = id, AUTOSOME_DEPTH = autocov, Z_DEPTH = zcov, DEPTH_RATIO = dratio))
}

# assign sex based on coverage ratio

df$NGS_SEX = NA
df$NGS_SEX[which(df$DEPTH_RATIO < 0.6)] = "Female"
df$NGS_SEX[which(is.na(df$NGS_SEX) == TRUE)] = "Male"

# write output
# write.table(df,file='/mnt/research/Fitz_Lab/projects/mosaic/map/coverage/ngs_sex_assignment.txt',col.names=TRUE,row.names=FALSE,sep="\t",quote=FALSE)

--- end R code ---


#
#
#


## ---------- GENETIC VARIANT CALLING ---------- ##

## Identify genetic variants and produce an all-sites VCF (accounts for sex of individual)

$ /mnt/research/Fitz_Lab/projects/mosaic/variants/call/call_variants_array.sh
implements:

--- start bash code ---

REF='/mnt/research/Fitz_Lab/ref/bird/FSJ_V3/FSJ.V3.fa'
BAMS='/mnt/research/Fitz_Lab/projects/mosaic/map/mosaic_bam_list.txt'
SCAFFLIST="/mnt/research/Fitz_Lab/projects/mosaic/variants/call/scaffold_sets/regions_${SLURM_ARRAY_TASK_ID}.rf"
PLOIDY_FILE='/mnt/research/Fitz_Lab/projects/mosaic/variants/call/mosaic_ploidy.txt'
SAMP_FILE='/mnt/research/Fitz_Lab/projects/mosaic/variants/call/mosaic_sample_sex.txt'
OUTBCF="/mnt/gs18/scratch/users/lindero1/mosaic/vcf/call/fsj_mosaic_${SLURM_ARRAY_TASK_ID}.bcf.gz"

CMD="bcftools mpileup \
-f $REF \
-b $BAMS \
-R $SCAFFLIST \
-C 0 \
-d 10000 \
-L 10000 \
-q 20 \
-Q 13 \
--ns UNMAP,SECONDARY,QCFAIL,DUP \
-a FORMAT/AD,FORMAT/DP,FORMAT/QS,FORMAT/SP,FORMAT/SCR,INFO/AD,INFO/SCR \
-p \
-O u \
| bcftools call \
--ploidy-file $PLOIDY_FILE \
-S $SAMP_FILE \
-a PV4,GQ,GP \
-m \
-P 0.003 \
-O u \
| bcftools +fill-tags \
-O b \
-o $OUTBCF \
-- -t 'AF,ExcHet,NS'"

printf "\n%s\n\n" "$CMD"

eval $CMD

wait

tabix -p bcf $OUTBCF

--- end bash code ---

# normalize variants

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/variants/norm/norm_variants_array.sh
implements:

--- start bash code ---

REF='/mnt/research/Fitz_Lab/ref/bird/FSJ_V3/FSJ.V3.fa'
INBCF="/mnt/gs18/scratch/users/lindero1/mosaic/vcf/call/fsj_mosaic_${SLURM_ARRAY_TASK_ID}.bcf.gz"
OUTBCF="/mnt/gs18/scratch/users/lindero1/mosaic/vcf/norm/fsj_mosaic_norm_${SLURM_ARRAY_TASK_ID}.bcf.gz"

CMD="bcftools norm -f $REF -O b -o $OUTBCF $INBCF"

printf "\n%s\n\n" "$CMD"

eval $CMD

wait

tabix -p bcf $OUTBCF

--- end bash code ---

## Annotate VCF including populating the FILTER and INFO fields with quality-related annotations

# Generate accessability masks

Merge BAMs in order to calculate mapping and sequencing quality information across all individuals

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/variants/masks/merge_bams.sh
implements:

--- start bash code ---

REF='/mnt/research/Fitz_Lab/ref/bird/FSJ_V3/FSJ.V3.fa'
BAMS='/mnt/research/Fitz_Lab/projects/mosaic/map/mosaic_bam_list.txt'
OUTFILE='/mnt/gs18/scratch/users/lindero1/mosaic/mask/mosaic_fsj_all.bam'

CMD="samtools merge -O BAM --reference $REF -b $BAMS -o $OUTFILE -@ 20"

printf "\n%s\n\n" "$CMD"

eval $CMD

wait

samtools index -@ 20 "$OUTFILE"

--- end bash code ---

Calculate mapping and sequencing quality information

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/variants/masks/bamstats_array.sh
implements:

--- start bash code ---

EXEC='/mnt/research/Fitz_Lab/projects/mosaic/variants/masks/bamstats'
SCAFLIST='/mnt/research/Fitz_Lab/ref/bird/FSJ_V3/FSJ_V3_scaffolds.txt'
SCAF=$(sed -n "${SLURM_ARRAY_TASK_ID}p" "$SCAFLIST")
REF='/mnt/research/Fitz_Lab/ref/bird/FSJ_V3/FSJ.V3.fa'
BAM='/mnt/gs18/scratch/users/lindero1/mosaic/mask/mosaic_fsj_all.bam'
OUTFILE="/mnt/research/Fitz_Lab/projects/mosaic/variants/masks/bam_stats/fsj_mosaic_allind_${SCAF}.bamstats"

CMD="$EXEC -A -d 8700000 -f $REF -q 0 -Q 0 -r $SCAF --ff UNMAP,SECONDARY,QCFAIL,DUP -s -aa $BAM > $OUTFILE"

printf "\n%s\n\n" "$CMD"

eval $CMD

--- end bash code ---

Summarize BAM statistics

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/variants/masks/bamstats_main_summary_array.sh
implements:

--- start bash code ---

EXEC='/mnt/research/Fitz_Lab/projects/mosaic/variants/masks/qualSummaryStats.R'
STATLIST="/mnt/gs18/scratch/users/lindero1/mosaic/mask/fsj_v3_autosome_bamstat_${SLURM_ARRAY_TASK_ID}.list"
if [ $SLURM_ARRAY_TASK_ID -eq 4 ]; then STATLIST='/mnt/gs18/scratch/users/lindero1/mosaic/mask/fsj_v3_z_bamstat.list'; fi
OUTFILE="/mnt/gs18/scratch/users/lindero1/mosaic/mask/bam_stats/fsj_mosaic_allind_bamstat_summary_${SLURM_ARRAY_TASK_ID}.txt"

CMD="$EXEC $STATLIST $OUTFILE 3 4 5 6 7 8 9"

printf "\n%s\n\n" "$CMD"

eval $CMD

--- end bash code ---


Make accessability mask bed files based on BAM statistics

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/variants/masks/bed_mask_array.sh
implements:

--- start bash code ---

EXEC='/mnt/research/Fitz_Lab/projects/mosaic/variants/masks/bedmask.pl'
SCAFLIST='/mnt/research/Fitz_Lab/ref/bird/FSJ_V3/FSJ_V3_scaffolds.txt'
SCAF=$(sed -n "${SLURM_ARRAY_TASK_ID}p" "$SCAFLIST")
BAMSTATS="/mnt/research/Fitz_Lab/projects/mosaic/variants/masks/bam_stats/fsj_mosaic_allind_${SCAF}.bamstats"
OUTPREFIX="/mnt/research/Fitz_Lab/projects/mosaic/variants/masks/bed/fsj_mosaic_mask_${SCAF}"

CMD="$EXEC --mindepth 523 --maxdepth 741 --minmq 35 --maxmq0 0.1 --minbq 20 --maxbq0 0.003 $BAMSTATS $OUTPREFIX"

if [ "$SCAF" = 'Chromosome24' ]
then
        CMD="$EXEC --mindepth 386 --maxdepth 681 --minmq 35 --maxmq0 0.1 --minbq 20 --maxbq0 0.003 $BAMSTATS $OUTPREFIX"
fi

printf "\n%s\n\n" "$CMD"

eval $CMD

--- end bash code ---


Calculate quality information based on VCF. This will be quality based on reads that were actually used for genotype calling, i.e. 
that passed minimum base and mapping quality cutoffs when calling variants with bcftools.

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/variants/masks/vcfstats_array.sh
implements:

--- start bash code ---

BCF="/mnt/gs18/scratch/users/lindero1/mosaic/vcf/norm/fsj_mosaic_norm_${SLURM_ARRAY_TASK_ID}.bcf.gz"
OUTFILE="/mnt/gs18/scratch/users/lindero1/mosaic/mask/vcf_stats/fsj_mosaic_${SLURM_ARRAY_TASK_ID}.vcfstats"

CMD="(printf '%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\n' 'CHR' 'POS' 'DP' 'NS' 'QUAL' 'MQ' 'RPBZ' 'MQBZ' 'BQBZ' 'FS' 'ExcHet' 'PV4_STRAND' 'PV4_BASEQ' 'PV4_MAPQ' 'PV4_POS' && bcftools query -f '%CHROM\t%POS\t%INFO/DP\t%INFO/NS\t%QUAL\t%MQ\t%INFO/RPBZ\t%INFO/MQBZ\t%INFO/BQBZ\t%INFO/FS\t%INFO/ExcHet\t%INFO/PV4{0}\t%INFO/PV4{1}\t%INFO/PV4{2}\t%INFO/PV4{3}\n' $BCF) > $OUTFILE"

printf "\n%s\n\n" "$CMD"

eval $CMD

--- end bash code ---


Summarize VCF quality information

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/variants/masks/vcfstats_main_summary_array.sh
implements:

--- start bash code ---

EXEC='/mnt/research/Fitz_Lab/projects/mosaic/variants/masks/qualSummaryStats.R'
CHRLIST='/mnt/research/Fitz_Lab/ref/bird/FSJ_V3/FSJ_V3_main_autosomes.txt'
CHR=$(sed -n "${SLURM_ARRAY_TASK_ID}p" "$CHRLIST")
STATLIST="/mnt/research/Fitz_Lab/projects/mosaic/variants/masks/tmp/fsj_mosaic_vcfstats_${SLURM_ARRAY_TASK_ID}.list"
echo "/mnt/research/Fitz_Lab/projects/mosaic/variants/masks/vcf_stats/fsj_mosaic_${CHR}.vcfstats" > "$STATLIST"
OUTFILE="/mnt/research/Fitz_Lab/projects/mosaic/variants/masks/vcf_stats/fsj_mosaic_allind_vcfstats_summary_${CHR}.txt"

CMD="$EXEC $STATLIST $OUTFILE 3 4 5 6 7 8 9 10 11 12 13 14 15"

printf "\n%s\n\n" "$CMD"

eval $CMD

--- end bash code ---

Annotate all-sites VCF using BAM stats accessability mask and VCF quality cutoffs

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/variants/masks/annotate_array.sh
implements:

--- start bash code ---

EXEC='/mnt/research/Fitz_Lab/projects/mosaic/variants/masks/insertAnnotations.pl'
BCF="/mnt/gs18/scratch/users/lindero1/mosaic/vcf/norm/fsj_mosaic_norm_${SLURM_ARRAY_TASK_ID}.bcf.gz"
BEDFILE='/mnt/research/Fitz_Lab/projects/mosaic/variants/masks/bed/fsj_mosaic_mask_genome_fail.bed'
GRPFILE='/mnt/research/Fitz_Lab/projects/mosaic/variants/masks/fsj_mosaic_group_file.txt'
OUTFILE="/mnt/gs18/scratch/users/lindero1/mosaic/vcf/annotate/fsj_mosaic_annotated_${SLURM_ARRAY_TASK_ID}.vcf.gz"

CMD="bcftools view --no-version $BCF | $EXEC --dpbounds 474,790 --hetbound 0.06 --bed $BEDFILE --overwrite --genorep $GRPFILE | bgzip > $OUTFILE"

if [ "$SLURM_ARRAY_TASK_ID" = 7 ]
then
        CMD="bcftools view --no-version $BCF | $EXEC --dpbounds 336,560 --hetbound 0.06 --bed $BEDFILE --overwrite --genorep $GRPFILE | bgzip > $OUTFILE"
fi

printf "\n%s\n\n" "$CMD"
eval $CMD
wait
tabix -p vcf $OUTFILE

--- end bash code ---


Concatenate annotated VCFs to produce a single, final, release-ready, all-sites VCF

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/variants/masks/merge_vcfs.sh
implements:

--- start bash code ---

VCFLIST='/mnt/gs18/scratch/users/lindero1/mosaic/vcf/annotate/fsj_mosaic_vcf.list'
OUTFILE='/mnt/research/Fitz_Lab/projects/mosaic/variants/vcf/all_sites/fsj_mosaic_allsites_genome.vcf.gz'

CMD="bcftools concat -f $VCFLIST -O z -o $OUTFILE --threads 20"

printf "\n%s\n\n" "$CMD"

eval $CMD
wait
tabix -p vcf "$OUTFILE"

--- end bash code ---

Produce accompanying position file for the entire genome of sites that pass missing data and quality cutoffs

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/variants/scripts/extract_allsites_qc_pos.sh
implements:

--- start bash code ---

VCF='/mnt/research/Fitz_Lab/projects/mosaic/variants/vcf/all_sites/fsj_mosaic_allsites_genome.vcf.gz'
OUTPOS='/mnt/research/Fitz_Lab/projects/mosaic/variants/vcf/all_sites/fsj_mosaic_allsites_genome_qc.pos'

bcftools view -H -f "PASS" -i 'N_PASS(GT[0-27]!="mis" & FMT/DP > 2) > 24 && N_PASS(GT[28-38]!="mis" & FMT/DP > 2) > 9 && N_PASS(GT[39-44]!="mis" & FMT/DP > 2) > 4 && N_PASS(GT[45-57]!="mis" & FMT/DP > 2) > 11 && N_PASS(GT[58-86]!="mis" & FMT/DP > 2) > 25' "$VCF" | perl -ne  '@tok = split(/\s+/,$_); if ($tok[7] =~ /REPGQ=(\d+),(\d+),(\d+),(\d+),(\d+)/) {print "$tok[0]\t$tok[1]\n" if ($1 > 24 && $2 > 9 && $3 > 4 && $4 > 11 && $5 > 25);} else {print "$tok[0]\t$tok[1]\n";}' | uniq > "$OUTPOS"

--- end bash code ---

Produce accompanying position file for scaffolds that are homologous to zebra finch autosomes (refered to as "main autosomes") and 
which pass missing data and quality cutoffs

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/variants/scripts/extract_allsites_main_autosome_qc_pos.sh
implements:

--- start bash code ---

VCF='/mnt/research/Fitz_Lab/projects/mosaic/variants/vcf/all_sites/fsj_mosaic_allsites_genome.vcf.gz'
OUTPOS='/mnt/research/Fitz_Lab/projects/mosaic/variants/vcf/all_sites/fsj_mosaic_allsites_main_autosomes_qc.pos'
REGFILE='/mnt/research/Fitz_Lab/ref/bird/FSJ_V3/fsj_v3_main_autosomes.rf'

bcftools view -H -R "$REGFILE" -f "PASS" -i 'N_PASS(GT[0-27]!="mis" & FMT/DP > 2) > 24 && N_PASS(GT[28-38]!="mis" & FMT/DP > 2) > 9 && N_PASS(GT[39-44]!="mis" & FMT/DP > 2) > 4 && N_PASS(GT[45-57]!="mis" & FMT/DP > 2) > 11 && N_PASS(GT[58-86]!="mis" & FMT/DP > 2) > 25' "$VCF" | perl -ne  '@tok = split(/\s+/,$_); if ($tok[7] =~ /REPGQ=(\d+),(\d+),(\d+),(\d+),(\d+)/) {print "$tok[0]\t$tok[1]\n" if ($1 > 24 && $2 > 9 && $3 > 4 && $4 > 11 && $5 > 25);} else {print "$tok[0]\t$tok[1]\n";}' | uniq > "$OUTPOS"

--- end bash code ---

## Produce a sites-only allsites VCF (no individual genotype information)

$ bcftools view -G -O z /mnt/research/Fitz_Lab/projects/mosaic/variants/vcf/all_sites/fsj_mosaic_allsites_genome.vcf.gz > /mnt/research/Fitz_Lab/projects/mosaic/variants/vcf/all_sites/fsj_mosaic_allsites_genome_sitesonly.vcf.gz

## Extract all-variants VCF subset

Extract variable sites from all-sites VCF

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/variants/scripts/extract_variants.sh
implements:

--- start bash code ---

EXEC='/mnt/research/Fitz_Lab/projects/mosaic/variants/scripts/extractVariants.pl'
VCF='/mnt/research/Fitz_Lab/projects/mosaic/variants/vcf/all_sites/fsj_mosaic_allsites_genome.vcf.gz'
OUTVCF='/mnt/research/Fitz_Lab/projects/mosaic/variants/vcf/all_variants/fsj_mosaic_variants_genome.vcf.gz'

$EXEC $VCF | bgzip > $OUTVCF

tabix -p vcf $OUTVCF

--- end bash code ---

## Extract biallelic SNP VCF subset

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/variants/scripts/extract_snps.sh
implements:

--- start bash code ---

EXEC='/mnt/research/Fitz_Lab/projects/mosaic/variants/vcf/scripts/extractBiallelicSnps.pl'
VCF='/mnt/research/Fitz_Lab/projects/mosaic/variants/vcf/all_sites/fsj_mosaic_allsites_genome.vcf.gz'
OUTVCF='/mnt/research/Fitz_Lab/projects/mosaic/variants/vcf/biallelic_snps/fsj_mosaic_biallelic_snps_genome.vcf.gz'

$EXEC --minmaf 0 $VCF | bgzip > $OUTVCF

tabix -p vcf $OUTVCF

--- end bash code ---

Produce accompanying position file of genome-wide biallelic SNPs that pass missing data and quality cutoffs

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/variants/scripts/extract_snps_qc_pos.sh
implements:

--- start bash code ---

VCF='/mnt/research/Fitz_Lab/projects/mosaic/variants/vcf/biallelic_snps/fsj_mosaic_biallelic_snps_genome.vcf.gz'
OUTPOS='/mnt/research/Fitz_Lab/projects/mosaic/variants/vcf/biallelic_snps/fsj_mosaic_biallelic_snps_genome_qc.pos'

bcftools view -H -f "PASS" -i 'N_PASS(GT[0-27]!="mis" & FMT/DP > 2) > 24 && N_PASS(GT[28-38]!="mis" & FMT/DP > 2) > 9 && N_PASS(GT[39-44]!="mis" & FMT/DP > 2) > 4 && N_PASS(GT[45-57]!="mis" & FMT/DP > 2) > 11 && N_PASS(GT[58-86]!="mis" & FMT/DP > 2) > 25' "$VCF" | perl -ne  '@tok = split(/\s+/,$_); if ($tok[7] =~ /REPGQ=(\d+),(\d+),(\d+),(\d+),(\d+)/) {print "$tok[0]\t$tok[1]\n" if ($1 > 24 && $2 > 9 && $3 > 4 && $4 > 11 && $5 > 25);} else {print "$tok[0]\t$tok[1]\n";}' | uniq > "$OUTPOS"

--- end bash code ---

Producing accompanying position file of biallelic SNPs on main autosomes that pass missing data and quality cutoffs

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/variants/scripts/extract_snps_main_autosome_qc_pos.sh
implements:

--- start bash code ---

VCF='/mnt/research/Fitz_Lab/projects/mosaic/variants/vcf/biallelic_snps/fsj_mosaic_biallelic_snps_genome.vcf.gz'
OUTPOS='/mnt/research/Fitz_Lab/projects/mosaic/variants/vcf/biallelic_snps/fsj_mosaic_biallelic_snps_main_autosomes_qc.pos'
REGFILE='/mnt/research/Fitz_Lab/ref/bird/FSJ_V3/fsj_v3_main_autosomes.rf'

bcftools view -H -R "$REGFILE" -f "PASS" -i 'N_PASS(GT[0-27]!="mis" & FMT/DP > 2) > 24 && N_PASS(GT[28-38]!="mis" & FMT/DP > 2) > 9 && N_PASS(GT[39-44]!="mis" & FMT/DP > 2) > 4 && N_PASS(GT[45-57]!="mis" & FMT/DP > 2) > 11 && N_PASS(GT[58-86]!="mis" & FMT/DP > 2) > 25' "$VCF" | perl -ne  '@tok = split(/\s+/,$_); if ($tok[7] =~ /REPGQ=(\d+),(\d+),(\d+),(\d+),(\d+)/) {print "$tok[0]\t$tok[1]\n" if ($1 > 24 && $2 > 9 && $3 > 4 && $4 > 11 && $5 > 25);} else {print "$tok[0]\t$tok[1]\n";}' | uniq > "$OUTPOS"

--- end bash code ---

Extract VCF subset of quality-controlled biallelic SNPs on main autosomes

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/variants/scripts/extract_qc_snps.sh
implements

--- start bash code ---

VCF='/mnt/research/Fitz_Lab/projects/mosaic/variants/vcf/biallelic_snps/fsj_mosaic_biallelic_snps_genome.vcf.gz'
POSFILE='/mnt/research/Fitz_Lab/projects/mosaic/variants/vcf/biallelic_snps/fsj_mosaic_biallelic_snps_main_autosomes_qc.pos'
OUTVCF='/mnt/research/Fitz_Lab/projects/mosaic/variants/vcf/biallelic_snps/fsj_mosaic_biallelic_snps_main_autosomes_qc.vcf.gz'

CMD="bcftools view -T $POSFILE -O z -o $OUTVCF $VCF"

printf "\n%s\n\n" "$CMD"

eval $CMD

tabix -p vcf $OUTVCF

--- end bash code ---


#
#
#


## ---------- DISTRIBUTION OF SEQUENCING DEPTH BETWEEN GROUPS ---------- ##

Compare the distribution of average individual sequencing depth between groups for which we 
test for population genetic differences.

--- start R code ---

library(boot)

meta <- read.table('/home/tyler/Dropbox/research/jay/mosaic/metadata/M4_sequenced_FSJsamples_metadata.txt',head=TRUE)
colnames(meta)[which(colnames(meta) == "pop_name_full")] = "POPULATION" # this is just to make column names consistent with released metadata
meta$biogroup = replace(meta$POPULATION, which(meta$POPULATION == "Site_1" | meta$POPULATION == "Site_12" | meta$POPULATION == "Site_13" | meta$POPULATION == "Site_18" | meta$POPULATION == "Texaco"),"donor_pop")
meta$biogroup = replace(meta$biogroup, which(meta$biogroup == "Golden_Aster_Scrub" | meta$biogroup == "Brigman" | meta$biogroup == "West_Balm" | meta$biogroup == "Duette_Headwaters" | meta$biogroup == "Sun_City"),"other_M4")
meta$biogroup = factor(meta$biogroup, levels=c("contemporary_Core_Region","resident_Core_Region","donor_pop","other_M4"))

# ANOVA of individual sequencing depth among groups

summary(aov(autosome_depth ~ biogroup, data=meta))
#            Df Sum Sq Mean Sq F value Pr(>F)
#biogroup     3   3.75   1.250   1.194  0.317
#Residuals   83  86.92   1.047 

depth_mod <- lm(autosome_depth ~ biogroup, data=meta)

summary(depth_mod)
#
#Call:
#lm(formula = autosome_depth ~ biogroup, data = meta)
#
#Residuals:
#    Min      1Q  Median      3Q     Max 
#-1.5607 -0.6141 -0.2823  0.3721  4.5496 
#
#Coefficients:
#                             Estimate Std. Error t value Pr(>|t|)    
#(Intercept)                   7.12271    0.19340  36.830   <2e-16 ***
#biogroupresident_Core_Region -0.07744    0.32071  -0.241    0.810    
#biogroupdonor_pop             0.42547    0.26891   1.582    0.117    
#biogroupother_M4              0.19684    0.34345   0.573    0.568    
#---
#Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1
#
#Residual standard error: 1.023 on 83 degrees of freedom
#Multiple R-squared:  0.04136,	Adjusted R-squared:  0.006713 
#F-statistic: 1.194 on 3 and 83 DF,  p-value: 0.3173

shapiro.test(resid(depth_mod)) # errors are slightly skewed so will bootstrap to test the effect of group on sequencing depth
#
#	Shapiro-Wilk normality test
#
#data:  resid(depth_mod)
#W = 0.84261, p-value = 3.503e-08

set.seed(246369)
group_depth.boot <- boot(data.frame(x=meta$biogroup,y=meta$autosome_depth), getBeta1, R=10000, stype="i", sim="ordinary")
group_depth.ci <- boot.ci(group_depth.boot, conf=0.95, type=c("perc","bca"))

group_depth.ci
#BOOTSTRAP CONFIDENCE INTERVAL CALCULATIONS
#Based on 10000 bootstrap replicates
#
#CALL : 
#boot.ci(boot.out = group_depth.boot, conf = 0.95, type = c("perc", 
#    "bca"))
#
#Intervals : 
#Level     Percentile            BCa          
#95%   (-0.5715,  0.4119 )   (-0.5730,  0.4112 )  
#Calculations and Intervals on Original Scale

# plot distribution of individual average autosomal sequencing depth for different groups (Figure S8)
seed = 77361
#png(file='/home/tyler/Dropbox/research/jay/mosaic/figures/methods_evaluation/sequence_depth_vs_group_boxplot.png', width=7, height=7,units='in', res=300)
par(mar=c(5,5,2,2))
boxplot(autosome_depth ~ biogroup, data=meta, outline=FALSE, names=c(rep("",length(unique(meta$biogroup)))), xlab="", ylab="Mean autosome sequence depth", main="", col="gray80", cex.axis=1.5, cex.lab=1.5, lwd=2, ylim=c(max(0,min(meta$autosome_depth)-1),max(meta$autosome_depth)+1))
mtext(c(paste0("Contemporary\nCR"), paste0("Resident\nCR"), paste0("Donor\npopulations"), paste0("Other\nM4")),1,at=1:5, padj=1, cex=1.5)
#mtext("Group",1,at=2.5,padj=4, cex=1.4)
for (i in 1:length(unique(meta$biogroup))) {
        grp = levels(meta$biogroup)[i]
        idx = which(as.character(meta$biogroup) == grp)
        set.seed(seed)
        xjitter=jitter(rep(i,length(idx)),amount=0.2)
        points(y=meta$autosome_depth[idx], x=xjitter, pch=21, col="grey30", bg=alpha("grey30",0.6),lwd=1.2,cex=1.4)
}
#dev.off()

--- end R code ---


#
#
#


## ---------- RELATEDNESS ESTIMATED FROM GENOMIC DATA ---------- ##

Estimate relatedness among all sequenced individuals.

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/popgen/relatedness/relatedness_qc_snps.sh
implements:

--- start bash code ---

VCF='/mnt/research/Fitz_Lab/projects/mosaic/variants/vcf/biallelic_snps/fsj_mosaic_biallelic_snps_main_autosomes_qc.vcf.gz'
OUTFILE='fsj_mosaic_biallelic_snps_main_autosomes_qc_relatedness.txt'

CMD="ngsRelate -h $VCF -O $OUTFILE -p 20 -l 0.02 -T PL -A AF"

printf "\n%s\n\n" "$CMD"

eval $CMD

--- end bash code ---

Format ngsRelate output into a two dimensional r matrix.

--- start R code ---

df <- read.table('/home/tyler/Dropbox/research/jay/mosaic/popgen/relatedness/fsj_mosaic_biallelic_snps_main_autosomes_qc_relatedness.txt',head=TRUE)
meta <- read.table('/home/tyler/Dropbox/research/jay/mosaic/metadata/M4_sequenced_FSJsamples_metadata.txt',head=TRUE,sep="\t")
meta$pop.names <- popnames(meta)

# convert pairwise comparisons into a matrix
n = 87
rmat <- matrix(ncol=n, nrow=n)

for (i in 1:n) {
	iidx = i-1
	for (j in 1:n) {
		jidx = j-1
		if (i == j) {
			rmat[i,j] = NA
		} else if (!is.na(rmat[j,i])) {
			rmat[i,j] = rmat[j,i]
			#if (j < i) rmat[i,j] = NA # this makes half matrix
		} else {
			rmat[i,j] = df$rab[which(df$a == iidx & df$b == jidx)]
		}
	}
}

# output matrix
#write.table(rmat,file='/home/tyler/Dropbox/research/jay/mosaic/popgen/relatedness/#fsj_mosaic_biallelic_snps_main_autosomes_qc_relatedness_matrix.nonames.txt',col.names=FALSE,row.names=FALSE,quote=FALSE,sep="\t

colnames(rmat) <- paste0(meta$LAB_ID,":",gsub(" ", "_", meta$pop.names))
rownames(rmat) <- paste0(meta$LAB_ID,":",gsub(" ", "_", meta$pop.names))
#write.table(rmat,file='/home/tyler/Dropbox/research/jay/mosaic/popgen/relatedness/fsj_mosaic_biallelic_snps_main_autosomes_qc_relatedness_matrix.txt',col.names=TRUE,row.names=TRUE,quote=FALSE,sep="\t")

--- end R code ----

## Relatedness distribution summaries

--- start R code ----

dat <- read.table('/home/tyler/Dropbox/research/jay/mosaic/popgen/relatedness/fsj_mosaic_biallelic_snps_main_autosomes_qc_relatedness_ranked_usfws_pretty2.txt',head=FALSE)
# Each column in fsj_mosaic_biallelic_snps_main_autosomes_qc_relatedness_ranked_usfws_pretty2.txt is a focal individual, row 1 is focal individual information in the format
# <Fitz LAB ID>,<USFWS ID>,<population ID>, while rows 2..87 are other individuals in format <Fitz LAB ID>,<USFWS ID>,<population ID>,<relatedness to focal individual>.

# average pairwise relatedness between translocated individuals and Residents
r.rt = NULL # stores the pairwise relatedness between Residents and translocated individuals
transpop <- c("SITE_1", "SITE_12", "SITE_13", "SITE_18", "TEXACO")
for (i in 1:ncol(dat)) {
	tok = strsplit(dat[1,i],",")[[1]]
	if (tok[3] != "Resident") next
	for (j in 2:nrow(dat)) {
		tok = strsplit(dat[j,i],",")[[1]]
		if (tok[3] %in% transpop || tok[1] == "I_049") r.rt <- c(r.rt, as.numeric(tok[4]))
	}
}

quantile(r.rt, 0.95)
#      95% 
#0.0243058 # 95th quantile for pairwise relatedness between resident and donor site individuals

--- end R code ---

Extract relatedness submatrices for different groups or populations.

--- start R code ---

rmat <- as.matrix(read.table('/mnt/research/Fitz_Lab/projects/mosaic/popgen/relatedness/fsj_mosaic_biallelic_snps_main_autosomes_qc_relatedness_matrix.txt',head=TRUE,row.names=1))
colnames(rmat) <- gsub('\\..+$', '', colnames(rmat), perl=TRUE) # remove location info
meta <- read.table('/mnt/research/Fitz_Lab/projects/mosaic/M4_sequenced_FSJsamples_metadata.txt',head=TRUE,sep="\t")

# collect IDs of individuals in each group
c.id <- meta$LAB_ID[which(meta$pop == "Contemporary")]
r.id <- meta$LAB_ID[which(meta$pop == "Resident")]
s13.id <- meta$LAB_ID[which(meta$pop == "SITE_13")]
histmeta.id <- meta$LAB_ID[which(meta$year_sampled < 2021)]

# note: exclude RSW-K from CR founders in case I use them as a reference pop for the Contemporary CR individuals at some point
crfounders.id <- meta$LAB_ID[which((meta$pop == "Resident" | meta$pop == "SITE_1" | meta$pop == "SITE_12" | meta$pop == "SITE_13" | meta$pop == "SITE_18" | meta$pop == "TEXACO") & meta$LAB_ID != "T_072")]

# note: include RSW-K from the donor site group because they are relevant for estimating the allele frequencies in this metapopulation subset
donor.id <- meta$LAB_ID[which(meta$pop == "SITE_1" | meta$pop == "SITE_12" | meta$pop == "SITE_13" | meta$pop == "SITE_18" | meta$pop == "TEXACO")]

# commenting out translocated subset below because all donor site individuals are a better way to estimate allele frequencies for the translocated group 
#trans.id <': trans.id <- meta$LAB_ID[which((meta$pop == "SITE_1" | meta$pop == "SITE_12" | meta$pop == "SITE_13" | meta$pop == "SITE_18" | meta$pop == "TEXACO") & meta$LAB_ID != "T_072")]

# extract relatedness matrix subsets
c.rmat <- rmat[which(colnames(rmat) %in% c.id == TRUE), which(colnames(rmat) %in% c.id == TRUE)]
r.rmat <- rmat[which(colnames(rmat) %in% r.id == TRUE), which(colnames(rmat) %in% r.id == TRUE)]
s13.rmat <- rmat[which(colnames(rmat) %in% s13.id == TRUE), which(colnames(rmat) %in% s13.id == TRUE)]
histmeta.rmat <- rmat[which(colnames(rmat) %in% histmeta.id == TRUE), which(colnames(rmat) %in% histmeta.id == TRUE)]
crfounders.rmat <- rmat[which(colnames(rmat) %in% crfounders.id == TRUE), which(colnames(rmat) %in% crfounders.id == TRUE)]
donor.rmat <- rmat[which(colnames(rmat) %in% donor.id == TRUE), which(colnames(rmat) %in% donor.id == TRUE)]

# output relatedness matrices subsets
#write.table(c.rmat, file='/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/contemporary_cr_relatedness_matrix.txt', col.names=TRUE, row.names=FALSE, quote=FALSE, sep="\t")
#write.table(r.rmat, file='/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/resident_cr_relatedness_matrix.txt', col.names=TRUE, row.names=FALSE, quote=FALSE, sep="\t")
#write.table(s13.rmat, file='/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/site13_relatedness_matrix.txt', col.names=TRUE, row.names=FALSE, quote=FALSE, sep="\t")
#write.table(histmeta.rmat, file='/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/historic_metapop_relatedness_matrix.txt', col.names=TRUE, row.names=FALSE, quote=FALSE, sep="\t")
#write.table(crfounders.rmat, file='/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/cr_founders_relatedness_matrix.txt', col.names=TRUE, row.names=FALSE, quote=FALSE, sep="\t")
#write.table(donor.rmat, file='/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/donor_pops_relatedness_matrix.txt', col.names=TRUE, row.names=FALSE, quote=FALSE, sep="\t")

# output the original relatedness matrix of all samples, entirely unchanged except for removing the row names and simplifying the IDs (remove population labels)
#write.table(rmat, file='/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/fsj_mosaic_biallelic_snps_main_autosomes_qc_relatedness_matrix_fmt.txt', col.names=TRUE, row.names=FALSE, quote=FALSE, sep="\t")

--- end R code ---

--- start R code ---


## Make relatedness-pruned subsets of individuals (all pairwise r is <= 0.4, i.e. no first degree relatives)

Subset relatedness matrices by removing particular individuals that should be excluded prior to r-pruning

--- start R code ---

# remove T_072 (RSW-K) from donor pop relatedness matrix because this individual was not translocated
donor.mat <- read.table('/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/inputs/donor_pops_relatedness_matrix.txt',head=TRUE)
trans.mat <- donor.mat[- which(colnames(donor.mat) == "T_072"), - which(colnames(donor.mat) == "T_072")]
write.table(trans.mat,file='/mnt/research/Fitz_Lab/projects/mosaic/popgen/relatedness/unrelated_subsets/translocated_relatedness_matrix.txt',col.names=TRUE,row.names=FALSE,quote=FALSE,sep="\t")

# remove E_030 (K-SRB) from resident relatendess matrix because this is an F1 between a site 12 father and CR resident mother
res.mat <- read.table('/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/inputs/resident_cr_relatedness_matrix.txt',head=TRUE)
res.sub.mat <- res.mat[-which(colnames(res.mat) == "E_030"), -which(colnames(res.mat) == "E_030")]
rite.table(res.sub.mat,file='/mnt/research/Fitz_Lab/projects/mosaic/popgen/relatedness/unrelated_subsets/resident_cr_noE030_matrix.txt',col.names=TRUE,row.names=FALSE,quote=FALSE,sep="\t")

--- end R code ---


Take random subsets of individuals such that the max pairwise r within each group is <= 0.4

--- start bash code ---

$ /mnt/research/Fitz_Lab/projects/mosaic/popgen/relatedness/scripts/subsetUnrelated.R /mnt/research/Fitz_Lab/projects/mosaic/popgen/relatedness/unrelated_subsets/translocated_relatedness_matrix.txt 0.4 328974 > /mnt/research/Fitz_Lab/projects/mosaic/popgen/relatedness/unrelated_subsets/translocated_relatedness_maxr0.4_ids_seed328974.txt
$ /mnt/research/Fitz_Lab/projects/mosaic/popgen/relatedness/scripts/subsetUnrelated.R /mnt/research/Fitz_Lab/projects/mosaic/popgen/relatedness/unrelated_subsets/resident_cr_noE030_matrix.txt 0.4 836241 > /mnt/research/Fitz_Lab/projects/mosaic/popgen/relatedness/unrelated_subsets/resident_cr_noE030_relatedness_maxr0.4_ids_seed836241.txt

The following subsets were created and are stored in the HPCC directory '/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/inputs' (they were generated 
during the ROH analyses and then used subsequently):
$ /mnt/research/Fitz_Lab/projects/mosaic/popgen/relatedness/scripts/subsetUnrelated.R contemporary_cr_relatedness_matrix.txt 0.4 836241 > contemporary_cr_relatedness_maxr0.4_ids.txt
$ /mnt/research/Fitz_Lab/projects/mosaic/popgen/relatedness/scripts/subsetUnrelated.R resident_cr_relatedness_matrix.txt 0.4 836241 > resident_cr_relatedness_maxr0.4_ids.txt
$ /mnt/research/Fitz_Lab/projects/mosaic/popgen/relatedness/scripts/subsetUnrelated.R site13_relatedness_matrix.txt 0.4 836241 > site13_relatedness_maxr0.4_ids.txt
$ /mnt/research/Fitz_Lab/projects/mosaic/popgen/relatedness/scripts/subsetUnrelated.R historic_metapop_relatedness_matrix.txt 0.4 836241 > historic_metapop_relatedness_maxr0.4_ids.txt
$ /mnt/research/Fitz_Lab/projects/mosaic/popgen/relatedness/scripts/subsetUnrelated.R cr_founders_relatedness_matrix.txt 0.4 836241 > cr_founders_relatedness_maxr0.4_ids.txt
$ /mnt/research/Fitz_Lab/projects/mosaic/popgen/relatedness/scripts/subsetUnrelated.R donor_pops_relatedness_matrix.txt 0.4 836241 > donor_pops_relatedness_maxr0.4_ids.txt
$ /mnt/research/Fitz_Lab/projects/mosaic/popgen/relatedness/scripts/subsetUnrelated.R fsj_mosaic_biallelic_snps_main_autosomes_qc_relatedness_matrix_fmt.txt 0.4 836241 > fsj_mosaic_biallelic_snps_main_autosomes_qc_relatedness_maxr0.4_ids.txt

--- end bash code ---

## Take random subsets of individuals so that all within-group pairwise relatedness is <= 0.01
## Consider these subsets of unrelated individuals.

--- begin R code ---

sample_unrelated <- function(pop, relate.matrix, maxr=0.01, niter=100) {

        grp.idx <- grep(pop,colnames(relate.matrix))
        urelate = NULL

        for (i in 1:niter) {
                submat = relate.matrix[grp.idx,grp.idx]
                while (max(submat,na.rm=TRUE) > maxr) {
                        id = colnames(submat)
                        ind.pairs <- combn(id, m=2)
                        idx.perm <- sample(1:ncol(ind.pairs),size=ncol(ind.pairs))
                        reset = 0
                        for (i in idx.perm) {
                                ind.vec = ind.pairs[,i]
                                a.idx = which(id == ind.vec[1])
                                b.idx = which(id == ind.vec[2])
                                r = relate.matrix[a.idx, b.idx]
                                if (r > maxr) {
                                        a.relatives = length(which(submat[a.idx,] > maxr))
                                        b.relatives = length(which(submat[b.idx,] > maxr))
                                        discard.idx = ifelse(a.relatives > b.relatives, a.idx, b.idx)
                                        submat <- submat[-discard.idx, -discard.idx]
                                        reset = 1
                                        break
                                }
                                if (reset == 1) break
                        }
                }
                if (is.null(urelate) == TRUE || ncol(submat) > ncol(urelate)) urelate = submat
        }

        return(colnames(urelate))
}

rmat <- as.matrix(read.table('/home/tyler/Dropbox/research/jay/mosaic/popgen/relatedness/fsj_mosaic_biallelic_snps_main_autosomes_qc_relatedness_matrix.txt',head=TRUE,row.names=1))
rmat <- rmat[-which(colnames(rmat) == "T_072.Site_1"),-which(colnames(rmat) == "T_072.Site_1")] # exclude RSW-K because this individual was not translocated

set.seed(324986)
contemp.unrelated <- sample_unrelated(pop="Contemporary", relate.matrix=rmat, maxr=0.01, niter=1000) # unrelated contemporary CR subset
res.unrelated <- sample_unrelated(pop="Resident", relate.matrix=rmat, maxr=0.01, niter=1000) # unrelated resident CR subset
trans.unrelated <- sample_unrelated(pop="Site|Texaco", relate.matrix=rmat, maxr=0.01, niter=1000) # unrelated translocated subset

contemp.unrelated.df  <- data.frame(ID=gsub("\\.Contemporary","",contemp.unrelated))
res.unrelated.df  <- data.frame(ID=gsub("\\.Resident","",res.unrelated))
trans.unrelated.df <- data.frame(ID=gsub("\\.Site.+|\\.Texaco","",trans.unrelated))

# write subset lists of individuals for which all r <= 0.01
#write.table(contemp.unrelated.df, file='/home/tyler/Dropbox/research/jay/mosaic/popgen/unrelated_subsample/contemporary_unrelated_samples.txt',col.names=FALSE,row.names=FALSE,quote=FALSE)
#write.table(res.unrelated.df, file='/home/tyler/Dropbox/research/jay/mosaic/popgen/unrelated_subsample/resident_unrelated_samples.txt',col.names=FALSE,row.names=FALSE,quote=FALSE)
#write.table(trans.unrelated.df, file='/home/tyler/Dropbox/research/jay/mosaic/popgen/unrelated_subsample/translocated_unrelated_samples.txt',col.names=FALSE,row.names=FALSE,quote=FALSE)

--- end R code ---


#
#
#


## ---------- SITE FREQUENCY SPECTRUM FOR QUALITY CONTROL ---------- ##

# Folded maximum likelihood SFS calculated from all sites as a data sanity check

Estimate per site allele frequency likelihoods for all quality controlled sites

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/popgen/sfs/main_autosome_grp_sfs_array2.sh
implements:

--- start bash code ---

GRP_ARR=('resident' 'C' 'T' 'M4')
FSJGRP="${GRP_ARR[$SLURM_ARRAY_TASK_ID]}"
BAMLIST="/mnt/research/Fitz_Lab/projects/mosaic/map/mosaic_${FSJGRP}_bam_list.txt"
OUTPREFIX="/mnt/research/Fitz_Lab/projects/mosaic/popgen/sfs/fsj_mosaic_allsites_main_autosomes_qc_${FSJGRP}"
REGFILE='/mnt/research/Fitz_Lab/ref/bird/FSJ_V3/FSJ_V3_main_autosomes.txt'
SITESFILE='/mnt/research/Fitz_Lab/projects/mosaic/variants/vcf/all_sites/fsj_mosaic_allsites_main_autosomes_qc.pos'
REF='/mnt/research/Fitz_Lab/ref/bird/FSJ_V3/FSJ.V3.fa'

CMD="angsd -bam $BAMLIST -out $OUTPREFIX -GL 1 -doSaf 1 -anc $REF -minQ 20 -minMapQ 20 -rf $REGFILE -sites $SITESFILE -P 4"

printf "\n%s\n\n" "$CMD"

eval $CMD

--- end bash code ---

Estimate folded SFS

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/popgen/sfs/main_autosome_grp_realsfs_fold_array2.sh
implements:

--- start bash code ---

GRP_ARR=('resident' 'C' 'T' 'M4')
FSJGRP="${GRP_ARR[$SLURM_ARRAY_TASK_ID]}"
SAFIDX="/mnt/research/Fitz_Lab/projects/mosaic/popgen/sfs/fsj_mosaic_allsites_main_autosomes_qc_${FSJGRP}.saf.idx"
OUTSFS="/mnt/research/Fitz_Lab/projects/mosaic/popgen/sfs/fsj_mosaic_allsites_main_autosomes_qc_${FSJGRP}.fold.sfs"

CMD="realSFS $SAFIDX -fold 1 -P 20 > $OUTSFS"

printf "\n%s\n\n" "$CMD"

eval $CMD

--- end bash code ---

# Folded SFS calculated using all sites for subsets of individuals for which all pairwise relatedness is <= 0.01

Estimate allele frequency likelihoods for subset of unrelated individuals at all quality-controlled sites

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/popgen/sfs/main_autosome_unrelated_grp_array.sh
implements:

--- start bash code ---

GRP_ARR=('contemporary' 'resident' 'translocated')
FSJGRP="${GRP_ARR[$SLURM_ARRAY_TASK_ID]}"
BAMLIST="/mnt/research/Fitz_Lab/projects/mosaic/map/unrelated/${FSJGRP}_unrelated_bam_list.txt"
OUTPREFIX="/mnt/research/Fitz_Lab/projects/mosaic/popgen/sfs/fsj_mosaic_allsites_main_autosomes_qc_${FSJGRP}_unrelated"
FFILE="/mnt/research/Fitz_Lab/projects/mosaic/popgen/fstats/unrelated/${FSJGRP}_unrelated_samples_F.txt"
REGFILE='/mnt/research/Fitz_Lab/ref/bird/FSJ_V3/FSJ_V3_main_autosomes.txt'
SITESFILE='/mnt/research/Fitz_Lab/projects/mosaic/variants/vcf/all_sites/fsj_mosaic_allsites_main_autosomes_qc.pos'
REF='/mnt/research/Fitz_Lab/ref/bird/FSJ_V3/FSJ.V3.fa'

CMD="angsd -bam $BAMLIST -out $OUTPREFIX -GL 1 -doSaf 2 -indF $FFILE -anc $REF -doMaf 1 -doMajorMinor 1 -minQ 20 -minMapQ 20 -rf $REGFILE -sites $SITESFILE -P 4"

printf "\n%s\n\n" "$CMD"

eval $CMD

--- end bash code ---

Note: GitHub version of /mnt/research/Fitz_Lab/projects/mosaic/popgen/sfs/main_autosome_unrelated_grp_array.sh 
is called main_autosome_unrelated_grp_sfs_array.sh.

Estimate the SFS for subsets of unrelated individuals based on all quality-controlled sites

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/popgen/sfs/main_autosome_unrelated_grp_realsfs_fold_array.sh

--- start bash code ---

GRP_ARR=('contemporary' 'resident' 'translocated')
FSJGRP="${GRP_ARR[$SLURM_ARRAY_TASK_ID]}"
SAFIDX="/mnt/research/Fitz_Lab/projects/mosaic/popgen/sfs/fsj_mosaic_allsites_main_autosomes_qc_${FSJGRP}_unrelated.saf.idx"
OUTSFS="/mnt/research/Fitz_Lab/projects/mosaic/popgen/sfs/fsj_mosaic_allsites_main_autosomes_qc_${FSJGRP}_unrelated.fold.sfs"

CMD="realSFS $SAFIDX -fold 1 -P 16 > $OUTSFS"

printf "\n%s\n\n" "$CMD"

eval $CMD

--- end bash code ---

# R functions for visualizing SFS

--- start R code ---

# plot SFS
plotsfs <- function(x = NULL, outfile = NULL, grp = NULL, fold = 0) {
        if (!is.null(outfile)) pdf(file=outfile) else x11()
        par(mfrow=c(2,2))
        for (i in 1:length(x)) {
                if (fold == 0) {
                        barplot(x[[i]][-c(1,length(x[[i]]))], main = grp[i], ylab="Number sites", xlab="Derived AF", names.arg=1:(length(x[[i]])-2))
                } else if (fold == 1) {
                        barplot(x[[i]][-1], main = grp[i], ylab="Number sites", xlab="MAF", names.arg=1:(length(x[[i]])-1))
                } else {
                        stop("fold argument must be 0 or 1")
                }
                if (is.null(outfile) && i %% 4 == 0) {
                        x11()
                        par(mfrow=c(2,2))
                }
        }
        if (!is.null(outfile)) invisible(dev.off())
}

neutral.sfs <- function(n) {
	# makes expected neutral SFS
        # n: diploid sample size
        sfs.vec <- rep(NA,n)
        for (i in 1:((2*n)-1)) {
                sfs.vec[i] = 1/i
        }
        sfs.vec <- sfs.vec/sum(sfs.vec)
        return(sfs.vec)
}

foldsfs <- function(x) {
	# folds the SFS
        n = length(x)+1
        fold.sfs <- NULL
        for (i in 1:(n/2-1)) {
                fold.sfs <- c(fold.sfs, x[i]+x[n-i])
        }
        fold.sfs <- c(fold.sfs, x[n/2])

        return(fold.sfs)
}

# Examples for reading in SFS data for use the with function above

# define groups and sample sizes
sfsdir='./sfs/'
jaygrp = c('C','E','T','M4','I','all')
dipn = c(28, 11, 29, 13, 6, 87)
sfs.fold <- list()
sfs.ufold <- list()
bisnp.fold <- list()
bisnp.ufold <- list()

# read in SFS data
for (i in 1:length(jaygrp)) {
        grp <- jaygrp[i]
        n <- dipn[i]
        sfs.fold[[i]] <- scan(paste0(sfsdir,"fsj_mosaic_allsites_main_autosomes_qc_",grp,".fold.sfs"))
        sfs.fold[[i]] <- sfs.fold[[i]][1:(n+1)]
        sfs.ufold[[i]] <- scan(paste0(sfsdir,"fsj_mosaic_allsites_main_autosomes_qc_",grp,".unfold.sfs"))
        bisnp.fold[[i]] <- scan(paste0(sfsdir,"fsj_mosaic_biallelic_snps_main_autosomes_qc_",grp,".fold.sfs"))
        bisnp.fold[[i]] <- bisnp.fold[[i]][1:(n+1)]
        bisnp.ufold[[i]] <- scan(paste0(sfsdir,"fsj_mosaic_biallelic_snps_main_autosomes_qc_",grp,".unfold.sfs"))
}

# plot each group (includes Contemporary CR population, 'C', plot)
plotsfs(x=sfs.fold, outfile='fsj_mosaic_allsites_main_autosomes_qc_fold.pdf', grp=jaygrp, fold=1)
plotsfs(x=sfs.ufold, outfile='fsj_mosaic_allsites_main_autosomes_qc_unfold.pdf', grp=jaygrp, fold=0)
plotsfs(x=bisnp.fold, outfile='fsj_mosaic_biallelic_snps_main_autosomes_qc_fold.pdf', grp=jaygrp, fold=1)
plotsfs(x=bisnp.ufold, outfile='fsj_mosaic_biallelic_snps_main_autosomes_qc_ufold.pdf', grp=jaygrp, fold=0)

# Resident CR plot
res <- scan('./sfs/fsj_mosaic_allsites_main_autosomes_qc_resident.fold.sfs')
res.fold <- res[2:((length(res)-1)/2)]

# expected resident SFS
res.exp <- neutral.sfs(n=16)
res.exp.fold <- foldsfs(res.exp)
res.exp.fold.counts <- sum(res.fold) * res.exp.fold

barplot(res.exp.fold.counts, xlab="Minor allele frequency", names.arg = 1:length(res.exp.fold.counts), ylab="Number sites",cex.lab=1.3, cex.axis=1.3)

--- end R code ---


#
#
#


## ---------- FST ---------- ##

FST were calculated using variable sites only

# Estimate unfolded joint SFS to serve as joint allele frequency prior for SNPs

Estimate allele frequency likelihoods for quality-controlled SNPs
Note: the 'translocated' group for FST estimation includes RSW-K (T_072, no translocated) and so really represents the pooled donor sites
while the 'translocated_CR' group excluded RSW-K and so is only translocated jays.

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/popgen/sfs/main_autosome_snps_grp_sfs_array2.sh
implements:

--- start bash code ---

GRP_ARR=('resident' 'translocated' 'C' 'translocated_CR')
FSJGRP="${GRP_ARR[$SLURM_ARRAY_TASK_ID]}"
BAMLIST="/mnt/research/Fitz_Lab/projects/mosaic/map/mosaic_${FSJGRP}_bam_list.txt"
OUTPREFIX="/mnt/research/Fitz_Lab/projects/mosaic/popgen/sfs/fsj_mosaic_biallelic_snps_main_autosomes_qc_${FSJGRP}"
REGFILE='/mnt/research/Fitz_Lab/ref/bird/FSJ_V3/FSJ_V3_main_autosomes.txt'
SITESFILE='/mnt/research/Fitz_Lab/projects/mosaic/variants/vcf/biallelic_snps/fsj_mosaic_biallelic_snps_main_autosomes_qc.pos'
REF='/mnt/research/Fitz_Lab/ref/bird/FSJ_V3/FSJ.V3.fa'

CMD="angsd -bam $BAMLIST -out $OUTPREFIX -GL 1 -doSaf 1 -anc $REF -minQ 20 -minMapQ 20 -rf $REGFILE -sites $SITESFILE -P 4"

printf "\n%s\n\n" "$CMD"

eval $CMD

--- end bash code ---


Estimate unfolded 2D-SFS

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/popgen/sfs/main_autosome_snps_2dsfs_array2.sh
implements:

--- start bash code ---

CMP=('resident:C' 'resident:translocated' 'translocated_CR:C')
POP1=$(echo "${CMP[$SLURM_ARRAY_TASK_ID]}" | cut -f1 -d':')
POP2=$(echo "${CMP[$SLURM_ARRAY_TASK_ID]}" | cut -f2 -d':')
SAFIDX1="/mnt/research/Fitz_Lab/projects/mosaic/popgen/sfs/fsj_mosaic_biallelic_snps_main_autosomes_qc_${POP1}.saf.idx"
SAFIDX2="/mnt/research/Fitz_Lab/projects/mosaic/popgen/sfs/fsj_mosaic_biallelic_snps_main_autosomes_qc_${POP2}.saf.idx"
OUTSFS="/mnt/research/Fitz_Lab/projects/mosaic/popgen/sfs/fsj_mosaic_biallelic_snps_main_autosomes_qc_${POP1}_vs_${POP2}.unfold.2dsfs"

CMD="realSFS $SAFIDX1 $SAFIDX2 -P 20 > $OUTSFS"

printf "\n%s\n\n" "$CMD"

eval $CMD

--- end bash code ---

# Estimate pairwise FST for {resident CR vs donor populations}, {CR contemporary vs CR resident}, {CR contemporary vs CR translocated group}

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/popgen/fstats/pairwise_fst_array2.sh
implements:

--- start bash code ---

CMP=('resident:C' 'resident:translocated' 'translocated_CR:C')
POP1=$(echo "${CMP[$SLURM_ARRAY_TASK_ID]}" | cut -f1 -d':')
POP2=$(echo "${CMP[$SLURM_ARRAY_TASK_ID]}" | cut -f2 -d':')
SAFIDX1="/mnt/research/Fitz_Lab/projects/mosaic/popgen/sfs/fsj_mosaic_biallelic_snps_main_autosomes_qc_${POP1}.saf.idx"
SAFIDX2="/mnt/research/Fitz_Lab/projects/mosaic/popgen/sfs/fsj_mosaic_biallelic_snps_main_autosomes_qc_${POP2}.saf.idx"
SFSPRIOR="/mnt/research/Fitz_Lab/projects/mosaic/popgen/sfs/fsj_mosaic_biallelic_snps_main_autosomes_qc_${POP1}_vs_${POP2}.unfold.2dsfs"
OUTFILE="/mnt/research/Fitz_Lab/projects/mosaic/popgen/fstats/fsj_mosaic_biallelic_snps_main_autosomes_qc_${POP1}_vs_${POP2}"

CMD="realSFS fst index $SAFIDX1 $SAFIDX2 -sfs $SFSPRIOR -fstout $OUTFILE"

printf "\n%s\n\n" "$CMD"

eval $CMD

--- end bash code ---

Reported the "Fst.Weight" values.


#
#
#


## ---------- GENETIC DIVERSITY ---------- ##

## Heterozygosity

Estimate posterior expected H for each sample from their allele frequency posterior probabilities using FROH (see below for calculation)
in the genotype prior. This estimation accounts for inbreeding and does not assume Hardy-Weinberg equilibrium.

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/popgen/theta/heterozygosity/Froh_H/scripts/heterozygosity_froh_pop_specific_baq_array.sh
implements:

--- start bash code ---

BAMLIST='/mnt/research/Fitz_Lab/projects/mosaic/map/mosaic_bam_list.txt'
BAMFILE=$(sed -n "${SLURM_ARRAY_TASK_ID}p" "$BAMLIST")
SAMPLIST='/mnt/research/Fitz_Lab/projects/mosaic/mosiac_ids.txt'
SAMP=$(sed -n "${SLURM_ARRAY_TASK_ID}p" "$SAMPLIST")
REF='/mnt/research/Fitz_Lab/ref/bird/FSJ_V3/FSJ.V3.fa'
REGFILE='/mnt/research/Fitz_Lab/ref/bird/FSJ_V3/FSJ_V3_main_autosomes.txt'
SITESFILE='/mnt/research/Fitz_Lab/projects/mosaic/variants/vcf/all_sites/fsj_mosaic_allsites_main_autosomes_qc.pos'
OUTPREFIX="/mnt/research/Fitz_Lab/projects/mosaic/popgen/theta/heterozygosity/Froh_H/sfs/pop_specific/${SAMP}_allsites_main_autosomes_qc_Froh_pop_specific_baq"
FFILE="/mnt/research/Fitz_Lab/projects/mosaic/popgen/fstats/individual_f_files/${SAMP}_biallelic_snps_main_autosomes_qc_pop_specific_af_Froh.txt"
EXEC='/mnt/research/Fitz_Lab/projects/mosaic/popgen/theta/heterozygosity/ngsF_H/scripts/saf2H.pl'
EXEC2='/mnt/research/Fitz_Lab/projects/mosaic/popgen/sfs/revision1_sfs/saf2sfs.pl'

SAFCMD="angsd -i $BAMFILE -baq 1 -C 50 -ref $REF -out $OUTPREFIX -GL 1 -doSaf 2 -indF $FFILE -anc $REF -doMaf 1 -doMajorMinor 1 -minQ 20 -minMapQ 20 -remove_bads 1 -only_proper_pairs 1 -rf $REGFILE -sites $SITESFILE -P 4"

printf "\n%s\n\n" "$SAFCMD"

eval $SAFCMD
wait

HCMD="realSFS print ${OUTPREFIX}.saf.idx | $EXEC > ${OUTPREFIX}_H.txt"

printf "\n%s\n\n" "$HCMD"

eval $HCMD
wait

SFSCMD="realSFS print ${OUTPREFIX}.saf.idx | $EXEC2 0 > ${OUTPREFIX}_unfold.sfs"

printf "\n%s\n\n" "$SFSCMD"

eval $SFSCMD

--- end bash code ---


H estimates calculated above where stored in the M4_sequenced_FSJsamples_metadata.txt and in the 'H' field of the M4_sequenced_individual_metadata.tsv file 
deposited to dryad.

# Visualize H distrubutions with boxplots (Figure 3C)

--- start R code ---

library(scales)

# read in data

meta <- read.table('/home/tyler/Dropbox/research/jay/mosaic/metadata/M4_sequenced_FSJsamples_metadata.txt',head=TRUE,sep="\t")

# set up plotting features

meta$biopoint = biopoint(meta$pop)
meta$popcol <- popcolor(meta)

meta$group <- replace(meta$pop, which(meta$pop == "Golden_Aster_Scrub" | meta$pop == "Brigman" | meta$pop == "W.Balm" | 
meta$pop == "Duette_headwaters" | meta$pop == "Sun_City"), "M4")

meta$group <- replace(meta$group, which(meta$group == "SITE_1" | meta$group == "SITE_12" | meta$group == "SITE_13" | 
meta$group == "SITE_18" | meta$group == "TEXACO"), "Translocated")

meta$group = factor(meta$group, levels=c("Contemporary", "Resident", "Translocated", "M4"))o

# omit T_072 (RSW-K) because this site 1 bird was not translocated and migrated to LMSP, which is outside of the Core
meta.sub <- meta[-which(meta$LAB_ID == "T_072"),]

# H boxplot

range(meta$H) # set limits to exceed these values
#[1] 0.000532 0.001462

#png(file='/home/tyler/Dropbox/research/jay/mosaic/figures/H_postexp_distribution_Froh_pop_specific_af_baq.png',width=7, height=7,units='in', res=300)
h_boxplot3(x=meta.sub, n=23, lev=levels(meta.sub$group), ylabel="Heterozygosity per site", pntlab=meta.sub$biopoint, seed=10287, color=meta.sub$popcol, ylimits=c(0.0005,0.0016), labpos=c(0.8,1.95,3,4))
#dev.off()

# make plot with ID labels
#pdf(file='/home/tyler/Dropbox/research/jay/mosaic/figures/H_postexp_distribution_Froh_pop_specific_af_baq_ids.pdf',width=7, height=7)
h_boxplot3(x=meta.sub, n=23, lev=levels(meta.sub$group), ylabel="Heterozygosity per site", pntlab=NULL, seed=10287, color=meta.sub$popcol, ylimits=c(0.0005,0.0016), 
labpos=c(0.8,1.95,3,4), idlabels=meta.sub$LAB_ID)
#dev.off()

---- end R code ---


# Check for relationships between H and sequence depth and test for differences in mean H between groups

--- start R code ---

library(boot)
library(scales) # for alpha

# read in data with H estimates
meta <- read.table("/home/tyler/Dropbox/research/jay/mosaic/metadata/M4_sequenced_FSJsamples_metadata.txt", head=TRUE)

# read in subsets of indivdiuals for which all pairwise relatedness was < 0.4

res.prune2 <- read.table('/home/tyler/Dropbox/research/jay/mosaic/popgen/relatedness/unrelated_subsets/resident_cr_noE030_relatedness_maxr0.4_ids_seed836241.txt',head=FALSE)$V1 # excludes K-SRB
trans.prune <- read.table('/home/tyler/Dropbox/research/jay/mosaic/popgen/relatedness/unrelated_subsets/translocated_relatedness_maxr0.4_ids_seed328974.txt',head=FALSE)$V1
contemp.prune <- read.table('/home/tyler/Dropbox/research/jay/mosaic/popgen/roh/inputs/contemporary_cr_relatedness_maxr0.4_ids.txt',head=FALSE)$V1 # this is not necessary because all contemporary individuals are related with r < 0.4

# define groups to test differences between

colnames(meta)[which(colnames(meta) == "pop_name_full")] = "POPULATION" # this is just so column names match the released metadata
meta$group = replace(meta$POPULATION, which(meta$POPULATION == "contemporary_Core_Region"), "contemporary_cr")
meta$group = replace(meta$group, which(meta$group == "resident_Core_Region"), "resident_cr")
meta$group = replace(meta$group, which(meta$group == "Site_1" | meta$group == "Site_12" | meta$group == "Site_13" | meta$group == "Site_18" | meta$group == "Texaco"), "donor")
meta$group = replace(meta$group, which(meta$group == "Golden_Aster_Scrub" | meta$group == "Brigman" | meta$group == "West_Balm" | meta$group == "Duette_Headwaters" | meta$group == "Sun_City"), "other_m4")

meta.sub = meta[-which(meta$LAB_ID == "T_072"),] # omit T_072 because this site 1 bird was not translocated into the CR. All donor site birds in this dataframe were translocated.
meta.sub2 = meta.sub[-which(meta.sub$LAB_ID == "E_030"),] # omit E_030 (K-SRB) because this CR LR "resident" was the offspring of a site 12 father and CR resident mother

# Test for correlation between H and depth

hvd_fit <- lm(formula = meta$H ~ meta$autosome_depth)

summary(hvd_fit)
#
#Call:
#lm(formula = meta$H ~ meta$autosome_depth)
#
#Residuals:
#       Min         1Q     Median         3Q        Max 
#-2.656e-04 -1.584e-04 -1.258e-05  1.086e-04  6.281e-04 
#
#Coefficients:
#                     Estimate Std. Error t value Pr(>|t|)    
#(Intercept)         7.041e-04  1.423e-04   4.947 3.77e-06 ***
#meta$autosome_depth 1.530e-05  1.935e-05   0.791    0.431    
#---
#Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1
#
#Residual standard error: 0.0001843 on 85 degrees of freedom
#Multiple R-squared:  0.007303,	Adjusted R-squared:  -0.004376 
#F-statistic: 0.6253 on 1 and 85 DF,  p-value: 0.4313

#hist(resid(hvd_fit),breaks=20)

shapiro.test(resid(hvd_fit)) # errors are a bit skewed so will use bootstrap to check significance
#
#	Shapiro-Wilk normality test
#
#data:  resid(hvd_fit)
#W = 0.93925, p-value = 0.0004916

set.seed(83816711)
hvd.boot <- boot(data.frame(x=meta$autosome_depth, y=meta$H), getBeta1, R=10000, stype="i", sim="ordinary")
hvd.ci <- boot.ci(hvd.boot, conf=0.95, type=c("perc","bca"))

hvd.ci$bca
#     conf                                          
#[1,] 0.95 159.51 9637.59 -2.240671e-05 7.343164e-05

# standardize depth and H to ensure that there are no problems with effect size precision
h.std = (meta$H-mean(meta$H))/sd(meta$H)
depth.std = (meta$autosome_depth - mean(meta$autosome_depth))/sd(meta$autosome_depth)
hvd_std_fit = lm(h.std ~ depth.std)
set.seed(83816711)
hvd_std.boot <- boot(data.frame(x=depth.std, y=h.std), getBeta1, R=10000, stype="i", sim="ordinary")
hvd_std.ci <- boot.ci(hvd_std.boot, conf=0.95, type=c("perc","bca"))

hvd_std.ci
#BOOTSTRAP CONFIDENCE INTERVAL CALCULATIONS
#Based on 10000 bootstrap replicates
#
#CALL : 
#boot.ci(boot.out = hvd_std.boot, conf = 0.95, type = c("perc", 
#    "bca"))
#
#Intervals : 
#Level     Percentile            BCa          
#95%   (-0.1109,  0.4406 )   (-0.1220,  0.4117 )  
#Calculations and Intervals on Original Scale

# The unstandardized and standardized results are consistent

# Plot H vs depth (Fig. S7D)

biotype_col = bioclass_col(meta$POPULATION)

range(meta$H) # for setting y-lilmits
#[1] 0.000532 0.001462

#png(file="/home/tyler/Dropbox/research/jay/mosaic/figures/methods_evaluation/H_post_exp_froh_pop_specific_baq_v_depth.png", width=7, height=7, units='in', res=300)
par(mgp=c(2.65,1,0))
plot(x = meta$autosome_depth, y = meta$H, cex=1.5, pch=21, col=biotype_col, bg=alpha(biotype_col,0.6), xlab="Average sequencing depth",
ylab=expression(paste("Posterior expected ", italic("H"))),cex.lab=1.5, cex.axis=1.5, ylim=c(0.0005,0.0015))
abline(a=hvd_fit$coefficients[1], b=hvd_fit$coefficients[2], col="gray40")
legend('topright',legend=c("Contemporary CR","Resident CR","Donor population","Other M4"), fill=c("hotpink2","purple2","dodgerblue2","gold2"),bty='n',cex=1.2)
text(x=11,y=0.00093,label=bquote(italic(r)^2 == .(round(summary(hvd_fit)$r.square, digits=5))), cex=1.3)
#dev.off()

# test if H for different groups is approximately normally distributed

# all contemporary
shapiro.test(meta.sub$H[which(meta.sub$group == "contemporary_cr")])
#
#	Shapiro-Wilk normality test
#
#data:  meta.sub$H[which(meta.sub$group == "contemporary_cr")]
#W = 0.96922, p-value = 0.5597

# resident r-pruned without E_030 - deviates a bit from normal, but will still use t-test to compare means because of its robustness to minor deviations from normal
shapiro.test(meta$H[which(meta$LAB_ID %in% res.prune2 == TRUE)])
#
#	Shapiro-Wilk normality test
#
#data:  meta$H[which(meta$LAB_ID %in% res.prune2 == TRUE)]
#W = 0.86993, p-value = 0.05219

# translocated r-pruned
shapiro.test(meta$H[which(meta$LAB_ID %in% trans.prune == TRUE)])
#
#	Shapiro-Wilk normality test
#
#data:  meta$H[which(meta$LAB_ID %in% trans.prune == TRUE)]
#W = 0.93402, p-value = 0.3131


# Test for differences in mean H between groups

# contemporary vs r-pruned residents without E_030
t.test(x=meta$H[which(meta$LAB_ID %in% contemp.prune == TRUE)], y=meta$H[which(meta$LAB_ID %in% res.prune2 == TRUE)], alternative="two.sided")
#
#	Welch Two Sample t-test
#
#data:  meta$H[which(meta$LAB_ID %in% contemp.prune == TRUE)] and meta$H[which(meta$LAB_ID %in% res.prune2 == TRUE)]
#t = -5.6624, df = 13.352, p-value = 7.018e-05
#alternative hypothesis: true difference in means is not equal to 0
#95 percent confidence interval:
# -0.0003871193 -0.0001737158
#sample estimates:
#   mean of x    mean of y 
#0.0006414286 0.0009218462 


# contemporary vs r-pruned translocated
t.test(x=meta$H[which(meta$LAB_ID %in% contemp.prune == TRUE)], y=meta$H[which(meta$LAB_ID %in% trans.prune == TRUE)], alternative="two.sided")
#
#	Welch Two Sample t-test
#
#data:  meta$H[which(meta$LAB_ID %in% contemp.prune == TRUE)] and meta$H[which(meta$LAB_ID %in% trans.prune == TRUE)]
#t = -5.7909, df = 16.23, p-value = 2.607e-05
#alternative hypothesis: true difference in means is not equal to 0
#95 percent confidence interval:
# -0.0003331808 -0.0001547621
#sample estimates:
#   mean of x    mean of y 
#0.0006414286 0.0008854000 

# r-pruned resident without E_030 vs translocated
t.test(x=meta$H[which(meta$LAB_ID %in% res.prune2 == TRUE)], y=meta$H[which(meta$LAB_ID %in% trans.prune == TRUE)], alternative="two.sided")
#
#	Welch Two Sample t-test
#
#data:  meta$H[which(meta$LAB_ID %in% res.prune2 == TRUE)] and meta$H[which(meta$LAB_ID %in% trans.prune == TRUE)]
#t = 0.57849, df = 24.489, p-value = 0.5682
#alternative hypothesis: true difference in means is not equal to 0
#95 percent confidence interval:
# -9.344712e-05  1.663394e-04
#sample estimates:
#   mean of x    mean of y 
#0.0009218462 0.0008854000 

# group H summary statistics

# contemporary CR population
mean(meta$H[which(meta$LAB_ID %in% contemp.prune == TRUE)])
#[1] 0.0006414286
sd(meta$H[which(meta$LAB_ID %in% contemp.prune == TRUE)])
#[1] 6.012113e-05

# r-pruned residents CR population excluding E_030
mean(meta$H[which(meta$LAB_ID %in% res.prune2 == TRUE)])
#[1] 0.0009218462
sd(meta$H[which(meta$LAB_ID %in% res.prune2 == TRUE)])
#[1] 0.0001737948

# r-pruned translocated jays
mean(meta$H[which(meta$LAB_ID %in% trans.prune == TRUE)])
#[1] 0.0008854
sd(meta$H[which(meta$LAB_ID %in% trans.prune == TRUE)])
#[1] 0.0001571245

--- end R code ---


## Population nucleotide diversity (pi/Tajima's theta)

First calculate an estimate of the genome-wide SFS for each group that accounts for indivivdual inbreeding and 
which does not assume HWE.

Estimate per site allele frequency probabilities
sbatch /mnt/research/Fitz_Lab/projects/mosaic/popgen/sfs/revision1_sfs/main_autosome_af_postprob.sh
which implements:

--- start bash code ---

INFILES='/mnt/research/Fitz_Lab/projects/mosaic/popgen/sfs/revision1_sfs/input_lists.txt'
ID=$(sed -n "${SLURM_ARRAY_TASK_ID}p" $INFILES | cut -f1)
BAMLIST=$(sed -n "${SLURM_ARRAY_TASK_ID}p" $INFILES | cut -f2)
FFILE=$(sed -n "${SLURM_ARRAY_TASK_ID}p" $INFILES | cut -f3)
OUTPREFIX="/mnt/research/Fitz_Lab/projects/mosaic/popgen/sfs/revision1_sfs/${ID}_allsites_main_autosomes_qc_postprobs"
REGFILE='/mnt/research/Fitz_Lab/ref/bird/FSJ_V3/FSJ_V3_main_autosomes.txt'
SITESFILE='/mnt/research/Fitz_Lab/projects/mosaic/variants/vcf/all_sites/fsj_mosaic_allsites_main_autosomes_qc.pos'
REF='/mnt/research/Fitz_Lab/ref/bird/FSJ_V3/FSJ.V3.fa'

CMD="angsd -bam $BAMLIST -out $OUTPREFIX -GL 1 -doSaf 2 -indF $FFILE -anc $REF -doMaf 1 -doMajorMinor 1 -minQ 20 -minMapQ 20 -rf $REGFILE -sites $SITESFILE -P 4"

printf "\n%s\n\n" "$CMD"

eval $CMD

--- end bash code ---


Estimate the genome-wide SFS
$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/popgen/sfs/revision1_sfs/calc_posterior_expected_sfs_array.sh
implements:

--- start bash code ---

EXEC='/mnt/research/Fitz_Lab/projects/mosaic/popgen/sfs/revision1_sfs/saf2sfs.pl'
GRP_ARR=('contemporary' 'resident' 'resident_prune' 'translocated' 'translocated_prune')
FSJGRP="${GRP_ARR[$SLURM_ARRAY_TASK_ID]}"
SAFIDX="/mnt/research/Fitz_Lab/projects/mosaic/popgen/sfs/revision1_sfs/${FSJGRP}_allsites_main_autosomes_qc_postprobs.saf.idx"
OUTSFS="/mnt/research/Fitz_Lab/projects/mosaic/popgen/sfs/revision1_sfs/${FSJGRP}_allsites_main_autosomes_qc_postprobs_fold.sfs"

CMD="realSFS print $SAFIDX | $EXEC 1 > $OUTSFS"

printf "\n%s\n\n" "$CMD"

eval $CMD

--- end bash code ---


Calculate nucleotide diversity using the SFS above as a prior probability for the site allele frequencies

$ sbatch icer_hpcc:/mnt/research/Fitz_Lab/projects/mosaic/popgen/theta/revision1_theta/thetas_expost_sfs_array.sh
implements:

--- start bash code ---

GRP_ARR=('contemporary' 'resident' 'resident_prune' 'translocated' 'translocated_prune')
FSJGRP="${GRP_ARR[$SLURM_ARRAY_TASK_ID]}"
SAFIDX="/mnt/research/Fitz_Lab/projects/mosaic/popgen/sfs/revision1_sfs/${FSJGRP}_allsites_main_autosomes_qc_likes.saf.idx"
SFS="/mnt/research/Fitz_Lab/projects/mosaic/popgen/sfs/revision1_sfs/${FSJGRP}_allsites_main_autosomes_qc_postprobs_fold.sfs"
OUTFILE="/mnt/research/Fitz_Lab/projects/mosaic/popgen/theta/revision1_theta/${FSJGRP}_allsites_main_autosomes_qc_expost"
THETAIDX="${OUTFILE}.thetas.idx"

CMD="realSFS saf2theta $SAFIDX -outname $OUTFILE -sfs $SFS -fold 1"

printf "\n%s\n\n" "$CMD"

eval $CMD
wait

CMD2="thetaStat do_stat $THETAIDX"

printf "\n%s\n\n" "$CMD2"

eval $CMD2

--- end bash code ---

Transform the theta estimates from above (which includes pi) into a per site estimate of theta

--- start R code ---

grp=c('contemporary','resident','resident_prune','translocated','translocated_prune')
path='/mnt/research/Fitz_Lab/projects/mosaic/popgen/theta/revision1_theta'
suffix='_allsites_main_autosomes_qc_expost.thetas.idx.pestPG'

# read in theta estimates
df = NULL
for (g in grp) {
	theta <- read.table(paste0(path,"/",g,suffix))
	nsites = sum(theta[,14])
	theta$wt = theta[,14]/nsites
	df=rbind(df, data.frame(Group=g, Theta_Watterson = sum(theta[,4])/nsites, Pi = sum(theta[,5])/nsites, TajimaD = sum(theta[,9]*theta$wt)))
}

#write.table(df, file='/mnt/research/Fitz_Lab/projects/mosaic/popgen/theta/revision1_theta/theta_estimates_postexp_sfs_prior.txt',col.names=TRUE,row.names=FALSE,sep="\t",quote=FALSE)

--- end R code ---


#
#
#


## ---------- INBREEDING NGSF ---------- ##

## Individual inbreeding based on deviation from Hardy-Weinberg Equilibrium genotype frequencies

I. The following describes estimation of individual inbreeding coefficients, F, with ngsF using population-specific allele 
frequencies estimated with without relatedness-pruning (F visualized in Figuree S9). These values are in the 'F_PS_ALL' field of the 
inbreed_coefficient_alternate_calculations.tsv file deposited to dryad.

Ia. # Calculate genotype likelihoods for populations (includes all individuals for each population)

Genotype likelihoods for the Contemporary CR population

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/popgen/genotypes/contemporary_binary_gl.sh
implements:

--- start bash code ---

BAMLIST='/mnt/research/Fitz_Lab/projects/mosaic/map/population_specific_bam_lists/contemporary_cr_bams.txt'
REGFILE='/mnt/research/Fitz_Lab/ref/bird/FSJ_V3/FSJ_V3_main_autosomes.txt'
SITESFILE='/mnt/research/Fitz_Lab/projects/mosaic/variants/vcf/biallelic_snps/fsj_mosaic_biallelic_snps_main_autosomes_qc.pos'
OUTPREFIX='/mnt/research/Fitz_Lab/projects/mosaic/popgen/genotypes/contemporary_cr_biallelic_snps_main_autosomes_qc_glf3'

angsd -bam $BAMLIST -out $OUTPREFIX -GL 1 -doGlf 3 -doMaf 1 -doMajorMinor 1 -SNP_pval 1e-4 -minQ 20 -minMapQ 20 -remove_bads 1 -only_proper_pairs 1 -uniqueOnly 1 -rf $REGFILE -sites $SITESFILE -P 16

--- end bash code ---


Genotype likelihoods for the Resident CR population

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/popgen/genotypes/resident_binary_gl.sh
implements:

--- start bash code ---

BAMLIST='/mnt/research/Fitz_Lab/projects/mosaic/map/population_specific_bam_lists/resident_cr_bams.txt'
REGFILE='/mnt/research/Fitz_Lab/ref/bird/FSJ_V3/FSJ_V3_main_autosomes.txt'
SITESFILE='/mnt/research/Fitz_Lab/projects/mosaic/variants/vcf/biallelic_snps/fsj_mosaic_biallelic_snps_main_autosomes_qc.pos'
OUTPREFIX='/mnt/research/Fitz_Lab/projects/mosaic/popgen/genotypes/resident_cr_biallelic_snps_main_autosomes_qc_glf3'

angsd -bam $BAMLIST -out $OUTPREFIX -GL 1 -doGlf 3 -doMaf 1 -doMajorMinor 1 -SNP_pval 1e-4 -minQ 20 -minMapQ 20 -remove_bads 1 -only_proper_pairs 1 -uniqueOnly 1 -rf $REGFILE -sites $SITESFILE -P 16

--- end bash code ---


Genotype likelihoods for the donor population individuals

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/popgen/genotypes/donor_pop_binary_gl.sh
implements:

--- start bash code ---

BAMLIST='/mnt/research/Fitz_Lab/projects/mosaic/map/population_specific_bam_lists/donor_pop_bams.txt'
REGFILE='/mnt/research/Fitz_Lab/ref/bird/FSJ_V3/FSJ_V3_main_autosomes.txt'
SITESFILE='/mnt/research/Fitz_Lab/projects/mosaic/variants/vcf/biallelic_snps/fsj_mosaic_biallelic_snps_main_autosomes_qc.pos'
OUTPREFIX='/mnt/research/Fitz_Lab/projects/mosaic/popgen/genotypes/donor_pops_biallelic_snps_main_autosomes_qc_glf3'

angsd -bam $BAMLIST -out $OUTPREFIX -GL 1 -doGlf 3 -doMaf 1 -doMajorMinor 1 -SNP_pval 1e-4 -minQ 20 -minMapQ 20 -remove_bads 1 -only_proper_pairs 1 -uniqueOnly 1 -rf $REGFILE -sites $SITESFILE -P 16

--- end bash code ---


Genotype likelihoods for all historic (jays sampled from 2003-2008) M4 metapopulation individuals

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/popgen/genotypes/historic_metapop_binary_gl.sh
implements:

--- start bash code ---
BAMLIST='/mnt/research/Fitz_Lab/projects/mosaic/map/population_specific_bam_lists/historic_metapopulation_bams.txt'
REGFILE='/mnt/research/Fitz_Lab/ref/bird/FSJ_V3/FSJ_V3_main_autosomes.txt'
SITESFILE='/mnt/research/Fitz_Lab/projects/mosaic/variants/vcf/biallelic_snps/fsj_mosaic_biallelic_snps_main_autosomes_qc.pos'
OUTPREFIX='/mnt/research/Fitz_Lab/projects/mosaic/popgen/genotypes/historic_metapop_biallelic_snps_main_autosomes_qc_glf3'

angsd -bam $BAMLIST -out $OUTPREFIX -GL 1 -doGlf 3 -doMaf 1 -doMajorMinor 1 -SNP_pval 1e-4 -minQ 20 -minMapQ 20 -remove_bads 1 -only_proper_pairs 1 -uniqueOnly 1 -rf $REGFILE -sites $SITESFILE -P 16

--- end bash code ---

 
Genotype likelihoods for Site 13

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/popgen/genotypes/site13_binary_gl.sh
implements:

--- start bash code ---

BAMLIST='/mnt/research/Fitz_Lab/projects/mosaic/map/population_specific_bam_lists/site13_bams.txt'
REGFILE='/mnt/research/Fitz_Lab/ref/bird/FSJ_V3/FSJ_V3_main_autosomes.txt'
SITESFILE='/mnt/research/Fitz_Lab/projects/mosaic/variants/vcf/biallelic_snps/fsj_mosaic_biallelic_snps_main_autosomes_qc.pos'
OUTPREFIX='/mnt/research/Fitz_Lab/projects/mosaic/popgen/genotypes/site13_biallelic_snps_main_autosomes_qc_glf3'

angsd -bam $BAMLIST -out $OUTPREFIX -GL 1 -doGlf 3 -doMaf 1 -doMajorMinor 1 -SNP_pval 1e-4 -minQ 20 -minMapQ 20 -remove_bads 1 -only_proper_pairs 1 -uniqueOnly 1 -rf $REGFILE -sites $SITESFILE -P 16

--- end bash code ---


Ib. # Calculate inbreeding coefficients with ngsF. The F estimates from these calculations will also be used to initialize the EM calculations 
for estimates that use allele frequencies estimated from unrelated subsets (see II).


Calculate inbreeding coefficient for Contemporary CR individuals using Contemporary CR allele frequencies

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/popgen/fstats/contemporary_inbreed_coef.sh
implements:

--- start bash code ---

GENOLIKES='/mnt/research/Fitz_Lab/projects/mosaic/popgen/genotypes/contemporary_cr_biallelic_snps_main_autosomes_qc_glf3.glf'
OUTFILE='/mnt/research/Fitz_Lab/projects/mosaic/popgen/fstats/contemporary_cr_biallelic_snps_main_autosomes_qc_F.txt'

CMD="ngsF --glf $GENOLIKES --init_values e --out $OUTFILE --n_ind 28 --n_sites 1347940 --max_iters 3000 --n_threads 20"

printf "\n%s\n\n" "$CMD"

eval $CMD

--- end bash code ---


Calculate inbreeding coefficient for Resident CR individuals using Resident CR allele frequencies

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/popgen/fstats/resident_inbreed_coef.sh
implements:

--- start bash code ---

GENOLIKES='/mnt/research/Fitz_Lab/projects/mosaic/popgen/genotypes/resident_cr_biallelic_snps_main_autosomes_qc_glf3.glf'
OUTFILE='/mnt/research/Fitz_Lab/projects/mosaic/popgen/fstats/resident_cr_biallelic_snps_main_autosomes_qc_F.txt'

CMD="ngsF --glf $GENOLIKES --init_values e --out $OUTFILE --n_ind 16 --n_sites 1204026 --max_iters 3000 --n_threads 20"

printf "\n%s\n\n" "$CMD"

eval $CMD

--- end bash code ---


Calculate inbreeding coefficient for Site 13 individuals using Site 13 allele frequencies

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/popgen/fstats/site13_inbreed_coef.sh
implements:

--- start bash code ---

GENOLIKES='/mnt/research/Fitz_Lab/projects/mosaic/popgen/genotypes/site13_biallelic_snps_main_autosomes_qc_glf3.glf'
OUTFILE='/mnt/research/Fitz_Lab/projects/mosaic/popgen/fstats/site13_biallelic_snps_main_autosomes_qc_F.txt'

CMD="ngsF --glf $GENOLIKES --init_values e --out $OUTFILE --n_ind 19 --n_sites 919620 --max_iters 3000 --n_threads 20"

printf "\n%s\n\n" "$CMD"

eval $CMD

--- end bash code ---


Calculate inbreeding coefficient for donor site individuals using pooled donor site allele frequencies

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/popgen/fstats/donor_pops_inbreed_coef.sh
implements:

--- start bash code ---

GENOLIKES='/mnt/research/Fitz_Lab/projects/mosaic/popgen/genotypes/donor_pops_biallelic_snps_main_autosomes_qc_glf3.glf'
OUTFILE='/mnt/research/Fitz_Lab/projects/mosaic/popgen/fstats/donor_pops_biallelic_snps_main_autosomes_qc_F.txt'

CMD="ngsF --glf $GENOLIKES --init_values e --out $OUTFILE --n_ind 30 --n_sites 1391693 --max_iters 3000 --n_threads 20"

printf "\n%s\n\n" "$CMD"

eval $CMD

--- end bash code ---


Calculate inbreeding coefficient for historic metapopulation individuals using historic metapopulation allele frequencies

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/popgen/fstats/historic_metapop_inbreed_coef.sh
implements:

--- start bash code ---

GENOLIKES='/mnt/research/Fitz_Lab/projects/mosaic/popgen/genotypes/historic_metapop_biallelic_snps_main_autosomes_qc_glf3.glf'
OUTFILE='/mnt/research/Fitz_Lab/projects/mosaic/popgen/fstats/historic_metapop_biallelic_snps_main_autosomes_qc_F.txt'

CMD="ngsF --glf $GENOLIKES --init_values e --out $OUTFILE --n_ind 59 --n_sites 1869994 --max_iters 3000 --n_threads 20"

printf "\n%s\n\n" "$CMD"

eval $CMD

--- end bash code ---


II. The following describes estimation of individual inbreeding coefficients, F, with ngsF using population-specific allele frequencies estimated 
using subsets of individuals for which all pairwise r was <= 0.4 (relatedness pruned subsets, F is visualized in Figure 3B). These F estimates are in 
the 'F' field of the M4_sequenced_individual_metadata.tsv file deposited to dryad.

IIa. # Estimate GLs for subsets from each population where all pairwise relatedness is <= 0.4.

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/popgen/genotypes/binary_gl_maxr0.4_subset_array.sh
implements:

--- start bash code ---

GRP_ARR=('contemporary_cr' 'resident_cr' 'donor_pops' 'historic_metapop' 'site13')
FSJGRP="${GRP_ARR[$SLURM_ARRAY_TASK_ID]}"
BAMLIST="/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/inputs/${FSJGRP}_relatedness_maxr0.4_bams.txt"
OUTPREFIX="/mnt/research/Fitz_Lab/projects/mosaic/popgen/genotypes/${FSJGRP}_maxr0.4_subset_biallelic_snps_main_autosomes_qc_glf3"
REGFILE='/mnt/research/Fitz_Lab/ref/bird/FSJ_V3/FSJ_V3_main_autosomes.txt'
SITESFILE='/mnt/research/Fitz_Lab/projects/mosaic/variants/vcf/biallelic_snps/fsj_mosaic_biallelic_snps_main_autosomes_qc.pos'

CMD="angsd -bam $BAMLIST -out $OUTPREFIX -GL 1 -doGlf 3 -doMaf 1 -doMajorMinor 1 -SNP_pval 1e-4 -minQ 20 -minMapQ 20 -remove_bads 1 -only_proper_pairs 1 -uniqueOnly 1 -rf $REGFILE -sites $SITESFILE -P 16"

printf "\n%s\n\n" "$CMD"

eval $CMD

--- end bash code ---

IIb. # Estimate MAF estimates for r-pruned subsets while accounting for for inbreeding (jointy estimate MAF and F).

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/popgen/fstats/maxr_0.4_groups_ngsf_inputs.txt/maxr_0.4_groups_ngsf_calc_array.sh

which implements

--- start bash code ---

INPUT_LIST='/mnt/research/Fitz_Lab/projects/mosaic/popgen/fstats/maxr_0.4_groups_ngsf_inputs.txt'
POP=$(sed -n "${SLURM_ARRAY_TASK_ID}p" "$INPUT_LIST" | cut -f1)
GENOLIKES=$(sed -n "${SLURM_ARRAY_TASK_ID}p" "$INPUT_LIST" | cut -f2)
NIND=$(sed -n "${SLURM_ARRAY_TASK_ID}p" "$INPUT_LIST" | cut -f3)
NSITES=$(sed -n "${SLURM_ARRAY_TASK_ID}p" "$INPUT_LIST" | cut -f4)
OUTFILE="/mnt/research/Fitz_Lab/projects/mosaic/popgen/fstats/${POP}_maxr0.4_biallelic_snps_main_autosomes_qc_F.txt"

CMD="ngsF --glf $GENOLIKES --init_values e --out $OUTFILE --n_ind $NIND --n_sites $NSITES --max_iters 3000 --n_threads 20"

printf "\n%s\n\n" "$CMD"

eval $CMD

--- end bash code ---


IIc. # Replace the MAF estimates in the ngsF parameter file generated from the analysis using allele frequencies estimated using all individuals (Ib) 
from each population group with MAF estimates from the r-pruned subset (IIb). These modified parameter files provide allele frequency estimates and initital F estimates
to ngsF.

$ ./scripts/replaceMaf 16,14 1168799 resident_cr_biallelic_snps_main_autosomes_qc_F.txt.pars resident_cr_maxr0.4_biallelic_snps_main_autosomes_qc_F.txt.pars resident_cr_biallelic_snps_main_autosomes_qc_F_modified_maf.par

$ ./scripts/replaceMaf 28,28 1347940 contemporary_cr_biallelic_snps_main_autosomes_qc_F.txt.pars contemporary_cr_maxr0.4_biallelic_snps_main_autosomes_qc_F.txt.pars contemporary_cr_biallelic_snps_main_autosomes_qc_F_modified_maf.par

$ ./scripts/replaceMaf 30,16 1245900 donor_pops_biallelic_snps_main_autosomes_qc_F.txt.pars donor_pops_maxr0.4_biallelic_snps_main_autosomes_qc_F.txt.pars donor_pops_biallelic_snps_main_autosomes_qc_F_modified_maf.par

$ ./scripts/replaceMaf 59,39 1787861 historic_metapop_biallelic_snps_main_autosomes_qc_F.txt.pars historic_metapop_maxr0.4_biallelic_snps_main_autosomes_qc_F.txt.pars historic_metapop_biallelic_snps_main_autosomes_qc_F_modified_maf.par

$ ./scripts/replaceMaf 19,10 855080 site13_biallelic_snps_main_autosomes_qc_F.txt.pars site13_maxr0.4_biallelic_snps_main_autosomes_qc_F.txt.pars site13_biallelic_snps_main_autosomes_qc_F_modified_maf.par

IId. # Calculate genotype likelihoods for all individuals in a group/population at sites segregating in the subsets with max r <= 0.4.
The major and minor allele for the GL calculations was set according to the major/minor designations in the subsets of individuals with relatedness <= 0.4.
These glf files provide the genotype likelihoods to ngsF and ensures that only sites that were segregating in the respective unrelated subset are analyzed.

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/popgen/genotypes/binary_gl_set_sites_array.sh

which implements

--- start bash code ---

INPUT_LIST='/mnt/research/Fitz_Lab/projects/mosaic/popgen/genotypes/binary_gl_set_sites_input.txt'
POP=$(sed -n "${SLURM_ARRAY_TASK_ID}p" "$INPUT_LIST" | cut -f1)
BAMLIST=$(sed -n "${SLURM_ARRAY_TASK_ID}p" "$INPUT_LIST" | cut -f2)
SITESFILE=$(sed -n "${SLURM_ARRAY_TASK_ID}p" "$INPUT_LIST" | cut -f3)
REGFILE='/mnt/research/Fitz_Lab/ref/bird/FSJ_V3/FSJ_V3_main_autosomes.txt'
OUTPREFIX="/mnt/research/Fitz_Lab/projects/mosaic/popgen/genotypes/${POP}_allind_maxr0.4_qc_biallelic_snp_subset_glf3"

CMD="angsd -bam $BAMLIST -out $OUTPREFIX -GL 1 -doGlf 3 -doMajorMinor 3 -minQ 20 -minMapQ 20 -remove_bads 1 -only_proper_pairs 1 -uniqueOnly 1 -rf $REGFILE -sites $SITESFILE -P 16"

printf "\n%s\n\n" "$CMD"

eval $CMD

--- end bash code ---

IIe. Estimate F using population-specific allele frequencies estimated for subsets of unrelated individuals (these MAF estimates 
are fixed and not restimated jointly with F).

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/popgen/fstats/pop_specific_fixed_maf_ngsf_calc_array.sh
implements:

--- begin bash code ---

INPUT_LIST='/mnt/research/Fitz_Lab/projects/mosaic/popgen/fstats/pop_specific_fixed_maf_ngsf_calc_inputs.txt'
POP=$(sed -n "${SLURM_ARRAY_TASK_ID}p" "$INPUT_LIST" | cut -f1)
GENOLIKES=$(sed -n "${SLURM_ARRAY_TASK_ID}p" "$INPUT_LIST" | cut -f2)
PARFILE=$(sed -n "${SLURM_ARRAY_TASK_ID}p" "$INPUT_LIST" | cut -f3)
NIND=$(sed -n "${SLURM_ARRAY_TASK_ID}p" "$INPUT_LIST" | cut -f4)
NSITES=$(sed -n "${SLURM_ARRAY_TASK_ID}p" "$INPUT_LIST" | cut -f5)
OUTFILE="/mnt/research/Fitz_Lab/projects/mosaic/popgen/fstats/${POP}_allind_maxr0.4_biallelic_snps_main_autosomes_qc_fixedmaf_F.txt"

CMD="ngsF --glf $GENOLIKES --init_values $PARFILE --freq_fixed --out $OUTFILE --n_ind $NIND --n_sites $NSITES --max_iters 3000 --n_threads 20"

printf "\n%s\n\n" "$CMD"

eval $CMD

--- end bash code ---


IIf. Attach individual identity to the output of ngsF and collate results that use population specific allele frequencies. 
Note that {site1, site12, site18, Texaco} used allele frequencies from the pool of all donor sites and all 'other' M4 
individuals used allele frequencies of the historic metapopulation (all jays sampled from 2003-2008). Allele frequencies 
were estimated after removing first degree relationships (all genetic pairwise r were < 0.4).

--- start R code ---

# read in metadata
meta <- read.table('/mnt/research/Fitz_Lab/projects/mosaic/M4_sequenced_FSJsamples_metadata.txt',head=TRUE,sep="\t")

# read in F values
contemp_cr <- read.table('/mnt/research/Fitz_Lab/projects/mosaic/popgen/fstats/contemporary_cr_allind_maxr0.4_biallelic_snps_main_autosomes_qc_fixedmaf_F.txt', head=FALSE)
res_cr <- read.table('/mnt/research/Fitz_Lab/projects/mosaic/popgen/fstats/resident_cr_allind_maxr0.4_biallelic_snps_main_autosomes_qc_fixedmaf_F.txt', head=FALSE)
s13 <- read.table('/mnt/research/Fitz_Lab/projects/mosaic/popgen/fstats/site13_allind_maxr0.4_biallelic_snps_main_autosomes_qc_fixedmaf_F.txt', head=FALSE)
donor <- read.table('/mnt/research/Fitz_Lab/projects/mosaic/popgen/fstats/donor_pops_allind_maxr0.4_biallelic_snps_main_autosomes_qc_fixedmaf_F.txt', head=FALSE)
histmeta <- read.table('/mnt/research/Fitz_Lab/projects/mosaic/popgen/fstats/historic_metapop_allind_maxr0.4_biallelic_snps_main_autosomes_qc_fixedmaf_F.txt', head=FALSE)

# read in lists of bam files used to calculate genotype likelihood input for ngsF
contemp_bam <- read.table('/mnt/research/Fitz_Lab/projects/mosaic/map/population_specific_bam_lists/contemporary_cr_bams.txt', head=FALSE)
res_bam <- read.table('/mnt/research/Fitz_Lab/projects/mosaic/map/population_specific_bam_lists/resident_cr_bams.txt', head=FALSE)
s13_bam <- read.table('/mnt/research/Fitz_Lab/projects/mosaic/map/population_specific_bam_lists/site13_bams.txt', head=FALSE)
donor_bam <- read.table('/mnt/research/Fitz_Lab/projects/mosaic/map/population_specific_bam_lists/donor_pop_bams.txt', head=FALSE)
histmeta_bam <- read.table('/mnt/research/Fitz_Lab/projects/mosaic/map/population_specific_bam_lists/historic_metapopulation_bams.txt', head=FALSE)

# Associate IDs with F values
contemp_cr$ID <- gsub('/mnt/research/Fitz_Lab/projects/mosaic/map/bam/|.bam','',contemp_bam$V1)
res_cr$ID <- gsub('/mnt/research/Fitz_Lab/projects/mosaic/map/bam/|.bam','',res_bam$V1)
s13$ID <- gsub('/mnt/research/Fitz_Lab/projects/mosaic/map/bam/|.bam','',s13_bam$V1)
donor$ID <- gsub('/mnt/research/Fitz_Lab/projects/mosaic/map/bam/|.bam','',donor_bam$V1)
histmeta$ID <- gsub('/mnt/research/Fitz_Lab/projects/mosaic/map/bam/|.bam','',histmeta_bam$V1)

# collate values
combF <- data.frame(ID=read.table('/mnt/research/Fitz_Lab/projects/mosaic/M4_sequenced_FSJsamples_metadata.txt',head=TRUE,sep="\t")$LAB_ID)
combF$F_CONTEMPORARY_CR_AF <- unname(sapply(combF$ID,function(x,df){idx = which(df$ID == x); ifelse(length(idx) > 0, df$V1[idx], NA)}, df=contemp_cr))
combF$F_RESIDENT_CR_AF <- unname(sapply(combF$ID,function(x,df){idx = which(df$ID == x); ifelse(length(idx) > 0, df$V1[idx], NA)}, df=res_cr))
combF$F_SITE13_AF <- unname(sapply(combF$ID,function(x,df){idx = which(df$ID == x); ifelse(length(idx) > 0, df$V1[idx], NA)}, df=s13))
combF$F_DONOR_AF <- unname(sapply(combF$ID,function(x,df){idx = which(df$ID == x); ifelse(length(idx) > 0, df$V1[idx], NA)}, df=donor))
combF$F_HISTORIC_METAPOP_AF <- unname(sapply(combF$ID,function(x,df){idx = which(df$ID == x); ifelse(length(idx) > 0, df$V1[idx], NA)}, df=histmeta))

# Generate a column of F calculated using population specific allele frequencies
combF$F_POP_SPECIFIC_AF <- NA
for (i in 1:nrow(combF)) {
	id <- combF$ID[i]
	pop <- meta$pop[which(meta$LAB_ID == id)]
	if (pop == "Contemporary") {
		combF$F_POP_SPECIFIC_AF[i] <- combF$F_CONTEMPORARY_CR_AF[i]
	} else if (pop == "Resident") {
		combF$F_POP_SPECIFIC_AF[i] <- combF$F_RESIDENT_CR_AF[i]
	} else if (pop == "SITE_13") {
		combF$F_POP_SPECIFIC_AF[i] <- combF$F_SITE13_AF[i]
	} else if (pop == "SITE_1" || pop == "SITE_12" || pop == "SITE_18" || pop == "TEXACO") {
		combF$F_POP_SPECIFIC_AF[i] <- combF$F_DONOR_AF[i]
	} else if (pop == "Golden_Aster_Scrub" || pop == "Brigman" || pop == "W.Balm" || pop == "Duette_headwaters" || pop == "Sun_City") {
		combF$F_POP_SPECIFIC_AF[i] <- combF$F_HISTORIC_METAPOP_AF[i]
	} else {
		stop(paste0("Unknown population ",pop))
	}
}

# write results
# write.table(combF, file='/mnt/research/Fitz_Lab/projects/mosaic/popgen/fstats/fsj_mosaic_biallelic_snps_main_autosomes_qc_all_F_pop_specific_ref_AF_fixedMAF.txt', col.names=TRUE, row.names=FALSE, sep="\t", quote=FALSE)

--- end R code ---

The "F_POP_SPECIFIC_AF" F estimates in the fsj_mosaic_biallelic_snps_main_autosomes_qc_all_F_pop_specific_ref_AF_fixedMAF.txt file 
were stored in the metadata file M4_sequenced_FSJsamples_metadata.txt and used as the best estimates.

III. The following describes estimation of individual inbreeding coefficients, F, with ngsF using metapopulation-wide allele frequencies 
estimated without relatedness pruning (F visualized in Figure S9). These F estimates are in the 'F_META_ALL' of the inbreed_coefficient_alternate_calculations.tsv file 
deposited to dryad.

IIIa. Calculate genotype likelihoods for all samples

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/popgen/genotypes/genotype_binary_likes.sh
implements:

--- start bash code ---

BAMLIST='/mnt/research/Fitz_Lab/projects/mosaic/map/mosaic_bam_list.txt'
REGFILE='/mnt/research/Fitz_Lab/ref/bird/FSJ_V3/FSJ_V3_main_autosomes.txt'
SITESFILE='/mnt/research/Fitz_Lab/projects/mosaic/variants/vcf/biallelic_snps/fsj_mosaic_biallelic_snps_main_autosomes_qc.pos'
OUTPREFIX='/mnt/research/Fitz_Lab/projects/mosaic/popgen/genotypes/fsj_mosaic_biallelic_snps_main_autosomes_qc_all_glf3'

angsd -bam $BAMLIST -out $OUTPREFIX -GL 1 -doGlf 3 -doMajorMinor 1 -minQ 20 -minMapQ 20 -rf $REGFILE -sites $SITESFILE -P 16

--- end bash code ---

IIIb. Jointly estimate MAF and F using metapopulation-wide allele frequencies without relatedness pruning

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/popgen/fstats/inbreed_coef.sh
implements:

--- start bash code ---

GENOLIKES='/mnt/research/Fitz_Lab/projects/mosaic/popgen/genotypes/fsj_mosaic_biallelic_snps_main_autosomes_qc_all_glf3.glf'
OUTFILE='/mnt/research/Fitz_Lab/projects/mosaic/popgen/fstats/fsj_mosaic_biallelic_snps_main_autosomes_qc_all_F.txt'

CMD="ngsF --glf $GENOLIKES --init_values e --out $OUTFILE --n_ind 87 --n_sites 2049176 --max_iters 3000 --n_threads 20"

printf "\n%s\n\n" "$CMD"

eval $CMD

--- end bash code ---


IV. Statistical tests comparing distributions of F between groups

IVa. Tests with F estimated based on population-specific allele frequencies estimated using r-pruned subsets of individuals. Statistical 
tests using subsets of individuals for which all pairwise r < 0.4.

--- start R code ---

# read in F values calculated using population-specific allele frequencies. These F values are in the 'F' field of the M4_sequenced_individual_metadata.tsv file deposited to dryad.
f.popaf <- read.table('/mnt/research/Fitz_Lab/projects/mosaic/popgen/fstats/fsj_mosaic_biallelic_snps_main_autosomes_qc_all_F_pop_specific_ref_AF_fixedMAF.txt', head=TRUE)
# local version at /home/tyler/Dropbox/research/jay/mosaic/popgen/fstats/fsj_mosaic_biallelic_snps_main_autosomes_qc_all_F_pop_specific_ref_AF_fixedMAF.txt

# read in IDs for subsets of individuals

res.prune2 <- read.table('/home/tyler/Dropbox/research/jay/mosaic/popgen/relatedness/unrelated_subsets/resident_cr_noE030_relatedness_maxr0.4_ids_seed836241.txt',head=FALSE)$V1
trans.prune <- read.table('/home/tyler/Dropbox/research/jay/mosaic/popgen/relatedness/unrelated_subsets/translocated_relatedness_maxr0.4_ids_seed328974.txt',head=FALSE)$V1
contemp.prune <- read.table('/home/tyler/Dropbox/research/jay/mosaic/popgen/roh/inputs/contemporary_cr_relatedness_maxr0.4_ids.txt',head=FALSE)$V1
contemp.all <- read.table('/home/tyler/Dropbox/research/jay/mosaic/popgen/roh/inputs/contemporary_cr_ids.txt',head=FALSE)$V1 # identical to contemp.prune

## F estimated based on population-specific allele frequencies (AF) estimated with relatedness pruning

# test for whether F (pop-specific AF, no relatedness pruning) is normaly distributed using r-pruned subsets

shapiro.test(f.popaf$F_POP_SPECIFIC_AF[which(f.popaf$ID %in% contemp.all == TRUE)])
#
#       Shapiro-Wilk normality test
#
#data:  f.popaf$F_POP_SPECIFIC_AF[which(f.popaf$ID %in% contemp.all == TRUE)]
#W = 0.43, p-value = 2.332e-09

shapiro.test(f.popaf$F_POP_SPECIFIC_AF[which(f.popaf$ID %in% res.prune2 == TRUE)])
#
#       Shapiro-Wilk normality test
#
#data:  f.popaf$F_POP_SPECIFIC_AF[which(f.popaf$ID %in% res.prune2 == TRUE)]
#W = 0.41822, p-value = 2.575e-06

shapiro.test(f.popaf$F_POP_SPECIFIC_AF[which(f.popaf$ID %in% trans.prune == TRUE)])
#
#       Shapiro-Wilk normality test
#
#data:  f.popaf$F_POP_SPECIFIC_AF[which(f.popaf$ID %in% trans.prune == TRUE)]
#W = 0.85813, p-value = 0.02268

# test for differences in the distribution of F (pop-specific AF, no relatedness pruning) using r-pruned subsets

#Contemporary vs Resident CR without E_030 after removing relatedness > 0.4
wilcox.test(x=f.popaf$F_POP_SPECIFIC_AF[which(f.popaf$ID %in% contemp.prune == TRUE)], y=f.popaf$F_POP_SPECIFIC_AF[which(f.popaf$ID %in% res.prune2 == TRUE)], alternative="two.sided")
#
#       Wilcoxon rank sum exact test
#
#data:  f.popaf$F_POP_SPECIFIC_AF[which(f.popaf$ID %in% contemp.prune == TRUE)] and f.popaf$F_POP_SPECIFIC_AF[which(f.popaf$ID %in% res.prune2 == TRUE)]
#W = 313, p-value = 0.0001046
#alternative hypothesis: true location shift is not equal to 0


# Contemporary versus translocated individuals after removing relatedness > 0.4
wilcox.test(x=f.popaf$F_POP_SPECIFIC_AF[which(f.popaf$ID %in% contemp.prune == TRUE)], y=f.popaf$F_POP_SPECIFIC_AF[which(f.popaf$ID %in% trans.prune == TRUE)], alternative="two.sided")
#
#       Wilcoxon rank sum exact test
#
#data:  f.popaf$F_POP_SPECIFIC_AF[which(f.popaf$ID %in% contemp.prune == TRUE)] and f.popaf$F_POP_SPECIFIC_AF[which(f.popaf$ID %in% trans.prune == TRUE)]
#W = 355, p-value = 0.000104
#alternative hypothesis: true location shift is not equal to 0


# Resident CR without E_030 versus translocated individuals after removing relatedness > 0.4
wilcox.test(x=f.popaf$F_POP_SPECIFIC_AF[which(f.popaf$ID %in% res.prune2 == TRUE)], y=f.popaf$F_POP_SPECIFIC_AF[which(f.popaf$ID %in% trans.prune == TRUE)], alternative="two.sided")
#
#       Wilcoxon rank sum exact test
#
#data:  f.popaf$F_POP_SPECIFIC_AF[which(f.popaf$ID %in% res.prune2 == TRUE)] and f.popaf$F_POP_SPECIFIC_AF[which(f.popaf$ID %in% trans.prune == TRUE)]
#W = 111, p-value = 0.5551
#alternative hypothesis: true location shift is not equal to 0

# F (pop-specific AF, no relatedness pruning) based on r-pruned subsets

# All Contemporary CR individuals (all pairwise r < 0.4, i.e. no first degree relatives)

mean(f.popaf$F_POP_SPECIFIC_AF[which(f.popaf$ID %in% contemp.all == TRUE)])
#[1] 0.01538686
sd(f.popaf$F_POP_SPECIFIC_AF[which(f.popaf$ID %in% contemp.all == TRUE)])
#[1] 0.02530222
range(f.popaf$F_POP_SPECIFIC_AF[which(f.popaf$ID %in% contemp.all == TRUE)])
#[1] 0.004188 0.136676

# r-pruned residents without E_030
mean(f.popaf$F_POP_SPECIFIC_AF[which(f.popaf$ID %in% res.prune2 == TRUE)])
#[1] 0.009823923
sd(f.popaf$F_POP_SPECIFIC_AF[which(f.popaf$ID %in% res.prune2 == TRUE)])
#[1] 0.02285066
range(f.popaf$F_POP_SPECIFIC_AF[which(f.popaf$ID %in% res.prune2 == TRUE)])
#[1] 0.001088 0.084474

# r-pruned translocated individuals
mean(f.popaf$F_POP_SPECIFIC_AF[which(f.popaf$ID %in% trans.prune == TRUE)])
#[1] 0.003400667
sd(f.popaf$F_POP_SPECIFIC_AF[which(f.popaf$ID %in% trans.prune == TRUE)])
#[1] 0.00289038
range(f.popaf$F_POP_SPECIFIC_AF[which(f.popaf$ID %in% trans.prune == TRUE)])
#[1] 0.000604 0.009123


--- end R code ---

IVb. Tests with F estimated based on population-specific allele frequencies estimated without r-pruning. Statistical 
tests used all individuals (excluding E_030 from the residents due to admixed ancestry).

--- start R code ---

# read in F values calculated using population-specific allele frequencies. These are the values in the 'F_PS_ALL' column of the inbreed_coefficient_alternate_calculations.tsv file deposited to dryad.
f.popaf <- read.table('/mnt/research/Fitz_Lab/projects/mosaic/popgen/fstats/fsj_mosaic_biallelic_snps_main_autosomes_qc_all_F_pop_specific_ref_AF.txt', head=TRUE)

# read in sets of individuals (local copies)
contemp.prune <- read.table('/home/tyler/Dropbox/research/jay/mosaic/popgen/roh/inputs/contemporary_cr_relatedness_maxr0.4_ids.txt',head=FALSE)$V1
contemp.all <- read.table('/home/tyler/Dropbox/research/jay/mosaic/popgen/roh/inputs/contemporary_cr_ids.txt',head=FALSE)$V1
res.all <- read.table('/home/tyler/Dropbox/research/jay/mosaic/popgen/roh/inputs/resident_cr_ids.txt',head=FALSE)$V1
res.all2 <- res.all[-which(res.all == "E_030")] # remove E_030 (K-SRB) from residents because this is an F1 between a site 12 father and CR resident mother
donors.all <- read.table('/home/tyler/Dropbox/research/jay/mosaic/popgen/roh/inputs/donor_pops_ids.txt',head=FALSE)$V1
trans.all <- donors.all[-which(donors.all == "T_072")] # all translocated individuals

# test whether F is normally distributed

shapiro.test(f.popaf$F_POP_SPECIFIC_AF[which(f.popaf$ID %in% contemp.all == TRUE)])
#
#       Shapiro-Wilk normality test
#
#data:  f.popaf$F_POP_SPECIFIC_AF[which(f.popaf$ID %in% contemp.all == TRUE)]
#W = 0.52384, p-value = 2.028e-08

shapiro.test(f.popaf$F_POP_SPECIFIC_AF[which(f.popaf$ID %in% res.all2 == TRUE)])
#
#       Shapiro-Wilk normality test
#
#data:  f.popaf$F_POP_SPECIFIC_AF[which(f.popaf$ID %in% res.all2 == TRUE)]
#W = 0.4788, p-value = 2.384e-06


shapiro.test(f.popaf$F_POP_SPECIFIC_AF[which(f.popaf$ID %in% trans.all == TRUE)])
#
#       Shapiro-Wilk normality test
#
#data:  f.popaf$F_POP_SPECIFIC_AF[which(f.popaf$ID %in% trans.all == TRUE)]
#W = 0.51958, p-value = 1.256e-08

# test for differences in the distribution of F between groups

# All Contemporary vs Resident CR without E_030
wilcox.test(x=f.popaf$F_POP_SPECIFIC_AF[which(f.popaf$ID %in% contemp.all == TRUE)], y=f.popaf$F_POP_SPECIFIC_AF[which(f.popaf$ID %in% res.all2 == TRUE)], alternative="two.sided")
#
#       Wilcoxon rank sum exact test
#
#data:  f.popaf$F_POP_SPECIFIC_AF[which(f.popaf$ID %in% contemp.all == TRUE)] and f.popaf$F_POP_SPECIFIC_AF[which(f.popaf$ID %in% res.all2 == TRUE)]
#W = 312, p-value = 0.008565
#alternative hypothesis: true location shift is not equal to 0

# Contemporary versus all translocated
wilcox.test(x=f.popaf$F_POP_SPECIFIC_AF[which(f.popaf$ID %in% contemp.all == TRUE)], y=f.popaf$F_POP_SPECIFIC_AF[which(f.popaf$ID %in% trans.all == TRUE)], alternative="two.sided")
#
#       Wilcoxon rank sum exact test
#
#data:  f.popaf$F_POP_SPECIFIC_AF[which(f.popaf$ID %in% contemp.all == TRUE)] and f.popaf$F_POP_SPECIFIC_AF[which(f.popaf$ID %in% trans.all == TRUE)]
#W = 682, p-value = 3.515e-06
#alternative hypothesis: true location shift is not equal to 0

# All Resident CR without E_030 versus all translocated individuals
wilcox.test(x=f.popaf$F_POP_SPECIFIC_AF[which(f.popaf$ID %in% res.all2 == TRUE)], y=f.popaf$F_POP_SPECIFIC_AF[which(f.popaf$ID %in% trans.all == TRUE)], alternative="two.sided")
#
#       Wilcoxon rank sum exact test
#
#data:  f.popaf$F_POP_SPECIFIC_AF[which(f.popaf$ID %in% res.all2 == TRUE)] and f.popaf$F_POP_SPECIFIC_AF[which(f.popaf$ID %in% trans.all == TRUE)]
#W = 270, p-value = 0.2004
#alternative hypothesis: true location shift is not equal to 0

--- end R code ---


IVc. Tests with F estimated based on metapopulation allele frequencies estimated without r-pruning. Statistical 
tests used all individuals (excluding E_030 from the residents due to admixed ancestry).

--- start R code ---

# read in F values calculated using Mosaic-wide allele frequencies (frequencies calculated using all mosaic individuals). These are the values in the 
# 'F_META_ALL' column of the inbreed_coefficient_alternate_calculations.tsv deposited to dryad.
f.all <- read.table('/mnt/research/Fitz_Lab/projects/mosaic/popgen/fstats/fsj_mosaic_biallelic_snps_main_autosomes_qc_all_F_formatted.txt', head=TRUE)

# read in relatedness pruned subsets
res.prune2 <- read.table('/home/tyler/Dropbox/research/jay/mosaic/popgen/relatedness/unrelated_subsets/resident_cr_noE030_relatedness_maxr0.4_ids_seed836241.txt',head=FALSE)$V1
trans.prune <- read.table('/home/tyler/Dropbox/research/jay/mosaic/popgen/relatedness/unrelated_subsets/translocated_relatedness_maxr0.4_ids_seed328974.txt',head=FALSE)$V1
contemp.prune <- read.table('/home/tyler/Dropbox/research/jay/mosaic/popgen/roh/inputs/contemporary_cr_relatedness_maxr0.4_ids.txt',head=FALSE)$V1 # this is all contemporary individuals because all pairwise r <= 0.4

# test if F is normally distributed

shapiro.test(f.all$F[which(f.all$SAMPLE %in% contemp.prune == TRUE)])
#
#       Shapiro-Wilk normality test
#
#data:  f.all$F[which(f.all$SAMPLE %in% contemp.prune == TRUE)]
#W = 0.72967, p-value = 7.7e-06

shapiro.test(f.all$F[which(f.all$SAMPLE %in% res.prune2 == TRUE)])
#
#       Shapiro-Wilk normality test
#
#data:  f.all$F[which(f.all$SAMPLE %in% res.prune2 == TRUE)]
#W = 0.57613, p-value = 4.105e-05

shapiro.test(f.all$F[which(f.all$SAMPLE %in% trans.prune == TRUE)])
#
#       Shapiro-Wilk normality test
#
#data:  f.all$F[which(f.all$SAMPLE %in% trans.prune == TRUE)]
#W = 0.85767, p-value = 0.02234

# test for differences between distributions of F (with no first degree relatives, all pairwise r < 0.4)

# r-pruned contemporary CR vs resident CR without E_030
wilcox.test(x=f.all$F[which(f.all$SAMPLE %in% contemp.prune == TRUE)], y=f.all$F[which(f.all$SAMPLE %in% res.prune2 == TRUE)], alternative="two.sided") 
#
#       Wilcoxon rank sum exact test
#
#data:  f.all$F[which(f.all$SAMPLE %in% contemp.prune == TRUE)] and f.all$F[which(f.all$SAMPLE %in% res.prune2 == TRUE)]
#W = 278, p-value = 0.006292
#alternative hypothesis: true location shift is not equal to 0


# r-pruned Contemporary versus translocated individuals
wilcox.test(x=f.all$F[which(f.all$SAMPLE %in% contemp.prune == TRUE)], y=f.all$F[which(f.all$SAMPLE %in% trans.prune == TRUE)], alternative="two.sided")
#
#       Wilcoxon rank sum exact test
#
#data:  f.all$F[which(f.all$SAMPLE %in% contemp.prune == TRUE)] and f.all$F[which(f.all$SAMPLE %in% trans.prune == TRUE)]
#W = 306, p-value = 0.01371

# r-pruned Resident CR without E_030 vs translocated individuals
wilcox.test(x=f.all$F[which(f.all$SAMPLE %in% res.prune2 == TRUE)], y=f.all$F[which(f.all$SAMPLE %in% trans.prune == TRUE)], alternative="two.sided")
#
#       Wilcoxon rank sum exact test
#
#data:  f.all$F[which(f.all$SAMPLE %in% res.prune2 == TRUE)] and f.all$F[which(f.all$SAMPLE %in% trans.prune == TRUE)]
#W = 82, p-value = 0.4956
#alternative hypothesis: true location shift is not equal to 0

# F summary statistics based on subsets of individuals for which all pairwise r < 0.4

# r-pruned Contemporary CR individuals
mean(f.all$F[which(f.all$SAMPLE %in% contemp.prune == TRUE)])
#[1] 0.03405179
sd(f.all$F[which(f.all$SAMPLE %in% contemp.prune == TRUE)])
#[1] 0.03100887
range(f.all$F[which(f.all$SAMPLE %in% contemp.prune == TRUE)])
#[1] 0.006684 0.159594

# r-pruned Resident CR individuals
mean(f.all$F[which(f.all$SAMPLE %in% res.prune2 == TRUE)])
#[1] 0.02060154
sd(f.all$F[which(f.all$SAMPLE %in% res.prune2 == TRUE)])
#0.03095494
range(f.all$F[which(f.all$SAMPLE %in% res.prune2 == TRUE)])
#[1] 0.002205 0.116956

# r-pruned translocated individuals
mean(f.all$F[which(f.all$SAMPLE %in% trans.prune == TRUE)])
#[1] 0.0164594
sd(f.all$F[which(f.all$SAMPLE %in% trans.prune == TRUE)])
#[1] 0.01255179
range(f.all$F[which(f.all$SAMPLE %in% trans.prune == TRUE)])
#[1] 0.00362 0.04953

--- end R code ---


V. Boxplots comparing distributions of individuals inbreeding

Va. Boxplots for F estimated based on population-specific allele frequencies estimated using r-pruned subsets of individuals.

F boxplots in Figure 3B. These are the F values in the 'F' field of the M4_sequenced_individual_metadata.tsv file on dryad.

--- start R code ---

library(scales)

# read in data

meta <- read.table('/home/tyler/Dropbox/research/jay/mosaic/metadata/M4_sequenced_FSJsamples_metadata.txt',head=TRUE,sep="\t")

# set up plotting features

meta$biopoint = biopoint(meta$pop)
meta$popcol <- popcolor(meta)

meta$group <- replace(meta$pop, which(meta$pop == "Golden_Aster_Scrub" | meta$pop == "Brigman" | meta$pop == "W.Balm" | 
meta$pop == "Duette_headwaters" | meta$pop == "Sun_City"), "M4")

meta$group <- replace(meta$group, which(meta$group == "SITE_1" | meta$group == "SITE_12" | meta$group == "SITE_13" | 
meta$group == "SITE_18" | meta$group == "TEXACO"), "Translocated")

meta$group = factor(meta$group, levels=c("Contemporary", "Resident", "Translocated", "M4"))

# omit T_072 (RSW-K) because this site 1 bird was not translocated and migrated to LMSP, which is outside of the Core
meta.sub <- meta[-which(meta$LAB_ID == "T_072"),]

range(meta$F)
#[1] 0.000604 0.136676

#png(file='/home/tyler/Dropbox/research/jay/mosaic/figures/F_distribution_pop_specific_AF_fixedMAF_improved_labels.png',width=7, height=7,units='in', res=300)
h_boxplot3(x=meta.sub, n=21, lev=levels(meta.sub$group), ylabel=expression(Individual~inbreeding~(italic(F))), pntlab=meta.sub$biopoint, seed=1947, color=meta.sub$popcol, 
ylimits=c(0,0.145), labpos=c(0.8,1.95,3,4))
axis(2, at=c((0.0+0.05)/2, (0.05+0.1)/2, (0.1+0.15)/2), line=NA, labels=NA) # add some extra axis tick marks for clarity
#dev.off()

# make plots with IDs at points to identify particular individuals
#pdf(file='/home/tyler/Dropbox/research/jay/mosaic/figures/F_distribution_pop_specific_AF_fixedMAF_text.pdf',width=7, height=7)
h_boxplot3(x=fdf, n=7, lev=grplevels, ylabel=expression(Individual~inbreeding~(italic(F))), pntlab=NULL, seed=1947, color=meta$popcol, ylimits=c(0,0.145), idlabels=fdf$ID)
axis(2, at=c((0.0+0.05)/2, (0.05+0.1)/2, (0.1+0.15)/2), line=NA, labels=NA) # add some extra axis tick marks for clarity

# zoomed in plot to better distinguish IDs
h_boxplot3(x=fdf, n=7, lev=grplevels, ylabel=expression(Individual~inbreeding~(italic(F))), pntlab=NULL, seed=1947, color=meta$popcol, ylimits=c(0,0.05), idlabels=fdf$ID)
axis(2, at=c((0.0+0.05)/2, (0.05+0.1)/2, (0.1+0.15)/2), line=NA, labels=NA) # add some extra axis tick marks for clarity

# zoomed in more
h_boxplot3(x=fdf, n=7, lev=grplevels, ylabel=expression(Individual~inbreeding~(italic(F))), pntlab=NULL, seed=1947, color=meta$popcol, ylimits=c(0,0.008), idlabels=fdf$ID)
axis(2, at=c((0.0+0.05)/2, (0.05+0.1)/2, (0.1+0.15)/2), line=NA, labels=NA) # add some extra axis tick marks for clarity

# zoom even more
h_boxplot3(x=fdf, n=7, lev=grplevels, ylabel=expression(Individual~inbreeding~(italic(F))), pntlab=NULL, seed=1947, color=meta$popcol, ylimits=c(0,0.007), idlabels=fdf$ID)
axis(2, at=c((0.0+0.05)/2, (0.05+0.1)/2, (0.1+0.15)/2), line=NA, labels=NA) # add some extra axis tick marks for clarity

# highest res zoom
h_boxplot3(x=fdf, n=7, lev=grplevels, ylabel=expression(Individual~inbreeding~(italic(F))), pntlab=NULL, seed=1947, color=meta$popcol, ylimits=c(0,0.003), idlabels=fdf$ID)
axis(2, at=c((0.0+0.05)/2, (0.05+0.1)/2, (0.1+0.15)/2), line=NA, labels=NA) # add some extra axis tick marks for clarity

# make a plot to find where the top 5 pedigree-based contributors circled in figure 3A are in the boxplot

meta$maskcol = meta$popcol
meta$maskcol[-which(meta$LAB_ID == "T_071" | meta$LAB_ID == "T_099" | meta$LAB_ID == "T_081" | meta$LAB_ID == "T_086" | meta$LAB_ID == "T_067")] <- alpha("grey90",0)
meta$maskcol[which(meta$LAB_ID == "T_071")] <- alpha(meta$popcol[which(meta$LAB_ID == "T_071")],0.65)
meta$maskcol[which(meta$LAB_ID == "T_099")] <- alpha(meta$popcol[which(meta$LAB_ID == "T_099")],0.65)
meta$maskcol[which(meta$LAB_ID == "T_081")] <- alpha(meta$popcol[which(meta$LAB_ID == "T_081")],0.65)
meta$maskcol[which(meta$LAB_ID == "T_086")] <- alpha(meta$popcol[which(meta$LAB_ID == "T_086")],0.65)
meta$maskcol[which(meta$LAB_ID == "T_067")] <- alpha(meta$popcol[which(meta$LAB_ID == "T_067")],0.65)

#pdf(file='/home/tyler/Dropbox/research/jay/mosaic/figures/F_distribution_pop_specific_AF_fixedMAF_top5ped_contributors_highlight.pdf',width=7, height=7)
h_boxplot_mask(x=fdf, n=7, lev=grplevels, ylabel=expression(Individual~inbreeding~(italic(F))), pntlab=fdf$biopoint, seed=1947, color=meta$maskcol, ylim=c(0,0.145))
#dev.off()

--- end R code ---


Vb. Boxplots for F estimated based on population-specific allele frequencies estimated without r-pruning.

F boxplots in Figure S9 (left panel). These are the F values in the 'F_PS_ALL' field of the inbreed_coefficient_alternate_calculations.tsv file on dryad.

--- start R code ---

library(scales)

meta <- read.table('/home/tyler/Dropbox/research/jay/mosaic/metadata/M4_sequenced_FSJsamples_metadata.txt',head=TRUE,sep="\t")
fdf <- read.table('/home/tyler/Dropbox/research/jay/mosaic/popgen/fstats/fsj_mosaic_biallelic_snps_main_autosomes_qc_all_F_pop_specific_ref_AF.txt', head=TRUE)
fdf <- fdf[match(meta$LAB_ID, fdf$ID),] # ensure that the order of individuals matches the metadata

meta$popletter <- popletters(meta) # popletters function defined in /home/tyler/Dropbox/research/jay/mosaic/popgen/fstats/README_MOSAIC_ANALYSIS
meta$popcol <- popcolor(meta) # popcolor function defined in /home/tyler/Dropbox/research/jay/mosaic/popgen/fstats/README_MOSAIC_ANALYSIS
meta$colors <- sitecol(meta) # sitecol function defined in /home/tyler/Dropbox/research/jay/mosaic/popgen/fstats/README_MOSAIC_ANALYSIS

# define groups
groups <- meta$pop
grplevels <- c("Contemporary", "Resident", "Translocated", "M4")

groups <- replace(groups, which(groups == "Golden_Aster_Scrub" | groups == "Brigman" | groups == "W.Balm" | 
groups == "Duette_headwaters" | groups == "Sun_City"), "M4")

groups <- replace(groups, which(groups == "SITE_1" | groups == "SITE_12" | groups == "SITE_13" | 
groups == "SITE_18" | groups == "TEXACO"), "Translocated")

fdf$group = factor(groups,levels=grplevels)

# omit T_072 (RSW-K) because this site 1 bird was not translocated and migrated to LMSP, which is outside of the Core
fdf <- fdf[-which(fdf$ID == "T_072"),]
meta <- meta[-which(meta$LAB_ID == "T_072"),]

# set point type
fdf$biopoint = biopoint(meta$pop)

max(fdf$F_POP_SPECIFIC_AF)
# [1] 0.137558 # set upper y-limit above this value

# plot

#png(file='/home/tyler/Dropbox/research/jay/mosaic/figures/F_distribution_pop_specific_AF.png',width=7, height=7,units='in', res=300) # this is Figure S9 - left panel
h_boxplot3(x=fdf, n=7, lev=grplevels, ylabel=expression(Individual~inbreeding~(italic(F))), pntlab=fdf$biopoint, seed=1947, color=meta$popcol, ylim=c(0,0.145))
axis(2, at=c((0.0+0.05)/2, (0.05+0.1)/2, (0.1+0.15)/2), line=NA, labels=NA) # add some extra axis tick marks for clarity
#dev.off()

# make plot with IDs at points
#pdf(file='/home/tyler/Dropbox/research/jay/mosaic/figures/F_distribution_pop_specific_AF_text.pdf',width=7, height=7)
h_boxplot3(x=fdf, n=7, lev=grplevels, ylabel=expression(Individual~inbreeding~(italic(F))), pntlab=NULL, seed=1947, color=meta$popcol, ylimits=c(0,0.145), idlabels=fdf$ID)
axis(2, at=c((0.0+0.05)/2, (0.05+0.1)/2, (0.1+0.15)/2), line=NA, labels=NA) # add some extra axis tick marks for clarity

# zoomed in plot to better distinguish IDs
h_boxplot3(x=fdf, n=7, lev=grplevels, ylabel=expression(Individual~inbreeding~(italic(F))), pntlab=NULL, seed=1947, color=meta$popcol, ylimits=c(0,0.05), idlabels=fdf$ID)
axis(2, at=c((0.0+0.05)/2, (0.05+0.1)/2, (0.1+0.15)/2), line=NA, labels=NA) # add some extra axis tick marks for clarity

# zoomed in more
h_boxplot3(x=fdf, n=7, lev=grplevels, ylabel=expression(Individual~inbreeding~(italic(F))), pntlab=NULL, seed=1947, color=meta$popcol, ylimits=c(0,0.008), idlabels=fdf$ID)
axis(2, at=c((0.0+0.05)/2, (0.05+0.1)/2, (0.1+0.15)/2), line=NA, labels=NA) # add some extra axis tick marks for clarity

# zoom even more
h_boxplot3(x=fdf, n=7, lev=grplevels, ylabel=expression(Individual~inbreeding~(italic(F))), pntlab=NULL, seed=1947, color=meta$popcol, ylimits=c(0,0.003), idlabels=fdf$ID)
axis(2, at=c((0.0+0.05)/2, (0.05+0.1)/2, (0.1+0.15)/2), line=NA, labels=NA) # add some extra axis tick marks for clarity

# make a plot to find where the top 5 pedigree-based contributors circled in figure 3A are in the boxplot

meta$maskcol = meta$popcol
meta$maskcol[-which(meta$LAB_ID == "T_071" | meta$LAB_ID == "T_099" | meta$LAB_ID == "T_081" | meta$LAB_ID == "T_086" | meta$LAB_ID == "T_067")] <- alpha("grey90",0)
meta$maskcol[which(meta$LAB_ID == "T_071")] <- alpha(meta$popcol[which(meta$LAB_ID == "T_071")],0.65)
meta$maskcol[which(meta$LAB_ID == "T_099")] <- alpha(meta$popcol[which(meta$LAB_ID == "T_099")],0.65)
meta$maskcol[which(meta$LAB_ID == "T_081")] <- alpha(meta$popcol[which(meta$LAB_ID == "T_081")],0.65)
meta$maskcol[which(meta$LAB_ID == "T_086")] <- alpha(meta$popcol[which(meta$LAB_ID == "T_086")],0.65)
meta$maskcol[which(meta$LAB_ID == "T_067")] <- alpha(meta$popcol[which(meta$LAB_ID == "T_067")],0.65)

h_boxplot_mask(x=fdf, n=7, lev=grplevels, ylabel=expression(Individual~inbreeding~(italic(F))), pntlab=fdf$biopoint, seed=1947, color=meta$maskcol, ylim=c(0,0.145))

--- end R code ---


Vc. Boxplots for F estimated based on metapopulation allele frequencies estimated without r-pruning.

F boxplots in Figure S9 (right panel). These are the F values in the 'F_META_ALL' field of the inbreed_coefficient_alternate_calculations.tsv file on dryad.

--- start R code ---

library(scales) # for alpha

# read in metapop data
meta <- read.table('/home/tyler/Dropbox/research/jay/mosaic/metadata/M4_sequenced_FSJsamples_metadata.txt',head=TRUE,sep="\t")
meta$popletter <- popletters(meta)
meta$popcol <- popcolor(meta)

# define groups
groups <- meta$pop
grplevels <- c("Contemporary", "Resident", "Translocated", "M4")

groups <- replace(groups, which(groups == "Golden_Aster_Scrub" | groups == "Brigman" | groups == "W.Balm" | 
groups == "Duette_headwaters" | groups == "Sun_City"), "M4")

groups <- replace(groups, which(groups == "SITE_1" | groups == "SITE_12" | groups == "SITE_13" | 
groups == "SITE_18" | groups == "TEXACO"), "Translocated")

# read in F (inbreeding coefficient)
fcoef <- read.table('/home/tyler/Dropbox/research/jay/mosaic/popgen/fstats/fsj_mosaic_biallelic_snps_main_autosomes_qc_all_F.txt',head=FALSE) # F estimated using metapopulation allele frequencies
fcoef$group = factor(groups,levels=grplevels)
fcoef$SAMPLE = meta$LAB_ID

# omit T_072 (RSW-K) because this site 1 bird was not translocated and migrated to LMSP, which is outside of the Core
fcoef <- fcoef[-which(fcoef$SAMPLE == "T_072"),]
meta <- meta[-which(meta$LAB_ID == "T_072"),]

# set point type
fcoef$biopoint = biopoint(meta$pop)

range(fcoef$V1)
#[1] 0.001959 0.159594

# plot

#png(file='/home/tyler/Dropbox/research/jay/mosaic/figures/F_distribution.png',width=7, height=7,units='in', res=300)
h_boxplot3(x=fcoef, n=1, lev=grplevels, ylabel=expression(Individual~inbreeding~(italic(F))), pntlab=fcoef$biopoint, seed=1947, color=meta$popcol, ylimits=c(0,0.17))
axis(2, at=c((0.0+0.05)/2, (0.05+0.1)/2, (0.1+0.15)/2), line=NA, labels=NA) # add some extra axis tick marks for clarity
#dev.off()

# make version with text IDs to identify particular individuals

#png(file='/home/tyler/Dropbox/research/jay/mosaic/figures/F_distribution_text.png',width=7, height=7,units='in', res=300)
h_boxplot3(x=fcoef, n=1, lev=grplevels, ylabel="Inbreeding coefficient (F)", pntlab=NULL, seed=1947, color=meta$popcol, ylimits=c(0,0.17), idlabels=fcoef$SAMPLE)
#dev.off()

--- end R code ---


#
#
#


## ---------- RUNS OF HOMOZYGOSITY (ROH) ---------- ##

Identify runs of homozygosity with bcftools roh HMM.

## Define reference populations and calculate allele frequencies

Reference population allele frequencies estimated for groups with >= 10 individuals after pruning potential 
first degree relatives (ensure all pairwise r < 0.4).


--- start R code ---

rmat <- as.matrix(read.table('/mnt/research/Fitz_Lab/projects/mosaic/popgen/relatedness/fsj_mosaic_biallelic_snps_main_autosomes_qc_relatedness_matrix.txt',head=TRUE,row.names=1))
colnames(rmat) <- gsub('\\..+$', '', colnames(rmat), perl=TRUE) # remove location info
meta <- read.table('/mnt/research/Fitz_Lab/projects/mosaic/M4_sequenced_FSJsamples_metadata.txt',head=TRUE,sep="\t")

# collect IDs of individuals in each group
c.id <- meta$LAB_ID[which(meta$pop == "Contemporary")]
r.id <- meta$LAB_ID[which(meta$pop == "Resident")]
s13.id <- meta$LAB_ID[which(meta$pop == "SITE_13")]
histmeta.id <- meta$LAB_ID[which(meta$year_sampled < 2021)]

# note: exclude RSW-K from CR founders in case I use them as a reference pop for the Contemporary CR individuals at some point
crfounders.id <- meta$LAB_ID[which((meta$pop == "Resident" | meta$pop == "SITE_1" | meta$pop == "SITE_12" | meta$pop == "SITE_13" | meta$pop == "SITE_18" | meta$pop == "TEXACO") & meta$LAB_ID != "T_072")]

# note: include RSW-K for the donor site group because they are relevant for estimating the allele frequencies in this metapopulation subset
donor.id <- meta$LAB_ID[which(meta$pop == "SITE_1" | meta$pop == "SITE_12" | meta$pop == "SITE_13" | meta$pop == "SITE_18" | meta$pop == "TEXACO")]

# extract relatedness matrix subsets
c.rmat <- rmat[which(colnames(rmat) %in% c.id == TRUE), which(colnames(rmat) %in% c.id == TRUE)]
r.rmat <- rmat[which(colnames(rmat) %in% r.id == TRUE), which(colnames(rmat) %in% r.id == TRUE)]
s13.rmat <- rmat[which(colnames(rmat) %in% s13.id == TRUE), which(colnames(rmat) %in% s13.id == TRUE)]
histmeta.rmat <- rmat[which(colnames(rmat) %in% histmeta.id == TRUE), which(colnames(rmat) %in% histmeta.id == TRUE)]
crfounders.rmat <- rmat[which(colnames(rmat) %in% crfounders.id == TRUE), which(colnames(rmat) %in% crfounders.id == TRUE)]
donor.rmat <- rmat[which(colnames(rmat) %in% donor.id == TRUE), which(colnames(rmat) %in% donor.id == TRUE)]

# output relatedness submatrices
#write.table(c.rmat, file='/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/contemporary_cr_relatedness_matrix.txt', col.names=TRUE, row.names=FALSE, quote=FALSE, sep="\t")
#write.table(r.rmat, file='/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/resident_cr_relatedness_matrix.txt', col.names=TRUE, row.names=FALSE, quote=FALSE, sep="\t")
#write.table(s13.rmat, file='/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/site13_relatedness_matrix.txt', col.names=TRUE, row.names=FALSE, quote=FALSE, sep="\t")
#write.table(histmeta.rmat, file='/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/historic_metapop_relatedness_matrix.txt', col.names=TRUE, row.names=FALSE, quote=FALSE, sep="\t")
#write.table(crfounders.rmat, file='/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/cr_founders_relatedness_matrix.txt', col.names=TRUE, row.names=FALSE, quote=FALSE, sep="\t")
#write.table(donor.rmat, file='/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/donor_pops_relatedness_matrix.txt', col.names=TRUE, row.names=FALSE, quote=FALSE, sep="\t")

# output the original relatedness matrix of all samples, entirely unchanged except for removing the row names and simplifying the IDs (remove population labels)
#write.table(rmat, file='/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/fsj_mosaic_biallelic_snps_main_autosomes_qc_relatedness_matrix_fmt.txt', col.names=TRUE, row.names=FALSE, quote=FALSE, sep="\t")

--- end R code ---

Randomly prune out individuals involved in relationships having pairwise relatedness > 0.4 (removes first degree relatives).

$ /mnt/research/Fitz_Lab/projects/mosaic/popgen/relatedness/scripts/subsetUnrelated.R contemporary_cr_relatedness_matrix.txt 0.4 836241 > contemporary_cr_relatedness_maxr0.4_ids.txt
$ /mnt/research/Fitz_Lab/projects/mosaic/popgen/relatedness/scripts/subsetUnrelated.R resident_cr_relatedness_matrix.txt 0.4 836241 > resident_cr_relatedness_maxr0.4_ids.txt
$ /mnt/research/Fitz_Lab/projects/mosaic/popgen/relatedness/scripts/subsetUnrelated.R site13_relatedness_matrix.txt 0.4 836241 > site13_relatedness_maxr0.4_ids.txt
$ /mnt/research/Fitz_Lab/projects/mosaic/popgen/relatedness/scripts/subsetUnrelated.R historic_metapop_relatedness_matrix.txt 0.4 836241 > historic_metapop_relatedness_maxr0.4_ids.txt
$ /mnt/research/Fitz_Lab/projects/mosaic/popgen/relatedness/scripts/subsetUnrelated.R cr_founders_relatedness_matrix.txt 0.4 836241 > cr_founders_relatedness_maxr0.4_ids.txt
$ /mnt/research/Fitz_Lab/projects/mosaic/popgen/relatedness/scripts/subsetUnrelated.R donor_pops_relatedness_matrix.txt 0.4 836241 > donor_pops_relatedness_maxr0.4_ids.txt
$ /mnt/research/Fitz_Lab/projects/mosaic/popgen/relatedness/scripts/subsetUnrelated.R fsj_mosaic_biallelic_snps_main_autosomes_qc_relatedness_matrix_fmt.txt 0.4 836241 > fsj_mosaic_biallelic_snps_main_autosomes_qc_relatedness_maxr0.4_ids.txt

The ID lists above were used to construct BAM lists containing the corresponding individuals, which was used as input to estimate allele frequencies for different groups.

Identify sites segregating within subsetted reference groups.

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/scripts/mosaic_groups_segregating_sites_array.sh
implements:

--- start bash code ---

VCF='/mnt/research/Fitz_Lab/projects/mosaic/variants/vcf/biallelic_snps/fsj_mosaic_biallelic_snps_main_autosomes_qc.vcf.gz'
POPLIST='/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/scripts/mosaic_reference_pop_maxr0.4_list.txt'
POP=$(sed -n "${SLURM_ARRAY_TASK_ID}p" "$POPLIST" | cut -f1)
SAMPLES=$(sed -n "${SLURM_ARRAY_TASK_ID}p" "$POPLIST" | cut -f2)
OUTFILE="/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/inputs/${POP}_biallelic_snps_main_autosomes_qc.pos"

CMD="bcftools view -O u -a -S $SAMPLES -c 1:minor -m2 -M2 $VCF | bcftools query -f '%CHROM\t%POS\t%REF\t%ALT\n' > $OUTFILE"

printf "\n%s\n\n" "$CMD"

eval $CMD

wait

CMD2="angsd sites index $OUTFILE"

printf "\n%s\n\n" "$CMD2"

eval $CMD2

--- end bash code ---

Calculate alternate allele (in this case same as the Mosaic-wide minor allele) frequency.

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/scripts/mosaic_reference_pop_allele_freq_array.sh
implements:

--- start bash code ---

INPUT_LIST='/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/scripts/mosaic_reference_pop_maxr0.4_af_estimate_inputs.txt'
POP=$(sed -n "${SLURM_ARRAY_TASK_ID}p" "$INPUT_LIST" | cut -f1)
BAMS=$(sed -n "${SLURM_ARRAY_TASK_ID}p" "$INPUT_LIST" | cut -f2)
SITESFILE=$(sed -n "${SLURM_ARRAY_TASK_ID}p" "$INPUT_LIST" | cut -f3)
OUTPREFIX="/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/inputs/${POP}_maxr0.4_biallelic_snps_main_autosomes_qc"

CMD="angsd -bam $BAMS -out $OUTPREFIX -GL 1 -doMaf 1 -doMajorMinor 3 -sites $SITESFILE -minQ 20 -minMapQ 20 -remove_bads 1 -only_proper_pairs 1 -uniqueOnly 1 -P 8"

printf "\n%s\n\n" "$CMD"

eval $CMD

--- end bash code ---

Format allele frequencies for bcftools roh.

$ zcat contemporary_cr_maxr0.4_biallelic_snps_main_autosomes_qc.mafs.gz | tail -n+2 | perl -ne 'chomp; @tok=split(/\t/,$_); print "$tok[0]\t$tok[1]\t$tok[2],$tok[3]\t$tok[4]\n";' | bgzip -c > contemporary_cr_maxr0.4_biallelic_snps_main_autosomes_qc.af.gz
$ tabix -s1 -b2 -e2 contemporary_cr_maxr0.4_biallelic_snps_main_autosomes_qc.af.gz

$ zcat resident_cr_maxr0.4_biallelic_snps_main_autosomes_qc.mafs.gz | tail -n+2 | perl -ne 'chomp; @tok=split(/\t/,$_); print "$tok[0]\t$tok[1]\t$tok[2],$tok[3]\t$tok[4]\n";' | bgzip -c > resident_cr_maxr0.4_biallelic_snps_main_autosomes_qc.af.gz
$ tabix -s1 -b2 -e2 resident_cr_maxr0.4_biallelic_snps_main_autosomes_qc.af.gz

$ zcat cr_founders_maxr0.4_biallelic_snps_main_autosomes_qc.mafs.gz | tail -n+2 | perl -ne 'chomp; @tok=split(/\t/,$_); print "$tok[0]\t$tok[1]\t$tok[2],$tok[3]\t$tok[4]\n";' | bgzip -c > cr_founders_maxr0.4_biallelic_snps_main_autosomes_qc.af.gz
$ tabix -s1 -b2 -e2 cr_founders_maxr0.4_biallelic_snps_main_autosomes_qc.af.gz

$ zcat donor_pops_maxr0.4_biallelic_snps_main_autosomes_qc.mafs.gz | tail -n+2 | perl -ne 'chomp; @tok=split(/\t/,$_); print "$tok[0]\t$tok[1]\t$tok[2],$tok[3]\t$tok[4]\n";' | bgzip -c > donor_pops_maxr0.4_biallelic_snps_main_autosomes_qc.af.gz
$ tabix -s1 -b2 -e2 donor_pops_maxr0.4_biallelic_snps_main_autosomes_qc.af.gz

$ zcat site13_maxr0.4_biallelic_snps_main_autosomes_qc.mafs.gz | tail -n+2 | perl -ne 'chomp; @tok=split(/\t/,$_); print "$tok[0]\t$tok[1]\t$tok[2],$tok[3]\t$tok[4]\n";' | bgzip -c > site13_maxr0.4_biallelic_snps_main_autosomes_qc.af.gz
$ tabix -s1 -b2 -e2 site13_maxr0.4_biallelic_snps_main_autosomes_qc.af.gz

$ zcat historic_metapop_maxr0.4_biallelic_snps_main_autosomes_qc.mafs.gz | tail -n+2 | perl -ne 'chomp; @tok=split(/\t/,$_); print "$tok[0]\t$tok[1]\t$tok[2],$tok[3]\t$tok[4]\n";' | bgzip -c > historic_metapop_maxr0.4_biallelic_snps_main_autosomes_qc.af.gz
$ tabix -s1 -b2 -e2 historic_metapop_maxr0.4_biallelic_snps_main_autosomes_qc.af.gz

$ zcat mosaic_all_maxr0.4_biallelic_snps_main_autosomes_qc.mafs.gz | tail -n+2 | perl -ne 'chomp; @tok=split(/\t/,$_); print "$tok[0]\t$tok[1]\t$tok[2],$tok[3]\t$tok[4]\n";' | bgzip -c > mosaic_all_maxr0.4_biallelic_snps_main_autosomes_qc.af.gz
$ tabix -s1 -b2 -e2 mosaic_all_maxr0.4_biallelic_snps_main_autosomes_qc.af.gz

Note that allele frequencies in mosaic_all_maxr0.4_biallelic_snps_main_autosomes_qc.mafs.gz are estimated from the individuals in fsj_mosaic_biallelic_snps_main_autosomes_qc_relatedness_maxr0.4_ids.txt.

## Identify ROH

Use a constant recombination rate that reflects the average across different bird species.

# recombination rate estimates for birds:
# Backstrom etal 2010: mean 1.5 cM/Mb in zebra finch exluding 10 microchromsomes and projected to be ~2 cM/Mb with the microchromosomes
# Singhal etal 2015: median 0.14 cM/Mb in both Taeniopygia guttata (zebra finch) and Poephila acuticuada (long-tailed finch)
# Bascon-Cardozo etal 2024: mean 5.8 cM/Mb in Eurasian blackcap
# Smeds etal 2016: mean 3.08 cM/Mb in collared flycatcher
# Ellegren 2005: median 2.8 cM/Mb for macrochromosomes in chicken
# Hagen etal 2020: mean 1.78 cM/Mb for macrochromosomes and 6.41 cM/Mb for microchromosomes, genome average = 4.095 cM/Mb, in house sparrows
# Groenen etal 2000: mean 6.02 cM/Mb in chicken
# Groenen etal 2009: mean 3.11 cM/Mb in chicken
# Stapley etal 2008: mean 3.18 cM/Mb in zebra finch
# Kawakami etal 2014: mean 3.1 cM/Mb in collared flycatcher

# Used in average estimate
# Backstrom etal 2010: 2 cM/Mb in zebrafinch
# Bascon-Cardozo etal 2024: 5.8 cM/Mb in Eurasian blackcap
# Smeds etal 2016: 3.08 cM/Mb in collared flycatcher
# Hagen etal 2020: 4.095 in house sparrows
# Groenen etal 2009: 3.11 cM/Mb in chicken

# Will use average of the mean recombination rates for the different species above:
# mean(c(2, 5.8, 3.08, 4.095, 3.11)) == 3.617 cM/Mb == 3.6e-8 crossovers/bp (expected)

Determine whether each SNP is in an autozygous or nonautozygous tract for individuals.

ROH for the Contemporary CR population using Contemporary CR population specific allele frequencies (estimated after pruning relatedness > 0.4) as reference.

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/scripts/contemporary_cr_roh_array.sh
implements:

--- start bash code ---

VCF='/mnt/research/Fitz_Lab/projects/mosaic/variants/vcf/biallelic_snps/fsj_mosaic_biallelic_snps_main_autosomes_qc.vcf.gz'
SAMPLE_LIST='/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/inputs/contemporary_cr_ids.txt'
SAMP=$(sed -n "${SLURM_ARRAY_TASK_ID}p" "$SAMPLE_LIST")
AF_FILE='/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/inputs/contemporary_cr_maxr0.4_biallelic_snps_main_autosomes_qc.af.gz'
OUTFILE="/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/estimates/${SAMP}_contemporary_cr_af_roh.txt"

CMD="bcftools roh --samples $SAMP --AF-file $AF_FILE --rec-rate 3.6e-8 --output $OUTFILE --output-type sr --skip-indels --viterbi-training 1e-10 --threads 12 $VCF"

printf "\n%s\n\n" "$CMD"

eval $CMD

--- end bash code ---


ROH for the Resident CR population using Resident CR population specific alelle frequencies (estimated after pruning relatedness > 0.4) as reference.

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/scripts/resident_cr_roh_array.sh
implements:

--- start bash code ---

VCF='/mnt/research/Fitz_Lab/projects/mosaic/variants/vcf/biallelic_snps/fsj_mosaic_biallelic_snps_main_autosomes_qc.vcf.gz'
SAMPLE_LIST='/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/inputs/resident_cr_ids.txt'
SAMP=$(sed -n "${SLURM_ARRAY_TASK_ID}p" "$SAMPLE_LIST")
AF_FILE='/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/inputs/resident_cr_maxr0.4_biallelic_snps_main_autosomes_qc.af.gz'
OUTFILE="/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/estimates/${SAMP}_resident_cr_af_roh.txt"

CMD="bcftools roh --samples $SAMP --AF-file $AF_FILE --rec-rate 3.6e-8 --output $OUTFILE --output-type sr --skip-indels --viterbi-training 1e-10 --threads 12 $VCF"

printf "\n%s\n\n" "$CMD"

eval $CMD

--- end bash code ---


ROH for all Site 13 individuals using allele frequencies estimated from Site 13 individuals (estimated after pruning relatedness < 0.4) as reference.

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/scripts/site13_roh_array.sh
implements:

--- start bash code ---

VCF='/mnt/research/Fitz_Lab/projects/mosaic/variants/vcf/biallelic_snps/fsj_mosaic_biallelic_snps_main_autosomes_qc.vcf.gz'
SAMPLE_LIST='/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/inputs/site13_ids.txt'
SAMP=$(sed -n "${SLURM_ARRAY_TASK_ID}p" "$SAMPLE_LIST")
AF_FILE='/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/inputs/site13_maxr0.4_biallelic_snps_main_autosomes_qc.af.gz'
OUTFILE="/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/estimates/${SAMP}_site13_af_roh.txt"

CMD="bcftools roh --samples $SAMP --AF-file $AF_FILE --rec-rate 3.6e-8 --output $OUTFILE --output-type sr --skip-indels --viterbi-training 1e-10 --threads 12 $VCF"

printf "\n%s\n\n" "$CMD"

eval $CMD

--- end bash code ---


ROH for all donor site individuals (includes translocated individuals) using donor population allele frequencies (estimated after pruning relatedness > 0.4) as reference

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/scripts/donor_pop_roh_array.sh
implements:

--- start bash code ---

VCF='/mnt/research/Fitz_Lab/projects/mosaic/variants/vcf/biallelic_snps/fsj_mosaic_biallelic_snps_main_autosomes_qc.vcf.gz'
SAMPLE_LIST='/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/inputs/donor_pops_ids.txt'
SAMP=$(sed -n "${SLURM_ARRAY_TASK_ID}p" "$SAMPLE_LIST")
AF_FILE='/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/inputs/donor_pops_maxr0.4_biallelic_snps_main_autosomes_qc.af.gz'
OUTFILE="/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/estimates/${SAMP}_donor_pops_af_roh.txt"

CMD="bcftools roh --samples $SAMP --AF-file $AF_FILE --rec-rate 3.6e-8 --output $OUTFILE --output-type sr --skip-indels --viterbi-training 1e-10 --threads 12 $VCF"

printf "\n%s\n\n" "$CMD"

eval $CMD

--- end bash code ---


ROH for all historic individuals (jays sampled from 2003-2008) throughout the M4 metapopulation using historic metapopulation allele frequencies (estimated after pruning relatedness > 0.4) as reference.

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/scripts/historic_metapop_roh_array.sh
implements:

--- start bash code ---

VCF='/mnt/research/Fitz_Lab/projects/mosaic/variants/vcf/biallelic_snps/fsj_mosaic_biallelic_snps_main_autosomes_qc.vcf.gz'
SAMPLE_LIST='/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/inputs/historic_metapop_ids.txt'
SAMP=$(sed -n "${SLURM_ARRAY_TASK_ID}p" "$SAMPLE_LIST")
AF_FILE='/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/inputs/historic_metapop_maxr0.4_biallelic_snps_main_autosomes_qc.af.gz'
OUTFILE="/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/estimates/${SAMP}_historic_metapop_af_roh.txt"

CMD="bcftools roh --samples $SAMP --AF-file $AF_FILE --rec-rate 3.6e-8 --output $OUTFILE --output-type sr --skip-indels --viterbi-training 1e-10 --threads 12 $VCF"

printf "\n%s\n\n" "$CMD"

eval $CMD

--- end bash code ---


ROH for all Mosaic individuals using allele frequencies estimated from all Mosaic individuals (after pruning relatedness < 0.4) as reference.

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/scripts/mosaic_all_roh_array.sh
implements:

--- start bash code ---

VCF='/mnt/research/Fitz_Lab/projects/mosaic/variants/vcf/biallelic_snps/fsj_mosaic_biallelic_snps_main_autosomes_qc.vcf.gz'
SAMPLE_LIST='/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/inputs/mosaic_all_ids.txt'
SAMP=$(sed -n "${SLURM_ARRAY_TASK_ID}p" "$SAMPLE_LIST")
AF_FILE='/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/inputs/mosaic_all_maxr0.4_biallelic_snps_main_autosomes_qc.af.gz'
OUTFILE="/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/estimates/${SAMP}_mosaic_all_af_roh.txt"

CMD="bcftools roh --samples $SAMP --AF-file $AF_FILE --rec-rate 3.6e-8 --output $OUTFILE --output-type sr --skip-indels --viterbi-training 1e-10 --threads 12 $VCF"

printf "\n%s\n\n" "$CMD"

eval $CMD

--- end bash code ---

Identify ROH regions and calculate FROH from bcftools roh HMM output.

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/scripts/mosaic_roh_regions_array.sh
implements:

--- start bash code ---

HMM_FILE_LIST='/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/scripts/mosaic_individual_roh_hmm_list.txt'
HMMF=$(sed -n "${SLURM_ARRAY_TASK_ID}p" "$HMM_FILE_LIST")
REGION_OUT=$(echo "$HMMF" | sed 's/\.txt$/\.regions/')
FROH_OUT=$(echo "$HMMF" | sed 's/\.txt$/\.froh/')
EXEC='/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/scripts/rohRegions.pl'

CMD="$EXEC 20 $HMMF $REGION_OUT > $FROH_OUT"

printf "\n%s\n\n" "$CMD"

eval $CMD

--- end bash code ---

## Collate FROH estimates

Collect FROH estimates for Contemporary CR individuals calculated using allele frequencies estimated from the Contemporary CR sample with relatedness <= 0.4.

--- start bash code ---

OUTF='/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/estimates/froh/contemporary_cr_froh_using_contemporary_cr_ref.txt'
printf "ID\tFROH\tFROH_HIQUAL\n" > "$OUTF"
while read id
do
	FILE="/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/estimates/${id}_contemporary_cr_af_roh.froh"
	(printf "%s\t" $id && (tail -n1 "$FILE" | cut -f1,2)) >> "$OUTF"
done < /mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/inputs/contemporary_cr_ids.txt

--- end bash code ---


Collect FROH estimates for Resident CR individuals calculated using allele frequencies estimated from the Resident CR population sample with relatedness <= 0.4.

--- start bash code ---

OUTF='/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/estimates/froh/resident_cr_froh_using_resident_cr_ref.txt'
printf "ID\tFROH\tFROH_HIQUAL\n" > "$OUTF"
while read id
do
	FILE="/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/estimates/${id}_resident_cr_af_roh.froh"
	(printf "%s\t" $id && (tail -n1 "$FILE" | cut -f1,2)) >> "$OUTF"
done < /mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/inputs/resident_cr_ids.txt

--- end bash code ---


Collect FROH estimates for Site 13 individuals calculated using allele frequencies estimated from the Site 13 population sample with relatedness <= 0.4.

--- start bash code ---

OUTF='/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/estimates/froh/site13_froh_using_site13_ref.txt'
printf "ID\tFROH\tFROH_HIQUAL\n" > "$OUTF"
while read id
do
	FILE="/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/estimates/${id}_site13_af_roh.froh"
	(printf "%s\t" $id && (tail -n1 "$FILE" | cut -f1,2)) >> "$OUTF"
done < /mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/inputs/site13_ids.txt

--- end bash code ---


Collect FROH estimates for donor population individuals calculated using allele frequencies estimated from pooled donor populations after removing relatedness > 0.4.

--- start bash code ---

OUTF='/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/estimates/froh/donor_froh_using_pooled_donor_ref.txt'
printf "ID\tFROH\tFROH_HIQUAL\n" > "$OUTF"
while read id
do
	FILE="/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/estimates/${id}_donor_pops_af_roh.froh"
	(printf "%s\t" $id && (tail -n1 "$FILE" | cut -f1,2)) >> "$OUTF"
done < /mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/inputs/donor_pops_ids.txt

--- end bash code ---

Collect FROH estimates for historic metapopulation individuals (jays sampled from 2003-2008) calculated using allele frequencies estimated from the historic metapopulation samples with relatedness <= 0.4.

--- start bash code ---

OUTF='/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/estimates/froh/historic_metapop_froh_using_historic_metapop_ref.txt'
printf "ID\tFROH\tFROH_HIQUAL\n" > "$OUTF"
while read id
do
	FILE="/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/estimates/${id}_historic_metapop_af_roh.froh"
	(printf "%s\t" $id && (tail -n1 "$FILE" | cut -f1,2)) >> "$OUTF"
done < /mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/inputs/historic_metapop_ids.txt

--- end bash code ---

Collect FROH estimates for all Mosaic individuals calculated using allele frequencies estimated from all pooled Mosaic individuals having relatedness <= 0.4.

--- start bash code ---

OUTF='/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/estimates/froh/all_mosaic_individuals_froh_using_all_pooled_mosaic_ref.txt'
printf "ID\tFROH\tFROH_HIQUAL\n" > "$OUTF"
while read id
do
	FILE="/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/estimates/${id}_mosaic_all_af_roh.froh"
	(printf "%s\t" $id && (tail -n1 "$FILE" | cut -f1,2)) >> "$OUTF"
done < /mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/inputs/mosaic_all_ids.txt

--- end bash code ---

Combine high quality FROH estimates across all samples into a single file.

'FROH_BEST' (what I consider the best Froh estimate) is Froh estimated using population-specific allele frequencies (when they could be estimated 
with a sample size >= 10 after removing first degree relatives, r > 0.4) when possible. When estimating population-specific allele frequencies 
was not possible the next most appropriate reference population was chosen, specifically the pooled donor sites for translocated jays or the entire 
historic metapopulation for the 'other' M4 population individuals. The 'FROH_BEST' estimates were added to the metadata, /home/tyler/Dropbox/research/jay/mosaic/metadata/M4_sequenced_FSJsamples_metadata.txt, and the M4_sequenced_individual_metadata.tsv file deposited to dryad under the 'FROH' field.

--- start R code ---

# read in metadata
meta <- read.table('/mnt/research/Fitz_Lab/projects/mosaic/M4_sequenced_FSJsamples_metadata.txt',head=TRUE,sep="\t")

# read in froh values
contemp_cr <- read.table('/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/estimates/froh/contemporary_cr_froh_using_contemporary_cr_ref.txt', head=TRUE)
res_cr <- read.table('/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/estimates/froh/resident_cr_froh_using_resident_cr_ref.txt', head=TRUE)
s13 <- read.table('/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/estimates/froh/site13_froh_using_site13_ref.txt',head=TRUE)
donor <- read.table('/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/estimates/froh/donor_froh_using_pooled_donor_ref.txt',head=TRUE)
histmeta <- read.table('/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/estimates/froh/historic_metapop_froh_using_historic_metapop_ref.txt',head=TRUE)
allmosaic <- read.table('/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/estimates/froh/all_mosaic_individuals_froh_using_all_pooled_mosaic_ref.txt',head=TRUE)

# combine froh values
allcomb <- allmosaic[,c(1,3)]
colnames(allcomb) <- c('ID', 'FROH_ALL_MOSAIC_AF')
allcomb$FROH_CONTEMPORARY_CR_AF <- unname(sapply(allcomb$ID, function(x,df){idx = which(df$ID == x); ifelse(length(idx) > 0, df$FROH_HIQUAL[idx], NA)}, df = contemp_cr))
allcomb$FROH_RESIDENT_CR_AF <- unname(sapply(allcomb$ID, function(x,df){idx = which(df$ID == x); ifelse(length(idx) > 0, df$FROH_HIQUAL[idx], NA)}, df = res_cr))
allcomb$FROH_SITE13_AF <- unname(sapply(allcomb$ID, function(x,df){idx = which(df$ID == x); ifelse(length(idx) > 0, df$FROH_HIQUAL[idx], NA)}, df = s13))
allcomb$FROH_DONOR_AF <- unname(sapply(allcomb$ID, function(x,df){idx = which(df$ID == x); ifelse(length(idx) > 0, df$FROH_HIQUAL[idx], NA)}, df = donor))
allcomb$FROH_HISTORIC_METAPOP_AF <- unname(sapply(allcomb$ID, function(x,df){idx = which(df$ID == x); ifelse(length(idx) > 0, df$FROH_HIQUAL[idx], NA)}, df = histmeta))

allcomb$FROH_BEST <- NA
for (i in 1:nrow(allcomb)) {
	id <- allcomb$ID[i]
	pop <- meta$pop[which(meta$LAB_ID == id)]
	if (pop == "Contemporary") {
		allcomb$FROH_BEST[i] <- allcomb$FROH_CONTEMPORARY_CR_AF[i]
	} else if (pop == "Resident") {
		allcomb$FROH_BEST[i] <- allcomb$FROH_RESIDENT_CR_AF[i]
	} else if (pop == "SITE_13") {
		allcomb$FROH_BEST[i] <- allcomb$FROH_SITE13_AF[i]
	} else if (pop == "SITE_1" || pop == "SITE_12" || pop == "SITE_18" || pop == "TEXACO") {
		allcomb$FROH_BEST[i] <- allcomb$FROH_DONOR_AF[i]
	} else if (pop == "Golden_Aster_Scrub" || pop == "Brigman" || pop == "W.Balm" || pop == "Duette_headwaters" || pop == "Sun_City") {
		allcomb$FROH_BEST[i] <- allcomb$FROH_HISTORIC_METAPOP_AF[i]
	} else {
		stop(paste0("Unknown population ",pop))
	}
}

allcomb <- allcomb[,c(1,8,3:7,2)]

# write combined results
#write.table(allcomb, file='/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/estimates/froh/mosaic_collated_froh.txt', col.names=TRUE, row.names=FALSE, sep="\t", quote=FALSE)

--- end R code ---

## Statistical tests comparing FROH distributions between groups

Test for differences in the distribution of Froh between subsets of individuals for which all pairwise r is below 0.4.

--- start R code ---

fdf <- read.table('/mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/estimates/froh/mosaic_collated_froh.txt',head=TRUE)

# read in relatedness pruned subsets
res.prune <- read.table('/home/tyler/Dropbox/research/jay/mosaic/popgen/roh/inputs/resident_cr_relatedness_maxr0.4_ids.txt',head=FALSE)$V1
res.prune2 <- read.table('/home/tyler/Dropbox/research/jay/mosaic/popgen/relatedness/unrelated_subsets/resident_cr_noE030_relatedness_maxr0.4_ids_seed836241.txt',head=FALSE)$V1
trans.prune <- read.table('/home/tyler/Dropbox/research/jay/mosaic/popgen/relatedness/unrelated_subsets/translocated_relatedness_maxr0.4_ids_seed328974.txt',head=FALSE)$V1 # updated compared to /mnt/research/Fitz_Lab/projects/mosaic/popgen/roh/inputs/donor_pops_relatedness_maxr0.4_ids.txt subset to strictly translocated jays and not those considered translocated (i.e. I_049)
contemp.prune <- read.table('/home/tyler/Dropbox/research/jay/mosaic/popgen/roh/inputs/contemporary_cr_relatedness_maxr0.4_ids.txt',head=FALSE)$V1 # these are all contemporary individuals because all pairwise r was < 0.4

## Test whether Froh are normally distributed

# r-pruned contemporary
shapiro.test(meta$FROH[which(meta$LAB_ID %in% contemp.prune == TRUE)])
#
#       Shapiro-Wilk normality test
#
#data:  meta$FROH[which(meta$LAB_ID %in% contemp.prune == TRUE)]
#W = 0.8966, p-value = 0.009531

# r-pruned residents without E_030
shapiro.test(meta$FROH[which(meta$LAB_ID %in% res.prune2 == TRUE)])
#
#       Shapiro-Wilk normality test
#
#data:  meta$FROH[which(meta$LAB_ID %in% res.prune2 == TRUE)]
#W = 0.69005, p-value = 0.0004421

# r-pruned translocated
shapiro.test(meta$FROH[which(meta$LAB_ID %in% trans.prune == TRUE)])
#
#       Shapiro-Wilk normality test
#
#data:  meta$FROH[which(meta$LAB_ID %in% trans.prune == TRUE)]
#W = 0.94394, p-value = 0.4345


## test for differences in the distributions of Froh

# r-pruned contemporary vs resident without E_030
c_v_r2_prune <- wilcox.test(x=meta$FROH[which(meta$LAB_ID %in% contemp.prune == TRUE)], y=meta$FROH[which(meta$LAB_ID %in% res.prune2 == TRUE)], alternative="two.sided")
c_v_r2_prune
#
#       Wilcoxon rank sum exact test
#
#data:  meta$FROH[which(meta$LAB_ID %in% contemp.prune == TRUE)] and meta$FROH[which(meta$LAB_ID %in% res.prune2 == TRUE)]
#W = 248, p-value = 0.06602
#alternative hypothesis: true location shift is not equal to 0

# r-pruned contemporary vs translocated
c_v_t_prune <- wilcox.test(x=meta$FROH[which(meta$LAB_ID %in% contemp.prune == TRUE)], y=meta$FROH[which(meta$LAB_ID %in% trans.prune == TRUE)], alternative="two.sided")
c_v_t_prune
#
#       Wilcoxon rank sum exact test
#
#data:  meta$FROH[which(meta$LAB_ID %in% contemp.prune == TRUE)] and meta$FROH[which(meta$LAB_ID %in% trans.prune == TRUE)]
#W = 323, p-value = 0.003333
#alternative hypothesis: true location shift is not equal to 0

# r-pruned residents without E_030 vs translocated
r2_v_t_prune <- wilcox.test(x=meta$FROH[which(meta$LAB_ID %in% res.prune2 == TRUE)], y=meta$FROH[which(meta$LAB_ID %in% trans.prune == TRUE)], alternative="two.sided")
r2_v_t_prune
#
#       Wilcoxon rank sum exact test
#
#data:  meta$FROH[which(meta$LAB_ID %in% res.prune2 == TRUE)] and meta$FROH[which(meta$LAB_ID %in% trans.prune == TRUE)]
#W = 117, p-value = 0.3874
#alternative hypothesis: true location shift is not equal to 0

## Calculate Froh summary stats for groups of individuals for which r < 0.4

# r-pruned contemporary
mean(meta$FROH[which(meta$LAB_ID %in% contemp.prune == TRUE)])
#[1] 0.09776112
sd(meta$FROH[which(meta$LAB_ID %in% contemp.prune == TRUE)])
#[1] 0.04031343
range(meta$FROH[which(meta$LAB_ID %in% contemp.prune == TRUE)])
#[1] 0.04617017 0.23007078

# r-pruned residents without E_030
mean(meta$FROH[which(meta$LAB_ID %in% res.prune2 == TRUE)])
#[1] 0.0849069
sd(meta$FROH[which(meta$LAB_ID %in% res.prune2 == TRUE)])
#[1] 0.05476314
range(meta$FROH[which(meta$LAB_ID %in% res.prune2 == TRUE)])
#[1] 0.04494418 0.24394346

# r-pruned translocated
mean(meta$FROH[which(meta$LAB_ID %in% trans.prune == TRUE)])
#[1] 0.06572061
sd(meta$FROH[which(meta$LAB_ID %in% trans.prune == TRUE)])
#[1] 0.02245787
range(meta$FROH[which(meta$LAB_ID %in% trans.prune == TRUE)])
#[1] 0.03469923 0.11252995

--- end R code ---

## Froh boxplots (Figure S6)

The inbreeding estimates being plotted are Froh estimated using population-specific allele frequencies estimated on subsets of indivdiuals 
for which pairwise r was below 0.4.

--- start R code ---

library(scales)

# parse data
meta <- read.table('/home/tyler/Dropbox/research/jay/mosaic/metadata/M4_sequenced_FSJsamples_metadata.txt',head=TRUE,sep="\t")

meta$biopoint = biopoint(meta$pop)
meta$popcol <- popcolor(meta)

meta$group <- replace(meta$pop, which(meta$pop == "Golden_Aster_Scrub" | meta$pop == "Brigman" | meta$pop == "W.Balm" |
meta$pop == "Duette_headwaters" | meta$pop == "Sun_City"), "M4")

meta$group <- replace(meta$group, which(meta$group == "SITE_1" | meta$group == "SITE_12" | meta$group == "SITE_13" |
meta$group == "SITE_18" | meta$group == "TEXACO"), "Translocated")

meta$group = factor(meta$group, levels=c("Contemporary", "Resident", "Translocated", "M4"))

meta.sub <- meta[-which(meta$LAB_ID == "T_072"),]

range(meta.sub$FROH)
#[1] 0.03469923 0.24783084

#png(file='/home/tyler/Dropbox/research/jay/mosaic/figures/Froh_distribution_pop_specific_AF_improved_labels.png',width=7, height=7,units='in', res=300)
h_boxplot3(x=meta.sub, n=22, lev=levels(meta.sub$group), ylabel=expression(Individual~inbreeding~(italic(F[ROH]))), pntlab=meta.sub$biopoint, seed=1947, color=meta.sub$popcol, ylim=c(0,0.28),
labpos=c(0.8,1.95,3,4))
#dev.off()

--- end R code ---


#
#
#

## ---------- RELATIONSHIP BETWEEN SEQUENCING DEPTH AND INBREEDING ---------- ##

Test for effects of sequencing depth on estimates of F from ngsF and runs of homozygosity. 
Also make plots of inbreeding estimates against sequencing depth.

--- start R code ---

library(scales)
library(boot)

meta <- read.table('/home/tyler/Dropbox/research/jay/mosaic/metadata/M4_sequenced_FSJsamples_metadata.txt',head=TRUE)
colnames(meta)[which(colnames(meta) == "pop_name_full")] = "POPULATION" # this is just to make column names consistent with the M4_sequenced_individual_metadata.tsv file on dryad
biotype_col = bioclass_col(meta$POPULATION)
meta$ptype = biopoint(meta$pop)
meta$popcol = popcolor(meta)

froh <- read.table('/home/tyler/Dropbox/research/jay/mosaic/popgen/roh/estimate/froh/mosaic_collated_froh.txt',head=TRUE) # Froh estimated using population-specific ('FROH_BEST') and metapopulation allele frequencies ('FROH_ALL_MOSAIC_AF') estimated from r-pruned subsets of individuals (all pairwise r <= 0.4)
ngsf.all <- read.table('/home/tyler/Dropbox/research/jay/mosaic/popgen/fstats/fsj_mosaic_biallelic_snps_main_autosomes_qc_all_F_formatted.txt',head=TRUE) # ngsF F estimated based on all individuals (no r-pruning) and metapopulation-wide reference population
ngsf.ps <- read.table('/home/tyler/Dropbox/research/jay/mosaic/popgen/fstats/fsj_mosaic_biallelic_snps_main_autosomes_qc_all_F_pop_specific_ref_AF_fixedMAF.txt', head=TRUE) # ngsF F estimated using population-specific allele frequencies from r-pruned subsets (all pairwise r <= 0.4)
ngsf.ps2 <- read.table('/home/tyler/Dropbox/research/jay/mosaic/popgen/fstats/fsj_mosaic_biallelic_snps_main_autosomes_qc_all_F_pop_specific_ref_AF.txt',head=TRUE) # ngsF F estimated using population-specific allele frequencies without relatedness pruning

# collate F and depth
meta$F_ALL = sapply(meta$LAB_ID,function(x,df){df$F[which(df$SAMPLE == x)]},df=ngsf.all, USE.NAMES=FALSE)
meta$F_PS = sapply(meta$LAB_ID,function(x,df){df$F_POP_SPECIFIC_AF[which(df$ID == x)]},df=ngsf.ps, USE.NAMES=FALSE)
meta$F_PS2 = sapply(meta$LAB_ID,function(x,df){df$F_POP_SPECIFIC_AF[which(df$ID == x)]},df=ngsf.ps2, USE.NAMES=FALSE)
meta$FROH_ALL = sapply(meta$LAB_ID,function(x,df){df$FROH_ALL_MOSAIC_AF[which(df$ID == x)]},df=froh, USE.NAMES=FALSE)
meta$FROH_PS = sapply(meta$LAB_ID,function(x,df){df$FROH_BEST[which(df$ID == x)]},df=froh, USE.NAMES=FALSE)

#I. Test for relationships between sequencing depth and F estimated from population-specific allele frequencies from r-pruned 
#subsets of individuals ('F' in dryad M4_sequenced_individual_metadata.tsv file).

ngsf_f_depth_ps_model = lm(F_PS ~ autosome_depth, data=meta)

summary(ngsf_f_depth_ps_model)
#
#Call:
#lm(formula = F_PS ~ autosome_depth, data = meta)
#
#Residuals:
#      Min        1Q    Median        3Q       Max 
#-0.012577 -0.009111 -0.006283 -0.004268  0.124075 
#
#Coefficients:
#                Estimate Std. Error t value Pr(>|t|)
#(Intercept)    0.0085178  0.0171284   0.497    0.620
#autosome_depth 0.0004936  0.0023286   0.212    0.833
#
#Residual standard error: 0.02217 on 85 degrees of freedom
#Multiple R-squared:  0.0005284,        Adjusted R-squared:  -0.01123 
#F-statistic: 0.04494 on 1 and 85 DF,  p-value: 0.8326

shapiro.test(resid(ngsf_f_depth_ps_model)) # errors not normal so will use a bootstrap to test for significant effect of depth on F
#
#       Shapiro-Wilk normality test
#
#data:  resid(ngsf_f_depth_ps_model)
#W = 0.48763, p-value = 6.784e-16

ngsf_f_depth.boot <- boot(data.frame(x=meta$autosome_depth, y=meta$F_PS), getBeta1, R=10000, stype="i", sim="ordinary")
ngsf_f_depth.ci <- boot.ci(ngsf_f_depth.boot, conf=0.95, type=c("perc","bca"))

ngsf_f_depth.ci
#BOOTSTRAP CONFIDENCE INTERVAL CALCULATIONS
#Based on 10000 bootstrap replicates
#
#CALL : 
#boot.ci(boot.out = ngsf_f_depth.boot, conf = 0.95, type = c("perc", 
#    "bca"))
#
#Intervals : 
#Level     Percentile            BCa          
#95%   (-0.0041,  0.0067 )   (-0.0034,  0.0086 )  
#Calculations and Intervals on Original Scale

# plot F vs depth (Figures S7A and S7B)

#png(file="/home/tyler/Dropbox/research/jay/mosaic/figures/methods_evaluation/ngsF_F_vs_depth_pop_specific.png", width=7, height=7, units='in', res=300)
par(mgp=c(2.65,1,0), mar=c(5,4.3,4,2) + 0.1)
plot(x = meta$autosome_depth, y = meta$F_PS, cex=1.5, pch=21, col=biotype_col, bg=alpha(biotype_col,0.6), xlab="Average sequencing depth",
ylab=bquote(italic(F[ngsF])),cex.lab=1.5, cex.axis=1.5, main="Population-specific AF")
abline(a=ngsf_f_depth_ps_model$coefficients[1], b=ngsf_f_depth_ps_model$coefficients[2], col="gray40")
legend('topright',legend=c("Contemporary CR","Resident CR","Donor population","Other M4"), fill=c("hotpink2","purple2","dodgerblue2","gold2"),bty='n',cex=1.2)
text(x=11,y=0.02,label=bquote(italic(r)^2 == .(round(summary(ngsf_f_depth_ps_model)$r.square, digits=5))), cex=1.3)
#dev.off()

# y-limit zoom
#png(file="/home/tyler/Dropbox/research/jay/mosaic/figures/methods_evaluation/ngsF_F_vs_depth_pop_specific_yzoom.png", width=7, height=7, units='in', res=300)
par(mgp=c(2.65,1,0), mar=c(5,4.3,4,2) + 0.1)
plot(x = meta$autosome_depth, y = meta$F_PS, cex=1.5, pch=21, col=biotype_col, bg=alpha(biotype_col,0.6), xlab="Average sequencing depth",
ylab=bquote(italic(F[ngsF])),cex.lab=1.5, cex.axis=1.5, main="Population-specific AF", ylim=c(0,0.02))
legend('topright',legend=c("Contemporary CR","Resident CR","Donor population","Other M4"), fill=c("hotpink2","purple2","dodgerblue2","gold2"),bty='n',cex=1.2)
#dev.off()

#II. Test for relationships between sequencing depth and F estimated from metapopulation allele frequencies with no r-pruning 
# ('F_META_ALL' in dryad inbreed_coefficient_alternate_calculations.tsv file). 

ngsf_f_depth_model = lm(F_ALL ~ autosome_depth, data=meta)

summary(ngsf_f_depth_model)
#
#Call:
#lm(formula = F_ALL ~ autosome_depth, data = meta)
#
#Residuals:
#      Min        1Q    Median        3Q       Max 
#-0.023402 -0.017828 -0.009750  0.005047  0.133679 
#
#Coefficients:
#                Estimate Std. Error t value Pr(>|t|)
#(Intercept)    0.0234328  0.0221008    1.06    0.292
#autosome_depth 0.0003001  0.0030045    0.10    0.921
#
#Residual standard error: 0.02861 on 85 degrees of freedom
#Multiple R-squared:  0.0001174,        Adjusted R-squared:  -0.01165 
#F-statistic: 0.009978 on 1 and 85 DF,  p-value: 0.9207

shapiro.test(resid(ngsf_f_depth_model)) # errors not normal so will use a bootstrap to test effect of depth on F
#
#       Shapiro-Wilk normality test
#
#data:  resid(ngsf_f_depth_model)
#W = 0.71935, p-value = 1.33e-11


ngsf_f_depth_meta.boot <- boot(data.frame(x=meta$autosome_depth, y=meta$F_ALL), getBeta1, R=10000, stype="i", sim="ordinary")
ngsf_f_depth_meta.ci <- boot.ci(ngsf_f_depth_meta.boot, conf=0.95, type=c("perc","bca"))

ngsf_f_depth_meta.ci
#BOOTSTRAP CONFIDENCE INTERVAL CALCULATIONS
#Based on 10000 bootstrap replicates
#
#CALL : 
#boot.ci(boot.out = ngsf_f_depth_meta.boot, conf = 0.95, type = c("perc", 
#    "bca"))
#
#Intervals : 
#Level     Percentile            BCa          
#95%   (-0.0050,  0.0069 )   (-0.0043,  0.0082 )  
#Calculations and Intervals on Original Scale

# plot F versus depth

#png(file="/home/tyler/Dropbox/research/jay/mosaic/figures/methods_evaluation/ngsF_F_vs_depth_metapop_wide.png")
par(mgp=c(2.65,1,0), mar=c(5,4.3,4,2) + 0.1)
plot(x = meta$autosome_depth, y = meta$F_ALL, cex=1.5, pch=21, col=biotype_col, bg=alpha(biotype_col,0.6), xlab="Average sequencing depth",
ylab=bquote(italic(F[ngsF])),cex.lab=1.5, cex.axis=1.5, main="Metapopulation-wide AF")
abline(a=ngsf_f_depth_model$coefficients[1], b=ngsf_f_depth_model$coefficients[2], col="gray40")
legend('topright',legend=c("Contemporary CR","Resident CR","Donor population","Other M4"), fill=c("hotpink2","purple2","dodgerblue2","gold2"),bty='n',cex=1.2)
text(x=11.4,y=0.0335,label=bquote(italic(r)^2 == .(round(summary(ngsf_f_depth_model)$r.square, digits=5))), cex=1.3)
#dev.off()

#III. Test for relationships between sequencing depth and Froh estimated with population-specific allele frequencies from r-pruned 
#subsets of individuals ('FROH' in dryad M4_sequenced_individual_metadata.tsv file).

froh_depth_ps_model = lm(FROH_PS ~ autosome_depth, data=meta)

summary(froh_depth_ps_model)
#
#Call:
#lm(formula = FROH_PS ~ autosome_depth, data = meta)
#
#Residuals:
#     Min       1Q   Median       3Q      Max 
#-0.05367 -0.03005 -0.01158  0.01699  0.15842 
#
#Coefficients:
#                Estimate Std. Error t value Pr(>|t|)   
#(Intercept)     0.103826   0.035624   2.915  0.00455 **
#autosome_depth -0.002310   0.004843  -0.477  0.63465   
#---
#Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1
#
#Residual standard error: 0.04612 on 85 degrees of freedom
#Multiple R-squared:  0.002669, Adjusted R-squared:  -0.009065 
#F-statistic: 0.2274 on 1 and 85 DF,  p-value: 0.6347

shapiro.test(resid(froh_depth_ps_model)) # errors not normal so will use a bootstrap to test effect depth on Froh
#
#       Shapiro-Wilk normality test
#
#data:  resid(froh_depth_ps_model)
#W = 0.83515, p-value = 1.976e-08

froh_depth_ps.boot <- boot(data.frame(x=meta$autosome_depth, y=meta$FROH_PS), getBeta1, R=10000, stype="i", sim="ordinary")
froh_depth_ps.ci <- boot.ci(froh_depth_ps.boot, conf=0.95, type=c("perc","bca"))

froh_depth_ps.ci
#BOOTSTRAP CONFIDENCE INTERVAL CALCULATIONS
#Based on 10000 bootstrap replicates
#
#CALL : 
#boot.ci(boot.out = froh_depth_ps.boot, conf = 0.95, type = c("perc", 
#    "bca"))
#
#Intervals : 
#Level     Percentile            BCa          
#95%   (-0.0114,  0.0060 )   (-0.0112,  0.0062 )  
#Calculations and Intervals on Original Scale

# plot Froh vs sequence depth (Figure S7C)

#png(file="/home/tyler/Dropbox/research/jay/mosaic/figures/methods_evaluation/Froh_vs_depth_pop_specific.png", width=7, height=7, units='in', res=300)
par(mgp=c(2.65,1,0), mar=c(5,4.3,4,2) + 0.1)
plot(x = meta$autosome_depth, y = meta$FROH_PS, cex=1.5, pch=21, col=biotype_col, bg=alpha(biotype_col,0.6), xlab="Average sequencing depth",
ylab=bquote(italic(F[ROH])),cex.lab=1.5, cex.axis=1.5, main="Population-specific AF")
abline(a=froh_depth_ps_model$coefficients[1], b=froh_depth_ps_model$coefficients[2], col="gray40")
legend('topright',legend=c("Contemporary CR","Resident CR","Donor population","Other M4"), fill=c("hotpink2","purple2","dodgerblue2","gold2"),bty='n',cex=1.2)
text(x=11.3,y=0.07,label=bquote(italic(r)^2 == .(round(summary(froh_depth_ps_model)$r.square, digits=5))), cex=1.3)
#dev.off()

#IV. Test for relationships between sequencing depth and Froh estimated with metapopulation-wide allele frequencies from r-pruned 
#subsets of individuals ('FROH_META_PRUNE' in dryad inbreed_coefficient_alternate_calculations.tsv file).

froh_depth_model = lm(FROH_ALL ~ autosome_depth, data=meta)

summary(froh_depth_model)
#
#Call:
#lm(formula = FROH_ALL ~ autosome_depth, data = meta)
#
#Residuals:
#     Min       1Q   Median       3Q      Max 
#-0.05721 -0.03046 -0.01250  0.01395  0.15706 
#
#Coefficients:
#                Estimate Std. Error t value Pr(>|t|)   
#(Intercept)     0.105613   0.035844   2.946  0.00415 **
#autosome_depth -0.002034   0.004873  -0.417  0.67746   
#---
#Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1
#
#Residual standard error: 0.0464 on 85 degrees of freedom
#Multiple R-squared:  0.002045, Adjusted R-squared:  -0.009695 
#F-statistic: 0.1742 on 1 and 85 DF,  p-value: 0.6775

shapiro.test(resid(froh_depth_model)) # errors not normal so will use a bootstrap to test effect of depth on Froh
#
#       Shapiro-Wilk normality test
#
#data:  resid(froh_depth_model)
#W = 0.84653, p-value = 4.765e-08

froh_depth.boot <- boot(data.frame(x=meta$autosome_depth, y=meta$FROH_ALL), getBeta1, R=10000, stype="i", sim="ordinary")
froh_depth.ci <- boot.ci(froh_depth.boot, conf=0.95, type=c("perc","bca"))

froh_depth.ci
#BOOTSTRAP CONFIDENCE INTERVAL CALCULATIONS
#Based on 10000 bootstrap replicates
#
#CALL : 
#boot.ci(boot.out = froh_depth.boot, conf = 0.95, type = c("perc", 
#    "bca"))
#
#Intervals : 
#Level     Percentile            BCa          
#95%   (-0.0110,  0.0063 )   (-0.0109,  0.0064 )  
#Calculations and Intervals on Original Scale

# plot Froh vs depth

#png(file="/home/tyler/Dropbox/research/jay/mosaic/figures/methods_evaluation/Froh_vs_depth_metapop_wide.png")
par(mgp=c(2.65,1,0), mar=c(5,4.3,4,2) + 0.1)
plot(x = meta$autosome_depth, y = meta$FROH_ALL, cex=1.5, pch=21, col=biotype_col, bg=alpha(biotype_col,0.6), xlab="Average sequencing depth",
ylab=bquote(italic(F[ROH])),cex.lab=1.5, cex.axis=1.5, main="Metapopulation-wide AF")
abline(a=froh_depth_model$coefficients[1], b=froh_depth_model$coefficients[2], col="gray40")
legend('topright',legend=c("Contemporary CR","Resident CR","Donor population","Other M4"), fill=c("hotpink2","purple2","dodgerblue2","gold2"),bty='n',cex=1.2)
text(x=11.3,y=0.074,label=bquote(italic(r)^2 == .(round(summary(froh_depth_model)$r.square, digits=5))), cex=1.3)
#dev.off()

--- end R code ---


#
#
#


## ---------- EFFECTS OF RELATEDNESS PRUNING ON INBREEDING ---------- ##

Determine correlation between individual inbreeding estimated with ngsF using all indivivduals and a relatedness-pruned subset of individuals (no pairwise r > 0.4).
All compared F were estimated using population-specific allele frequencies (the same reference population was used to estimate F).

--- start R code ---

library(boot)
library(scales)

# Read in F estimated using allele frequencies based on all individuals from each population/group (no relatedness pruning). The population-specific allele frequencies were used to 
# estimate F. These are the 'F_PS_ALL' values in the inbreed_coefficient_alternate_calculations.tsv dryad file. 
f.all <- read.table('/home/tyler/Dropbox/research/jay/mosaic/popgen/fstats/fsj_mosaic_biallelic_snps_main_autosomes_qc_all_F_pop_specific_ref_AF.txt',head=TRUE)

# Read in F estimated using allele frequencies based on subsets of individuals for which all pairwise relatedness was <= 0.4 (relatedness pruned). The population-specific allele 
# frequencies were used to estimate F. These are the 'F' values in the M4_sequenced_individual_metadata.tsv dryad file.
f.prune <- read.table('/home/tyler/Dropbox/research/jay/mosaic/popgen/fstats/fsj_mosaic_biallelic_snps_main_autosomes_qc_all_F_pop_specific_ref_AF_fixedMAF.txt',head=TRUE)

# read in metadata
meta <- read.table('/home/tyler/Dropbox/research/jay/mosaic/metadata/M4_sequenced_FSJsamples_metadata.txt',head=TRUE)

meta$F.ALL <- sapply(meta$LAB_ID, function(x,df){df$F_POP_SPECIFIC_AF[which(df$ID == x)]}, df=f.all, USE.NAMES=FALSE)
meta$F.PRUNE <- sapply(meta$LAB_ID, function(x,df){df$F_POP_SPECIFIC_AF[which(df$ID == x)]}, df=f.prune, USE.NAMES=FALSE)

# test for correlation between F estimated with and without relatedness pruning

fmod <- lm(meta$F.PRUNE ~ meta$F.ALL)

summary(fmod)
#
#Call:
#lm(formula = meta$F.PRUNE ~ meta$F.ALL)
#
#Residuals:
#       Min         1Q     Median         3Q        Max 
#-0.0142090 -0.0018693  0.0004139  0.0020509  0.0089352 
#
#Coefficients:
#             Estimate Std. Error t value Pr(>|t|)    
#(Intercept) 3.065e-05  4.330e-04   0.071    0.944    
#meta$F.ALL  9.539e-01  1.666e-02  57.240   <2e-16 ***
#---
#Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1
#
#Residual standard error: 0.003527 on 85 degrees of freedom
#Multiple R-squared:  0.9747,   Adjusted R-squared:  0.9744 
#F-statistic:  3276 on 1 and 85 DF,  p-value: < 2.2e-16

shapiro.test(resid(fmod))
#
#       Shapiro-Wilk normality test
#
#data:  resid(fmod)
#W = 0.92922, p-value = 0.0001408

#hist(resid(fmod),breaks=20) # errors appear to deviate only slightly from a normal distribution, but will still bootstrap to test for correlation

ftype.ci
#BOOTSTRAP CONFIDENCE INTERVAL CALCULATIONS
#Based on 10000 bootstrap replicates
#
#CALL : 
#boot.ci(boot.out = ftype.boot, conf = 0.99, type = c("perc", 
#    "bca"))
#
#Intervals : 
#Level     Percentile            BCa          
#99%   ( 0.7792,  0.9968 )   ( 0.8539,  1.0112 )  
#Calculations and Intervals on Original Scale
#Some BCa intervals may be unstable

# plot correlation between F with and without relatedness pruning
meta$ptype = biopoint(meta$pop)
meta$popcol = popcolor(meta)

#png(file='/home/tyler/Dropbox/research/jay/mosaic/figures/methods_evaluation/ngsF_correlation_with_v_without_rpruning.png',width=7, height=7, units='in', res=300)
par(mgp=c(2.8,1,0))
plot(x=meta$F.ALL, y=meta$F.PRUNE, col=alpha(meta$popcol,0.6), bg=alpha(meta$popcol,0.6), pch=meta$ptype, cex=1.4, 
xlab=expression(paste(italic(F), ", no pruning")), ylab=expression(paste(italic(F), ", relatedness pruned", sep="")), cex.axis=1.3, cex.lab=1.3)
abline(0,1,lty="dashed",col="grey40")
abline(a=fmod$coefficients[1], b=fmod$coefficients[2], col="grey40")
text(x=0.12,y=0.093,label=bquote(italic(r)^2 == .(round(summary(fmod)$r.square, digits=5))), cex=1.3)
#dev.off()


# Note that the reason contemporary samples are not perfectly correlated despite not pruning (all pairwise r between contemporary individuals was < 0.4) is that for the pruned analyses
# ngsF was run with a starting F from a previous iteration involving all individuals. That is, the optimization for estimating F was slightly different.

# Examine correlation between F with and without r-pruning with Contemporary individuals excluded because none were pruned so will drive up correlation

meta.sub <- meta[-which(meta$pop == "Contemporary"),]

fmod.sub <- lm(meta.sub$F.PRUNE ~ meta.sub$F.ALL)

summary(fmod.sub)
#
#Call:
#lm(formula = meta.sub$F.PRUNE ~ meta.sub$F.ALL)
#
#Residuals:
#       Min         1Q     Median         3Q        Max 
#-0.0145742 -0.0008637  0.0002232  0.0017673  0.0090174 
#
#Coefficients:
#                Estimate Std. Error t value Pr(>|t|)    
#(Intercept)    0.0005454  0.0005599   0.974    0.334    
#meta.sub$F.ALL 0.9471035  0.0238523  39.707   <2e-16 ***
#---
#Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1
#
#Residual standard error: 0.00384 on 57 degrees of freedom
#Multiple R-squared:  0.9651,   Adjusted R-squared:  0.9645 
#F-statistic:  1577 on 1 and 57 DF,  p-value: < 2.2e-16

shapiro.test(resid(fmod.sub))
#
#       Shapiro-Wilk normality test
#
#data:  resid(fmod.sub)
#W = 0.86443, p-value = 9.684e-06

#hist(resid(fmod.sub),breaks=15)

# Normal distribution for errors is rejected by shapiro test, but they appear to only subtly deviate from normal.
# Will also calculate 95% bootstrap CI to test for a significant correlation using a nonparametric approach.

set.seed(61772)

ftype_sub.boot <- boot(data.frame(x=meta.sub$F.ALL, y=meta.sub$F.PRUNE), getBeta1, R=10000, stype="i", sim="ordinary")
ftype_sub.ci <- boot.ci(ftype_sub.boot, conf=0.95, type=c("perc","bca"))

ftype_sub.ci
#BOOTSTRAP CONFIDENCE INTERVAL CALCULATIONS
#Based on 10000 bootstrap replicates
#
#CALL : 
#boot.ci(boot.out = ftype_sub.boot, conf = 0.95, type = c("perc", 
#    "bca"))
#
#Intervals : 
#Level     Percentile            BCa          
#95%   ( 0.8349,  1.0006 )   ( 0.8812,  1.0182 )  
#Calculations and Intervals on Original Scale

# plot correlation between F with and without r-pruning (contemporary individuals excluded)

#png(file='/home/tyler/Dropbox/research/jay/mosaic/figures/methods_evaluation/ngsF_correlation_with_v_without_rpruning_no_contemporary.png',width=7, height=7, units='in', res=300)
par(mgp=c(2.8,1,0))
plot(x=meta.sub$F.ALL, y=meta.sub$F.PRUNE, col=alpha(meta.sub$popcol,0.6), bg=alpha(meta.sub$popcol,0.6), pch=meta.sub$ptype, cex=1.4,
xlab=expression(paste(italic(F), ", no pruning")), ylab=expression(paste(italic(F), ", relatedness pruned", sep="")), cex.axis=1.3, cex.lab=1.3)
abline(0,1,lty="dashed",col="grey40")
abline(a=fmod.sub$coefficients[1], b=fmod.sub$coefficients[2], col="grey40")
text(x=0.065,y=0.05,label=bquote(italic(r)^2 == .(round(summary(fmod)$r.square, digits=2))), cex=1.3)
#dev.off()

--- end R code ---


#
#
#


## ---------- RELATIONSHIP BETWEEN DIFFERENT APPROACHES TO ESTIMATING INBREEDING ---------- ##

--- start R code ---

library(scales)
library(boot)

meta <- read.table('/home/tyler/Dropbox/research/jay/mosaic/metadata/M4_sequenced_FSJsamples_metadata.txt',head=TRUE)
colnames(meta)[which(colnames(meta) == "pop_name_full")] = "POPULATION" # this is just to make column names consistent with the M4_sequenced_individual_metadata.tsv file on dryad
biotype_col = bioclass_col(meta$POPULATION)
meta$ptype = biopoint(meta$pop)
meta$popcol = popcolor(meta)

froh <- read.table('/home/tyler/Dropbox/research/jay/mosaic/popgen/roh/estimate/froh/mosaic_collated_froh.txt',head=TRUE) # Froh estimated using population-specific ('FROH_BEST') and metapopulation allele frequencies ('FROH_ALL_MOSAIC_AF') estimated from r-pruned subsets of individuals (all pairwise r <= 0.4)
ngsf.all <- read.table('/home/tyler/Dropbox/research/jay/mosaic/popgen/fstats/fsj_mosaic_biallelic_snps_main_autosomes_qc_all_F_formatted.txt',head=TRUE) # ngsF F estimated based on all individuals (no r-pruning) and metapopulation-wide reference population
ngsf.ps <- read.table('/home/tyler/Dropbox/research/jay/mosaic/popgen/fstats/fsj_mosaic_biallelic_snps_main_autosomes_qc_all_F_pop_specific_ref_AF_fixedMAF.txt', head=TRUE) # ngsF F estimated using population-specific allele frequencies from r-pruned subsets (all pairwise r <= 0.4)
ngsf.ps2 <- read.table('/home/tyler/Dropbox/research/jay/mosaic/popgen/fstats/fsj_mosaic_biallelic_snps_main_autosomes_qc_all_F_pop_specific_ref_AF.txt',head=TRUE) # ngsF F estimated using population-specific allele frequencies without relatedness pruning

# collate F and depth
meta$F_ALL = sapply(meta$LAB_ID,function(x,df){df$F[which(df$SAMPLE == x)]},df=ngsf.all, USE.NAMES=FALSE)
meta$F_PS = sapply(meta$LAB_ID,function(x,df){df$F_POP_SPECIFIC_AF[which(df$ID == x)]},df=ngsf.ps, USE.NAMES=FALSE)
meta$F_PS2 = sapply(meta$LAB_ID,function(x,df){df$F_POP_SPECIFIC_AF[which(df$ID == x)]},df=ngsf.ps2, USE.NAMES=FALSE)
meta$FROH_ALL = sapply(meta$LAB_ID,function(x,df){df$FROH_ALL_MOSAIC_AF[which(df$ID == x)]},df=froh, USE.NAMES=FALSE)
meta$FROH_PS = sapply(meta$LAB_ID,function(x,df){df$FROH_BEST[which(df$ID == x)]},df=froh, USE.NAMES=FALSE)

# I. Correlation between ngsF F estimated using population-specific allele frequencies (no relatedness pruning) vs metapopulation-wide allele frequencies (no relatedness pruning)

ngsf_refaf_model2 = lm(F_PS2 ~ F_ALL, data=meta)

summary(ngsf_refaf_model2)
#
#Call:
#lm(formula = F_PS2 ~ F_ALL, data = meta)
#
#Residuals:
#      Min        1Q    Median        3Q       Max 
#-0.033605 -0.006243  0.001666  0.004432  0.026335 
#
#Coefficients:
#             Estimate Std. Error t value Pr(>|t|)    
#(Intercept) -0.006179   0.001326  -4.661 1.16e-05 ***
#F_ALL        0.735630   0.034741  21.175  < 2e-16 ***
#---
#Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1
#
#Residual standard error: 0.009164 on 85 degrees of freedom
#Multiple R-squared:  0.8406,   Adjusted R-squared:  0.8388 
#F-statistic: 448.4 on 1 and 85 DF,  p-value: < 2.2e-16

shapiro.test(resid(ngsf_refaf_model2))
#
#       Shapiro-Wilk normality test
#
#data:  resid(ngsf_refaf_model2)
#W = 0.92975, p-value = 0.0001501

#hist(resid(ngsf_refaf_model2), breaks=30)

# errors are slightly skewed and shapiro test rejects that they are normal so will use bootstrap to calculate 95 CI to test for significant correlation between ngsF F estimates

ngsf_refaf2.boot <- boot(data.frame(x=meta$F_ALL, y=meta$F_PS2), getBeta1, R=10000, stype="i", sim="ordinary")
ngsf_refaf2.ci <- boot.ci(ngsf_refaf2.boot, conf=0.95, type=c("perc","bca"))

ngsf_refaf2.ci
#BOOTSTRAP CONFIDENCE INTERVAL CALCULATIONS
#Based on 10000 bootstrap replicates
#
#CALL : 
#boot.ci(boot.out = ngsf_refaf2.boot, conf = 0.95, type = c("perc", 
#    "bca"))
#
#Intervals : 
#Level     Percentile            BCa          
#95%   ( 0.5200,  0.8523 )   ( 0.5475,  0.8629 )  
#Calculations and Intervals on Original Scale

# plot relationship between ngsF F estimates (Figure S10, left panel)

#png(file="/home/tyler/Dropbox/research/jay/mosaic/figures/methods_evaluation/ngsF_refAF_correlation_without_r_pruning.png", width=7, height=7, units='in', res=300)
#png(file="/home/tyler/Dropbox/research/jay/mosaic/figures/methods_evaluation/ngsF_refAF_correlation_without_r_pruning_bw.png", width=7, height=7, units='in', res=300) # black and white point version
par(mgp=c(2.65,1,0))

plot(x = meta$F_ALL, y = meta$F_PS2, cex=1.5, pch=21, col="black", bg=alpha("grey40",0.6),
xlab=expression(paste(italic(F)[ngsF], " (metapopulation reference)", sep="")), ylab=expression(paste(italic(F)[ngsF], " (population-specific reference)", sep="")),
main=NULL, cex.lab=1.3, cex.axis=1.3) # black points with transparency

#plot(x = meta$F_ALL, y = meta$F_PS2, cex=1.5, pch=meta$ptype, col=alpha(meta$popcol,0.6), bg=alpha(meta$popcol,0.6),
#xlab=expression(paste(italic(F)[ngsF], " (metapopulation reference)", sep="")), ylab=expression(paste(italic(F)[ngsF], " (population-specific reference)", sep="")),
#main=NULL, cex.lab=1.3, cex.axis=1.3) # points with population information

abline(a=ngsf_refaf_model2$coefficients[1], b=ngsf_refaf_model2$coefficients[2], col="gray40")
abline(a=0,b=1,col="gray50",lty="dashed")
text(x=0.125,y=0.072,label=bquote(italic(r)^2 == .(round(summary(ngsf_refaf_model2)$r.square, digits=2))), cex=1.3)
#dev.off()


# II. Correlation between ngsF F estimated using population-specific allele frequencies (with relatedness pruning) vs metapopulation-wide allele frequencies (no relatedness pruning)

ngsf_refaf_model = lm(F_PS ~ F_ALL, data=meta)

summary(ngsf_refaf_model)
#
#Call:
#lm(formula = F_PS ~ F_ALL, data = meta)
#
#Residuals:
#      Min        1Q    Median        3Q       Max 
#-0.032360 -0.006532  0.000648  0.004977  0.033704 
#
#Coefficients:
#             Estimate Std. Error t value Pr(>|t|)    
#(Intercept) -0.005427   0.001505  -3.607 0.000522 ***
#F_ALL        0.684652   0.039429  17.364  < 2e-16 ***
#---
#Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1
#
#Residual standard error: 0.0104 on 85 degrees of freedom
#Multiple R-squared:  0.7801,   Adjusted R-squared:  0.7775 
#F-statistic: 301.5 on 1 and 85 DF,  p-value: < 2.2e-16

shapiro.test(resid(ngsf_refaf_model)) # errors depart slightly from normal distribution, so will bootstrap to test for significant correlation between F estimates
#
#       Shapiro-Wilk normality test
#
#data:  resid(ngsf_refaf_model)
#W = 0.93742, p-value = 0.0003887

ngsf_refaf.boot <- boot(data.frame(x=meta$F_ALL, y=meta$F_PS), getBeta1, R=10000, stype="i", sim="ordinary")
ngsf_refaf.ci <- boot.ci(ngsf_refaf.boot, conf=0.95, type=c("perc","bca"))

ngsf_refaf.ci
#BOOTSTRAP CONFIDENCE INTERVAL CALCULATIONS
#Based on 10000 bootstrap replicates
#
#CALL : 
#boot.ci(boot.out = ngsf_refaf.boot, conf = 0.95, type = c("perc", 
#    "bca"))
#
#Intervals : 
#Level     Percentile            BCa          
#95%   ( 0.4400,  0.8225 )   ( 0.4755,  0.8401 )  
#Calculations and Intervals on Original Scale

# plot relationship between ngsF F estimates

#png(file="/home/tyler/Dropbox/research/jay/mosaic/figures/methods_evaluation/ngsF_refAF_correlation.png")
par(mgp=c(2.65,1,0))
plot(x = meta$F_ALL, y = meta$F_PS, cex=1.5, pch=21, col="black", bg=alpha("grey40",0.6),
xlab=expression(paste(italic(F)[ngsF], " (metapopulation reference)", sep="")), ylab=expression(paste(italic(F)[ngsF], " (population-specific reference)", sep="")),
main=NULL, cex.lab=1.3, cex.axis=1.3)
abline(a=ngsf_refaf_model$coefficients[1], b=ngsf_refaf_model$coefficients[2], col="gray40")
abline(a=0,b=1,col="gray50",lty="dashed")
text(x=0.125,y=0.06,label=bquote(italic(r)^2 == .(round(summary(ngsf_refaf_model)$r.square, digits=5))), cex=1.3)
#dev.off()

# y-axis zoom
#png(file="/home/tyler/Dropbox/research/jay/mosaic/figures/methods_evaluation/ngsF_refAF_correlation_ylim_zoom.png")
par(mgp=c(2.65,1,0))
plot(x = meta$F_ALL, y = meta$F_PS, cex=1.5, pch=21, col="black", bg=alpha("grey40",0.6),
xlab=expression(paste(italic(F)[ngsF], " (metapopulation reference)", sep="")), ylab=expression(paste(italic(F)[ngsF], " (population-specific reference)", sep="")),
main=NULL, cex.lab=1.3, cex.axis=1.3, ylim=c(0,0.03))
abline(a=ngsf_refaf_model$coefficients[1], b=ngsf_refaf_model$coefficients[2], col="gray40")
abline(a=0,b=1,col="gray50",lty="dashed")
text(x=0.1,y=0.015,label=bquote(italic(r)^2 == .(round(summary(ngsf_refaf_model)$r.square, digits=5))), cex=1.3)
#dev.off()


# III. Correlation between Froh estimated using population-specific allele frequencies (estimated with r-pruning) vs metapopulation-wide allele frequencies (estimated with r-pruning)

froh_refaf_model = lm(FROH_PS ~ FROH_ALL, data=meta)
#
#Call:
#lm(formula = FROH_PS ~ FROH_ALL, data = meta)
#
#Residuals:
#       Min         1Q     Median         3Q        Max 
#-0.0110706 -0.0027381 -0.0002654  0.0032676  0.0140133 
#
#Coefficients:
#             Estimate Std. Error t value Pr(>|t|)    
#(Intercept) -0.002903   0.000984  -2.951   0.0041 ** 
#FROH_ALL     0.990166   0.009671 102.381   <2e-16 ***
#---
#Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1
#
#Residual standard error: 0.004142 on 85 degrees of freedom
#Multiple R-squared:  0.992,    Adjusted R-squared:  0.9919 
#F-statistic: 1.048e+04 on 1 and 85 DF,  p-value: < 2.2e-16

shapiro.test(resid(froh_refaf_model)) # errors are normally distributed
#
#       Shapiro-Wilk normality test
#
#data:  resid(froh_refaf_model)
#W = 0.98055, p-value = 0.2152

# plot relationship between Froh estimates (Figure S10, right panel)

#png(file="/home/tyler/Dropbox/research/jay/mosaic/figures/methods_evaluation/Froh_refAF_correlation.png", width=7, height=7, units='in', res=300)
par(mgp=c(2.65,1,0))
plot(x = meta$FROH_ALL, y = meta$FROH_PS, cex=1.5, pch=21, col="black", bg=alpha("grey40",0.6),
xlab=expression(paste(italic(F)[ROH], " (metapopulation reference)", sep="")), ylab=expression(paste(italic(F)[ROH], " (population-specific reference)", sep="")),
main=NULL, cex.lab=1.3, cex.axis=1.3)
abline(a=froh_refaf_model$coefficients[1], b=froh_refaf_model$coefficients[2], col="gray40")
abline(a=0,b=1,col="gray50",lty="dashed")
text(x=0.165,y=0.12,label=bquote(italic(r)^2 == .(round(summary(froh_refaf_model)$r.square, digits=5))), cex=1.3)
#dev.off()

# IV. Correlation between ngsF F and Froh using population specific allele frequencies (estimated with r-pruning).

fest_ps_model = lm(F_PS ~ FROH_PS, data=meta)

summary(fest_ps_model)
#
#Call:
#lm(formula = F_PS ~ FROH_PS, data = meta)
#
#Residuals:
#      Min        1Q    Median        3Q       Max 
#-0.027300 -0.006676 -0.000088  0.006165  0.068706 
#
#Coefficients:
#             Estimate Std. Error t value Pr(>|t|)    
#(Intercept) -0.021853   0.002981   -7.33 1.24e-10 ***
#FROH_PS      0.390414   0.030344   12.87  < 2e-16 ***
#---
#Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1
#
#Residual standard error: 0.01292 on 85 degrees of freedom
#Multiple R-squared:  0.6607,   Adjusted R-squared:  0.6567 
#F-statistic: 165.5 on 1 and 85 DF,  p-value: < 2.2e-16

shapiro.test(resid(fest_ps_model)) # errors slightly skewed so will bootstrap to test for significant correlation between F and Froh
#
#       Shapiro-Wilk normality test
#
#data:  resid(fest_ps_model)
#W = 0.86092, p-value = 1.539e-07

fest_ps.boot <- boot(data.frame(x=meta$FROH_PS, y=meta$F_PS), getBeta1, R=10000, stype="i", sim="ordinary")
fest_ps.ci <- boot.ci(fest_ps.boot, conf=0.95, type=c("perc","bca"))

fest_ps.ci
#BOOTSTRAP CONFIDENCE INTERVAL CALCULATIONS
#Based on 10000 bootstrap replicates
#
#CALL : 
#boot.ci(boot.out = fest_ps.boot, conf = 0.95, type = c("perc", 
#    "bca"))
#
#Intervals : 
#Level     Percentile            BCa          
#95%   ( 0.2409,  0.5109 )   ( 0.2745,  0.5534 )  
#Calculations and Intervals on Original Scale

# plot ngsF F versus Froh

#png(file="/home/tyler/Dropbox/research/jay/mosaic/figures/methods_evaluation/Festimator_pop_specific_ref_correlation.png")
par(mgp=c(2.65,1,0))
plot(x = meta$FROH_PS, y = meta$F_PS, cex=1.5, pch=21, col="black", bg=alpha("grey40",0.6),
xlab=expression(paste(italic(F)[ROH], sep="")), ylab=expression(paste(italic(F)[ngsF], sep="")),
main=NULL, cex.lab=1.3, cex.axis=1.3)
abline(a=fest_ps_model$coefficients[1], b=fest_ps_model$coefficients[2], col="gray40")
abline(a=0,b=1,col="gray50",lty="dashed")
text(x=0.2,y=0.005,label=bquote(italic(r)^2 == .(round(summary(fest_ps_model)$r.square, digits=5))), cex=1.3)
#dev.off()

# V. Correlation between ngsF F and Froh estimated using metapopulation-wide allele frequencies.

# Note that allele frequencies in the ngsF analysis were estimated without relatedness pruning while the allele frequencies
# for the Froh analysis were estimated with relatedness pruning.

fest_model = lm(F_ALL ~ FROH_ALL, data=meta)

summary(fest_model)
#
#Call:
#lm(formula = F_ALL ~ FROH_ALL, data = meta)
#
#Residuals:
#      Min        1Q    Median        3Q       Max 
#-0.030962 -0.004870  0.000180  0.005008  0.049092 
#
#Coefficients:
#             Estimate Std. Error t value Pr(>|t|)    
#(Intercept) -0.026737   0.002391  -11.18   <2e-16 ***
#FROH_ALL     0.576623   0.023502   24.54   <2e-16 ***
#---
#Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1
#
#Residual standard error: 0.01006 on 85 degrees of freedom
#Multiple R-squared:  0.8763,   Adjusted R-squared:  0.8748 
#F-statistic:   602 on 1 and 85 DF,  p-value: < 2.2e-16

shapiro.test(resid(fest_model)) # errors deviate slightly from normal distribution so will bootstrap to test for significant correlation between ngsF F and Froh
#
#       Shapiro-Wilk normality test
#
#data:  resid(fest_model)
#W = 0.89818, p-value = 4.665e-06


fest.boot <- boot(data.frame(x=meta$FROH_ALL, y=meta$F_ALL), getBeta1, R=10000, stype="i", sim="ordinary")
fest.ci <- boot.ci(fest.boot, conf=0.95, type=c("perc","bca"))

fest.ci
#BOOTSTRAP CONFIDENCE INTERVAL CALCULATIONS
#Based on 10000 bootstrap replicates
#
#CALL : 
#boot.ci(boot.out = fest.boot, conf = 0.95, type = c("perc", "bca"))
#
#Intervals : 
#Level     Percentile            BCa          
#95%   ( 0.4801,  0.6711 )   ( 0.4976,  0.7000 )  
#Calculations and Intervals on Original Scale

# plot ngsF F versus Froh

#png(file="/home/tyler/Dropbox/research/jay/mosaic/figures/methods_evaluation/Festimator_metapop_ref_correlation.png")
par(mgp=c(2.65,1,0))
plot(x = meta$FROH_ALL, y = meta$F_ALL, cex=1.5, pch=21, col="black", bg=alpha("grey40",0.6),
xlab=expression(paste(italic(F)[ROH], sep="")), ylab=expression(paste(italic(F)[ngsF], sep="")),
main=NULL, cex.lab=1.3, cex.axis=1.3)
abline(a=fest_model$coefficients[1], b=fest_model$coefficients[2], col="gray40")
abline(a=0,b=1,col="gray50",lty="dashed")
text(x=0.2,y=0.04,label=bquote(italic(r)^2 == .(round(summary(fest_model)$r.square, digits=5))), cex=1.3)
#dev.off()

--- end R code ---


#
#
#


## ---------- PRINCIPAL COMPONENT ANALYSIS ---------- ##

# Estimate genetic covariance among all individuals

Calculate genotype posterior probabilities using a HWE prior.

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/popgen/genotypes/genotype_post_prob.sh
implements:

--- start bash code ---

BAMLIST='/mnt/research/Fitz_Lab/projects/mosaic/map/mosaic_bam_list.txt'
REGFILE='/mnt/research/Fitz_Lab/ref/bird/FSJ_V3/FSJ_V3_main_autosomes.txt'
SITESFILE='/mnt/research/Fitz_Lab/projects/mosaic/variants/vcf/biallelic_snps/fsj_mosaic_biallelic_snps_main_autosomes_qc.pos'
OUTPREFIX='/mnt/research/Fitz_Lab/projects/mosaic/popgen/genotypes/fsj_mosaic_biallelic_snps_main_autosomes_qc_all'

angsd -bam $BAMLIST -out $OUTPREFIX -GL 1 -doGeno 32 -doPost 1 -doMajorMinor 1 -doMaf 1 -minQ 20 -minMapQ 20 -rf $REGFILE -sites $SITESFILE -P 16

--- end bash code ---

Estimate genetic covariance based on genotype posterior probabilities and using a 2% MAF cutoff.

$ sbatch /mnt/research/Fitz_Lab/projects/mosaic/popgen/pca/covar_mat_unweighted.sh
implements:

--- start bash code ---

GENOFILE='/mnt/research/Fitz_Lab/projects/mosaic/popgen/genotypes/fsj_mosaic_biallelic_snps_main_autosomes_qc_all.geno'
OUTPUT='/mnt/research/Fitz_Lab/projects/mosaic/popgen/pca/fsj_mosaic_biallelic_snps_main_autosomes_qc_all_unweighted.covar'

CMD="ngsCovar -probfile $GENOFILE -outfile $OUTPUT -nind 87 -nsites 2049176 -norm 0 -call 0 -minmaf 0.02"

printf "\n%s\n\n" "$CMD"

eval $CMD

--- end bash code ---

Calculate eigen vectors and values and visualize PCA

--- start R code ---

# read in covariance matrix and perform eigen decomposition on it

covar <- as.matrix(read.table('/home/tyler/Dropbox/research/jay/mosaic/popgen/pca/fsj_mosaic_biallelic_snps_main_autosomes_qc_all_unweighted.covar',head=FALSE))
eig <- eigen(covar) # PCs
var <- round((eig$values/sum(eig$values))*100, digits=2) # variance explained by PCs

# set plotting values

meta <- read.table('/home/tyler/Dropbox/research/jay/mosaic/metadata/M4_sequenced_FSJsamples_metadata.txt',head=TRUE,sep="\t")
meta$letter_code <- pointletters(meta)
meta$grpcol <- pntcol(meta)
meta$popcode <- popletters(meta)
meta$popcol <- popcolor(meta)

# Add color band IDs to metadata data.frame
jayid <- read.csv('/home/tyler/Dropbox/research/jay/mosaic/metadata/jayid_map_20230512.txt',head=TRUE,sep="\t") # this is just a data.frame to map between USFWS, color band, and Fitz Lab IDs
meta$COLOR_ID = unname(sapply(meta$LAB_ID,function(x,df){id=df$COLOR_ID[which(df$LAB_ID == x)]; ifelse(id=="*",x,id)},df=jayid)) # uses M4 Fitz Lab IDs since the M4 birds don't have color IDs

# visualize PCAs

# The following PCAs were just used as exploratory analyses (not for final figures/results)

# plot PCA using type (i.e. E, C, T, I, M4) text as points and colored by type
#pdf(file='/home/tyler/Dropbox/research/jay/mosaic/popgen/pca/plots/mosaic_fsj_locality_colors2_print.pdf',width=8,height=8)
i = 1
while (i < 7) {
	j = i+1
	par(mar=c(5.1,4.1,4,2)+0.1)
	plot(x=eig$vectors[,i], y=eig$vectors[,j], xlab=paste0("PC",i,", ",var[i],"%"), ylab=paste0("PC",j,", ",var[j],"%"), type="n", cex.axis=1.4, cex.lab=1.4)
	text(x=eig$vectors[,i],y=eig$vectors[,j], labels = meta$letter_code, col=meta$grpcol, cex=1.2)
	if (i == 1) legend('topleft',fill=c(meta$grpcol[which(meta$type == "E")[1]], meta$grpcol[which(meta$type == "C")[1]], meta$grpcol[which(meta$type == "T")[1]], meta$grpcol[which(meta$type == "M4")[1]], meta$grpcol[which(meta$type == "I")[1]]), c("E","C","T","M4","U"),bty="n", horiz=TRUE, cex=1.3)
	i = i+2
}
#dev.off()

# plot PCA using individual Fitz Lab ID text as points colored by population
#pdf(file='/home/tyler/Dropbox/research/jay/mosaic/popgen/pca/plots/mosaic_fsj_individual_popcol.pdf',width=8,height=8)
i = 1
while (i < 13) {
        j = i+1
        plot(x=eig$vectors[,i], y=eig$vectors[,j], xlab=paste0("PC",i,", ",var[i],"%"), ylab=paste0("PC",j,", ",var[j],"%"), type="n")
        #text(x=eig$vectors[,i],y=eig$vectors[,j], labels = meta$LAB_ID, col=meta$grpcol, cex=0.6) # group coloring
        text(x=eig$vectors[,i],y=eig$vectors[,j], labels = meta$LAB_ID, col=meta$popcol, cex=0.6) # pop coloring
        #if (i == 1) legend('topleft',fill=c(meta$grpcol[which(meta$type == "E")[1]], meta$grpcol[which(meta$type == "C")[1]], meta$grpcol[which(meta$type == "T")[1]], meta$grpcol[which(meta$type == "M4")[1]], meta$grpcol[which(meta$type == "I")[1]]), c("E","C","T","M4","I"),bty="n", horiz=TRUE, cex=0.8)
        i = i+2
}
#dev.off()

# plot PCA using population code text colored by population
idx.wellfield = which(meta$pop == "Resident" | meta$pop == "Contemporary")
#pdf(file='/home/tyler/Dropbox/research/jay/mosaic/popgen/pca/plots/mosaic_fsj_pop.pdf',width=8,height=8)
i=1
while (i < 13) {
	j = i+1
	par(mar=c(5.1,4.1,4,2)+0.1)
	plot(x=eig$vectors[,i], y=eig$vectors[,j], xlab=paste0("PC",i,", ",var[i],"%"), ylab=paste0("PC",j,", ",var[j],"%"), type="n", cex.axis=1.4, cex.lab=1.4)
	# text is added in two steps just so that wellfield points are on top
	text(x=eig$vectors[-idx.wellfield,i],y=eig$vectors[-idx.wellfield,j], labels = meta$popcode[-idx.wellfield], col=meta$popcol[-idx.wellfield], cex=1.2)
	text(x=eig$vectors[idx.wellfield,i],y=eig$vectors[idx.wellfield,j], labels = meta$popcode[idx.wellfield], col=meta$popcol[idx.wellfield], cex=1.2)
	i = i+2
}
#dev.off()

# plot amount of variance explained by each PC
#pdf(file='/home/tyler/Dropbox/research/jay/mosaic/popgen/pca/plots/mosaic_fsj_pca_variance_explained.pdf',width=7,height=7)
n = length(eig$vector[,1])
for (i in 0:2) {
	barplot(var,ylab="% variance explained", xlab="PCs", names.arg=1:n,col=c(rep("gray",i*2),rep("plum4",2),rep("gray",n-(2*(i+1)))))
}
#dev.off()

# The following PCA was used for finalized inferences.

# Plot PC1 vs PC2 with individuals labeled according to biological origin. This is the PCA displayed in the paper - Figure 3A

meta$biopoint <- biopoint(meta$pop)
rswk.idx = which(meta$COLOR_ID == "RSW-K")
#meta$biopoint[rswk.idx] <- 22 # RSW-K was from Site 1B and immigrated into Little Manatee State Park (not part of The Core and was not translocated).

pc1.scale = var[1]/var[2]
axis.height = 8
axis.width = axis.height * pc1.scale

# shape points
x11(width=axis.width,height=axis.height)
#png(file='/home/tyler/Dropbox/research/jay/mosaic/figures/pca_pop_colors.png',width=axis.width, height=axis.height, units='in', res=300)
par(mar=c(5.1,4.1,4,2)+0.1)
plot(x=eig$vectors[,1], y=eig$vectors[,2], xlab=paste0("PC",1,", ",var[1],"%"), ylab=paste0("PC",2,", ",var[2],"%"),cex.axis=1.4, cex.lab=1.4,
pch=meta$biopoint, col=meta$popcol, bg=alpha(meta$popcol,0.65), cex=1.7, lwd=1.2)
points(x=eig$vectors[rswk.idx,1], y=eig$vector[rswk.idx,2], pch=3, cex=1.3, col="grey20", lwd=1.5)

#dev.off()

# text points
x11(width=axis.width,height=axis.height)
#png(file='/home/tyler/Dropbox/research/jay/mosaic/figures/pca_pop_colors_text.png',width=axis.width, height=axis.height, units='in', res=300)
par(mar=c(5.1,4.1,4,2)+0.1)
plot(x=eig$vectors[,1], y=eig$vectors[,2], xlab=paste0("PC",1,", ",var[1],"%"), ylab=paste0("PC",2,", ",var[2],"%"),cex.axis=1.4, cex.lab=1.4, type="n")
text(x=eig$vectors[,1],y=eig$vectors[,2], labels = meta$COLOR_ID, col=meta$popcol, cex=0.5)

#dev.off()

--- end R code ---


#
#
#


## ---------- PEDIGREE SKEW ANALYSIS ---------- ##

## Generate pedigree

# Extract census data for only the core population (Mosaic Wellfield + Duette Preserve + Coker Tract) from metadata.

--- begin R code for extracting core pop individuals ---

census <- read.csv(/home/tyler/Dropbox/research/jay/mosaic/metadata/20230512_metadata/Longform_Data_05122023.tsv',head=TRUE,sep="\t")
core <- census[which(census$PROPERTY == "MW" | census$PROPERTY == "DUETTE PRESERVE" | census$PROPERTY == "COKER"),]
core.ids <- toupper(unique(core$COLOR_ID)) # unique set of IDs for birds censused in the core region
write.table(data.frame(ID=core.ids),file='/home/tyler/Dropbox/research/jay/mosaic/metadata/20230512_metadata/core_pop/core_pop_color_ids.txt',col.names=FALSE,row.names=FALSE,quote=FALSE)
write.table(core,file='/home/tyler/Dropbox/research/jay/mosaic/metadata/20230512_metadata/core_pop/Longform_Data_05122023_core.tsv',col.names=TRUE,row.names=FALSE,quote=FALSE,sep="\t")

--- end R code for extracting core pop individuals ---

# Make inputs for makePed.pl, which constructs the pedigree in ped format.

--- begin R code for formatting census data ---
census <- read.csv('/home/tyler/Dropbox/research/jay/mosaic/metadata/20230512_metadata/Longform_Data_05122023.tsv',head=TRUE,sep="\t")
census.sub <- census[which(census$Present == 1),]
write.table(census.sub[,c(1,2,3,4,5,12)],file='/home/tyler/Dropbox/research/jay/mosaic/pedigree/mosaic_census_20230512.tsv',col.names=TRUE,row.names=FALSE,sep="\t",quote=FALSE)
--- end R code for formatting census data ---

--- start bash code ---

cut -f2,3,12 /home/tyler/Dropbox/research/jay/mosaic/metadata/20230512_metadata/CUMULATIVE_NESTING_DATA_FINAL_05122023.tsv | sed -s 's/\t/,/g' > cumulative_nesting_data_20230512.csv
cut -f1,2,5,10,16,17 /home/tyler/Dropbox/research/jay/mosaic/metadata/20230512_metadata/JAYID_05122023.tsv | sed -s 's/\t/,/g' > jayid_20230512.csv

--- end bash code ---

## Expected genetic contribution based on the pedigree

# Calculate pairwise relatedness from the pedigree

Make pedigree input for nadiv R package to calculate pedigree-based relatedness.

--- start bash code ----

./makePed.pl jayid_20230512.csv cumulative_nesting_data_20230512.csv mosaic_census_20230512.tsv 2> ./troubleshoot/mosaic_ped_20230512_raw_warnings.txt > mosaic_ped_20230512_raw.csv

--- end bash code ---

Manually modified the pedigree in some instances for the following individuals per Lauren's notes:

SR-LK (1063-09904): cohort_last set to 2004 per Lauren's notes "banded as HY august 2004 and never seen again".
OK-OS (1573-41864): Did not change missing survival data as I only see it recorded in Site 18. Luaren's notes "banded June 2004 and not seen on the July 2004 census or thereafter".
GF-SG (1713-54398): set cohort and cohort_last to 2016 per Lauren's notes "banded as immigrant in 2016 and never observed on a census" and this bird nested in DP.
PF-LS (1713-82944): Did not change missing survival data per Lauren's notes "rutland bird - never on census"
GF-AS (1713-82946): Did not change missing surivial data per Lauren's notes "rutland bird - never on census"
LDZ-F (1873-26844): set cohort_last to individuals year class (2021) per Lauren's notes "banded as Hy and never seen again"
BDZ-F (1873-26845): set cohort_last to individuals year class (2021) per Lauren's notes "banded as Hy and never seen again"
WDZ-F (1873-26846): set cohort_last to individuals year class (2021) per Lauren's notes "banded as Hy and never seen again"

# Set cohort and population for translocated pedigree individuals to year of translocation and donor patch respectively.

--- begin R code for reconciling translocation with pedigree data ---

ped <- read.csv('/home/tyler/Dropbox/research/jay/mosaic/pedigree/mosaic_ped_20230512_raw.csv',head=TRUE, na.strings="*")
trans <- read.csv('/home/tyler/Dropbox/research/jay/mosaic/metadata/Translocated_Jay_Individual_Statistics.tsv',head=TRUE,sep="\t",na.strings="*")
trans$COLOR_ID[which(trans$COLOR_ID == "PK-AS")] <- "PK-OS" # Laurens notes in the cumulative nest data say that "PK-AS and PK-OS are the same bird. Did not have any more orange bands at the time of capture and replaced with azure".
trans$Donor_Patch <- gsub(" ", "_", trans$Donor_Patch)
for (i in 1:nrow(trans)) {
	id <- trans$COLOR_ID[i]
	yr <- trans$Year_Translocated[i]
	patch <- trans$Donor_Patch[i]
	idx <- which(ped$ID == id)
	if (length(idx) > 0) {
		ped$COHORT[idx] = yr
		ped$POPULATION[idx] = patch
	} else {
		print(paste0("Could not find ", id, " in pedigree"))
	}
}

# if last observation year is missing set it to the first observation year to indicate bird was censused once and never seen again
for (i in 1:nrow(ped)) {
	if (!is.na(ped$COHORT[i]) && is.na(ped$COHORT_LAST[i])) ped$COHORT_LAST[i] = ped$COHORT[i]
}

# write full M4 pedigree
write.table(ped,file='/home/tyler/Dropbox/research/jay/mosaic/pedigree/mosaic_ped_20230512.csv',col.names=TRUE,row.names=FALSE,quote=FALSE,na="*",sep=",")
write.table(ped,file='/home/tyler/Dropbox/research/jay/mosaic/pedigree/mosaic_ped_20230512.tsv',col.names=TRUE,row.names=FALSE,quote=FALSE,na="*",sep="\t")

# write core population pedigree
core <- ped[which(!is.na(ped$COHORT)),] # individuals never censused in (i.e. part of) the Core Region will have missing COHORT because this is the first time censused in the Core

write.table(core,file='/home/tyler/Dropbox/research/jay/mosaic/pedigree/cr_ped_20230512.csv',col.names=TRUE,row.names=FALSE,quote=FALSE,na="*",sep=",")
write.table(core,file='/home/tyler/Dropbox/research/jay/mosaic/pedigree/cr_ped_20230512.tsv',col.names=TRUE,row.names=FALSE,quote=FALSE,na="*",sep="\t")

--- end R code for reconciling translocation with pedigree data ---


Make additive genetic relatedness matrix based on pedigree

--- start R code for pedigree-based relatedness matrix ---

# load required packages
library(nadiv)

# read in and format pedigree
# using full M4 pedigree to account for relatdness among CR founders
ped.raw <- read.csv('/home/tyler/Dropbox/research/jay/mosaic/pedigree/mosaic_ped_20230512.csv',head=TRUE)

ped2 <- prepPed(ped.raw[,1:4], gender='SEX', check=TRUE)
ped2 <- ped2[,1:3]

# calculate additive genetic matrix
r_mat <- makeA(ped2)
r_mat2 <- as.matrix(r_mat) # convert sparse dsCMatrix into normal matrix

# ouput full m4 matrix
write.table(r_mat2,file='/home/tyler/Dropbox/research/jay/mosaic/pedigree/mosaic_ped_20230512_relatedness_matrix.txt',col.names=TRUE,row.names=FALSE,quote=FALSE)

# subset matrix down to only Core Region individuals
core <- read.table('/home/tyler/Dropbox/research/jay/mosaic/pedigree/cr_ped_20230512.tsv',head=TRUE)
core.idx <- which(colnames(r_mat2) %in% core$ID == TRUE)
r_mat.core <- r_mat2[core.idx,core.idx]
write.table(r_mat.core,file='/home/tyler/Dropbox/research/jay/mosaic/pedigree/cr_ped_20230512_relatedness_matrix.txt',col.names=TRUE,row.names=FALSE,quote=FALSE)

--- end R code for pedigree-based relatedness matrix ---


## Expected genetic contribution to 2021 cohort with relateStats

Make inputs for relateStats

--- begin R code for making relateStats inputs ---

jaymeta <- read.csv('~/Dropbox/research/jay/mosaic/metadata/20230512_metadata/JAYID_05122023.tsv',head=TRUE,sep="\t")
jaymeta$COLOR_ID <- toupper(jaymeta$COLOR_ID)
core <- read.table('~/Dropbox/research/jay/mosaic/pedigree/cr_ped_20230512.tsv',head=TRUE) # for screening individuals that were not present in the Core Region
ind.e <- data.frame(ID=c("SW-RK", "SW-OKB", "SW-LK", "SR-WK", "SW-BK", "K-SRB")) # individuals classified as Residents in the genetic data and LR in the jayID metadata


# make file of T and IE ancestors
anc1 <- data.frame(ID=jaymeta$COLOR_ID[which(jaymeta$Biological_Origin_Status == "T" | jaymeta$Biological_Origin_Status == "IE")])
anc1 <- rbind(anc1,ind.e)
anc1.core <- data.frame(ID = anc1$ID[which(anc1$ID %in% core$ID)])
write.table(anc1.core,file='/home/tyler/Dropbox/research/jay/mosaic/pedigree/relateStat_inputs/CR_T_IE_ancestors_20230512.txt',col.names=FALSE,row.names=FALSE,quote=FALSE)

# make file of sequenced contemporary color band IDs

seqmeta <- read.table('~/Dropbox/research/jay/mosaic/metadata/M4_sequenced_FSJsamples_metadata.txt',head=TRUE,sep="\t")
c_seq_ids <- unname(sapply(seqmeta$USFWS_ID[which(seqmeta$pop == "Contemporary")],function(x,df){df$COLOR_ID[which(df$FEDERAL_ID == x)]},df=jaymeta))
write.table(data.frame(id=c_seq_ids),file='/home/tyler/Dropbox/research/jay/mosaic/pedigree/relateStat_inputs/CR_sequenced_contemporary_ids_20230512.txt',col.names=FALSE,row.names=FALSE,quote=FALSE)

# make files of local recruits (LR) by year class
jaymeta$YEAR_CLASS[which(jaymeta$YEAR_CLASS == "Unknown_Adult" | jaymeta$YEAR_CLASS == "unknown" | jaymeta$YEAR_CLASS == "*")] <- NA # mask unknown year classes
jaymeta$YEAR_CLASS <- as.numeric(jaymeta$YEAR_CLASS)
lr <- jaymeta[which(jaymeta$Biological_Origin_Status == "LR"),] # subset of local recruits
lr <- lr[which(lr$Natal_Patch == "MW" | lr$Natal_Patch == "DP" | lr$Natal_Patch == "COKER"),] # ensure all individuals were born in Core Region
lr <- lr[-grep("UNBAND|MWUUNB",lr$COLOR_ID),] # remove unbanded individuals

for (i in min(lr$YEAR_CLASS,na.rm=TRUE):max(lr$YEAR_CLASS,na.rm=TRUE)){
	id <- lr$COLOR_ID[which(lr$YEAR_CLASS == i)]
	if (length(id) > 0 ) {
		write.table(data.frame(ID=id),file=paste0('/home/tyler/Dropbox/research/jay/mosaic/pedigree/relateStat_inputs/CR_LR_ids_20230512_',i,'.txt'),col.names=FALSE,row.names=FALSE,quote=FALSE)
	}
}

--- end R code for making relateStats inputs ---


NOTE: All of the following samples (except RSW-K) considered residents in the genetic analyses were missing among the T, IE, and I ancestors so 
were manually added to the ancestors list file: /home/tyler/Dropbox/research/jay/mosaic/pedigree/relateStat_inputs/CR_T_IE_ancestors_20230512.txt.

SW-RK (LR)
SW-OKB (LR)
SW-LK (LR)
SR-WK (LR)
SW-BK (LR)
K-SRB (LR)
RSW-K (Donor Population, T_072 in the genetic data) was not translocated into the Core Region. This bird was from Site 1B and immigrated into Little Manatee State Park (which is not part of the Core)

## Calculate expected genetic contributions from Mosaic pedigree with relateStats

Abbreviations:
T = translocated.
IE = AHY bird banded in Mosaic Wellfield in 2002 prior to translocations (residents).
I = unbanded (excluded from skew analyses).

Calculate contribution of T and IE ancestors to population from 2002 (oldest cohort) to 2022 (most recent cohort).

--- start bash code ---

for i in {2002..2022}; do echo "$i"; ~/code_projects/PopGenomicsTools/relateStats --pedstat 1 --ped cr_ped_20230512.tsv --rmat cr_ped_20230512_relatedness_matrix.txt --anc ./relateStat_inputs/CR_T_IE_ancestors_20230512.txt --time2 "$i" --draw --out "./results/pop_temporal/T_IE_20230512_${i}_pop_contribution" 2> "./results/pop_temporal/T_IE_20230512_${i}_pop_contribution.log"; wait; done

--- end bash code ---


Calculate contribution of T and IE ancestors to local recruits born in 2004 (first local recruit) to 2022 (latest local recruit cohort).

--- start bash code ---

for i in {2004..2022}; do COHORT_FILE="./relateStat_inputs/CR_LR_ids_20230512_${i}.txt"; echo "$COHORT_FILE"; ~/code_projects/PopGenomicsTools/relateStats --pedstat 1 --ped cr_ped_20230512.tsv --rmat cr_ped_20230512_relatedness_matrix.txt --anc ./relateStat_inputs/CR_T_IE_ancestors_20230512.txt --cohort "$COHORT_FILE" --draw --out "./results/lr_temporal/T_IE_20230512_to_${i}_LR_contribution" 2> "./results/lr_temporal/T_IE_20230512_to_${i}_LR_contribution.log"; wait; done

--- end bash code ---


Calculate contribution of T and IE ancestors to sequenced contemporary individuals.

--- start bash code ---

$ ~/code_projects/PopGenomicsTools/relateStats --pedstat 1 --ped cr_ped_20230512.tsv --rmat cr_ped_20230512_relatedness_matrix.txt --anc ./relateStat_inputs/CR_T_IE_ancestors_20230512.txt --cohort ./relateStat_inputs/CR_sequenced_contemporary_ids_20230512.txt --draw --out ./results/sequenced_contemporary/T_IE_20230512_to_seq_contemporary 2> ./results/sequenced_contemporary/T_IE_20230512_to_seq_contemporary.log

--- end bash code ---


## Plots of expected genetic contribution by CR ancestors to CR population through time

--- begin R code for T and IE temporal contributions to population ---

library(scales) # for alpha colors
library(ggplot2)
library(ggpattern)

meta <- read.table("/home/tyler/Dropbox/research/jay/mosaic/metadata/jayid_map_20230512.txt",head=TRUE,sep="\t")
fdir='/home/tyler/Dropbox/research/jay/mosaic/pedigree/results/pop_temporal/'
ped <- read.table('/home/tyler/Dropbox/research/jay/mosaic/pedigree/cr_ped_20230512.tsv', head=TRUE, na.strings='*')

pop.n <- NULL # data frame of number of expected genomic copies
pop.pfocal <- NULL # data frame of contributions normalized by focal ancestors
pop.pmax <- NULL # data frame of contribution normalized by max cohort pop contribution

# read in pedstat files for time points 2002-2022

time.periods = 2002:2022

# subset time periods for plots that follow so that they span years 2003-2022 (exclude 2002)
time.periods2 <- time.periods[2:length(time.periods)]

tidx <- 2:(length(time.periods)+1) # these are the contribution columns in matrix
id <- NULL
for (t in time.periods) {
	df <- read.table(paste0(fdir,'T_IE_20230512_',t,'_pop_contribution.pedstat1'),head=TRUE)
	if (is.null(id)) id <- df[,1]
	pop.n <- cbind(pop.n, df[,2])
	pop.pfocal <- cbind(pop.pfocal, df[,3])
	pop.pmax <- cbind(pop.pmax, df[,4])
}

# mask values of individuals if they weren't born
ped.sub <- ped[which(ped$ID %in% id),c(1,5)]
ped.sub <- ped.sub[match(id,ped.sub$ID),]
for (i in 1:length(time.periods)) {
	t = time.periods[i]
	idx <- which(ped.sub$COHORT > t)
	if (length(idx) > 0) {
		pop.n[idx,i] <- NA
		pop.pfocal[idx,i] <- NA
		pop.pmax[idx,i] <- NA	
	}
}

# NOTE: Recalculating proportions here such that they sum to 1 because KRS- and SR-PK sired translocated individuals
# prior to arriving in the Wellfield in 2005 and 2009, respectively. Counting contributions AFTER existing in 
# the CR makes the total contribution of ancestors <1. Therefore, resumming to count only the contributions
# of individuals after they arrive in the CR (after masking has been applied). Total ancestor contribution will now be 1.

for (i in 1:ncol(pop.pfocal)) {
	pop.pfocal[,i] <- pop.pfocal[,i]/sum(pop.pfocal[,i], na.rm=TRUE)
}

#
#

pop.n <- cbind(data.frame(ID=id),as.data.frame(pop.n)) # add sample names
colnames(pop.n) <- c("ID",paste0("cohort.",time.periods))

pop.pfocal <- cbind(data.frame(ID=id),as.data.frame(pop.pfocal)) # add sample names
colnames(pop.pfocal) <- c("ID",paste0("cohort.",time.periods))

pop.pmax <- cbind(data.frame(ID=id),as.data.frame(pop.pmax)) # add sample names
colnames(pop.pmax) <- c("ID",paste0("cohort.",time.periods))

## Descriptions of the genetic contribtuion of ancestors to the CR population

anc.contributors <- NULL
for (i in 1:length(time.periods)) {
	j <- i+1
	nexist <- length(which(!is.na(pop.pfocal[,j])))
	n <- length(which(pop.pfocal[,j] > 0))
	anc.contributors <- rbind(anc.contributors, data.frame(year=time.periods[i], N=n, Percent=((n/nexist)*100),N_EXIST=nexist))
}

anc.contributors
#   year  N   Percent N_EXIST
#1  2002  4 100.00000       4
#2  2003 20 100.00000      20
#3  2004 29  82.85714      35
#4  2005 20  51.28205      39
#5  2006 11  28.20513      39
#6  2007 14  33.33333      42
#7  2008 27  46.55172      58
#8  2009 28  43.75000      64
#9  2010 35  47.29730      74
#10 2011 32  43.24324      74
#11 2012 32  43.24324      74
#12 2013 30  40.54054      74
#13 2014 30  40.54054      74
#14 2015 29  39.18919      74
#15 2016 29  39.18919      74
#16 2017 26  35.13514      74
#17 2018 25  33.78378      74
#18 2019 25  33.78378      74
#19 2020 25  33.78378      74
#20 2021 25  33.78378      74
#21 2022 25  33.78378      74

# number of contributing ancestors out of the potential number of ancestral lineages over time
anc.df <- NULL
for (i in 1:nrow(anc.contributors)) {
	anc.df <- rbind(anc.df, data.frame(year=anc.contributors$year[i], count="total", N=anc.contributors$N_EXIST[i]))
	anc.df <- rbind(anc.df, data.frame(year=anc.contributors$year[i], count="contributors", N=anc.contributors$N[i]))
}

anc.df$count <- factor(anc.df$count, levels=c("total", "contributors"))
anc.df.sub <- anc.df[which(anc.df$year > 2002),] # only plot years 2003+

# average and maximum contributions of specific lineages

# RLKS-K from 2008-2022
mean(as.matrix(pop.pfocal[which(pop.pfocal$ID == "RLS-K"),which(colnames(pop.pfocal) == "cohort.2008"):which(colnames(pop.pfocal) == "cohort.2022")])) # mean
# [1] 0.1339778 # mean
sd(as.matrix(pop.pfocal[which(pop.pfocal$ID == "RLS-K"),which(colnames(pop.pfocal) == "cohort.2008"):which(colnames(pop.pfocal) == "cohort.2022")])) # stanard deviation
# [1] 0.03263044 # standard deviation
max(as.matrix(pop.pfocal[which(pop.pfocal$ID == "RLS-K"),which(colnames(pop.pfocal) == "cohort.2008"):which(colnames(pop.pfocal) == "cohort.2022")])) # max
#[1] 0.1730849 # max

# WSA-K from 2008-2022
mean(as.matrix(pop.pfocal[which(pop.pfocal$ID == "WSA-K"),which(colnames(pop.pfocal) == "cohort.2008"):which(colnames(pop.pfocal) == "cohort.2022")])) # mean
# [1] 0.1041607 # mean
sd(as.matrix(pop.pfocal[which(pop.pfocal$ID == "WSA-K"),which(colnames(pop.pfocal) == "cohort.2008"):which(colnames(pop.pfocal) == "cohort.2022")])) # standard deviation
# [1] 0.03203001 # standard deviation
max(as.matrix(pop.pfocal[which(pop.pfocal$ID == "WSA-K"),which(colnames(pop.pfocal) == "cohort.2008"):which(colnames(pop.pfocal) == "cohort.2022")])) # max
# [1] 0.149241 # max

# mean contribution for all individuals since 2008
avg.contribution <- NULL
for (id2 in pop.pfocal$ID) {
	val <- mean(as.matrix(pop.pfocal[which(pop.pfocal$ID == id2),which(colnames(pop.pfocal) == "cohort.2008"):which(colnames(pop.pfocal) == "cohort.2022")]), na.rm=TRUE)
	avg.contribution <- rbind(avg.contribution, data.frame(ID=id2, AVG_PROPORTION=val))
}

avg.contribution <- avg.contribution[order(-avg.contribution$AVG_PROPORTION),]

head(avg.contribution, n=16)
#      ID AVG_PROPORTION
#44 RLS-K     0.13397785
#5  WSA-K     0.10416071
#46 OK-RS     0.05648191
#22 K-SLA     0.05161644
#60 SK-RG     0.04947236
#53 BK-FS     0.04824063
#45 BK-AS     0.04575711
#1  SR-PK     0.04531992
#8  K-RSW     0.03753052
#40 BK-LS     0.03660300
#4  WSF-K     0.03217750
#23 K-SBF     0.02936139
#14 LK-SG     0.02834174
#17 AK-SP     0.02629410
#7  K-GSW     0.02488999
#66 F-BPS     0.02471368

# average collective contribution of RLS-K and WSA-K since 2008
rlsk.idx = which(pop.pfocal$ID == "RLS-K")
wsak.idx = which(pop.pfocal$ID == "WSA-K")
comb.contribution <- NULL
for (tidx in which(colnames(pop.pfocal) == "cohort.2008"):which(colnames(pop.pfocal) == "cohort.2022")) {
	comb.contribution = c(comb.contribution,pop.pfocal[rlsk.idx,tidx] + pop.pfocal[wsak.idx,tidx])
}
mean(comb.contribution)
# [1] 0.2381386 # mean
sd(comb.contribution)
#[1] 0.06403289 # standard deviation
max(comb.contribution)
#[1] 0.322263 # max

# Proportion of genomic copies contributed by the top 16 contributors in 2022

ntop = 16
# pop.pfocal row indices of the top contributors in 2022 
topidx = unname(sapply(pop.pfocal[order(-pop.pfocal$cohort.2022),1][1:ntop],function(x,df){which(df$ID == x)},df=pop.pfocal))
# calculate the sum of the top contributor's genomic contribution for each year
top.contribution <- NULL
for (i in 1:length(time.periods)) {
	top.contribution <- rbind(top.contribution, data.frame(YEAR=time.periods[i], PROPORTION_GENOMIC_COPIES = sum(pop.pfocal[topidx,i+1], na.rm=TRUE)))
}

top.contribution
#   YEAR PROPORTION_GENOMIC_COPIES
#1  2002                 0.2500000
#2  2003                 0.2000000
#3  2004                 0.1707317
#4  2005                 0.3076927
#5  2006                 0.4999996
#6  2007                 0.5270272
#7  2008                 0.6368874
#8  2009                 0.7583543
#9  2010                 0.6504852
#10 2011                 0.6963268
#11 2012                 0.6982892
#12 2013                 0.6773675
#13 2014                 0.7156768
#14 2015                 0.7716050
#15 2016                 0.7612648
#16 2017                 0.7900778
#17 2018                 0.8003363
#18 2019                 0.8580870
#19 2020                 0.8346470
#20 2021                 0.8618459
#21 2022                 0.8802618

# minimum contribution since 2015
min(top.contribution[which(top.contribution$YEAR == 2015):nrow(top.contribution),2])
# [1] 0.7612648


## set plotting parameters for visualizing ancestor contribution proportions to the CR population

# get ID of top contributors to 2022 cohort
id.sort <- pop.pfocal$ID[order(-pop.pfocal$cohort.2022)] # individuals ordered by contribution in 2022
pop.pfocal$rank.2022 <- match(pop.pfocal$ID,id.sort)

id.sort[1:16]
# [1] "RLS-K" "WSA-K" "K-SLA" "OK-RS" "SK-RG" "BK-FS" "K-RSW" "K-SBF" "SR-PK"
# [10] "BK-LS" "K-GSW" "WSF-K" "LK-SG" "BK-AS" "WK-LS" "F-BPS"

# set colors for individuals (lines) of interest: top 16 contributors to 2022 population, which contributed over 75% of ancestry since 2015.
pop.pfocal$color <- "gray30"
pop.pfocal$color[which(pop.pfocal$ID == "RLS-K")] <- "red3"
pop.pfocal$color[which(pop.pfocal$ID == "WSA-K")] <- "blue1"
pop.pfocal$color[which(pop.pfocal$ID == "K-SLA")] <- "cyan"
pop.pfocal$color[which(pop.pfocal$ID == "OK-RS")] <- "steelblue1"
pop.pfocal$color[which(pop.pfocal$ID == "SK-RG")] <- "darkorange"
pop.pfocal$color[which(pop.pfocal$ID == "BK-FS")] <- "indianred4"
pop.pfocal$color[which(pop.pfocal$ID == "K-RSW")] <- "peru"
pop.pfocal$color[which(pop.pfocal$ID == "K-SBF")] <- "tan"
pop.pfocal$color[which(pop.pfocal$ID == "SR-PK")] <- "purple"
pop.pfocal$color[which(pop.pfocal$ID == "BK-LS")] <- "mediumpurple1"
pop.pfocal$color[which(pop.pfocal$ID == "K-GSW")] <- "plum2"
pop.pfocal$color[which(pop.pfocal$ID == "WSF-K")] <- "magenta"
pop.pfocal$color[which(pop.pfocal$ID == "LK-SG")] <- "deeppink3"
pop.pfocal$color[which(pop.pfocal$ID == "BK-AS")] <- "hotpink"
pop.pfocal$color[which(pop.pfocal$ID == "WK-LS")] <- "darkmagenta"
pop.pfocal$color[which(pop.pfocal$ID == "F-BPS")] <- "darkblue"

# set line width for top 16 contributors to 2022
pop.pfocal$lw <- 1
pop.pfocal$lw[which(pop.pfocal$ID == "RLS-K")] <- 2
pop.pfocal$lw[which(pop.pfocal$ID == "WSA-K")] <- 2
pop.pfocal$lw[which(pop.pfocal$ID == "K-SLA")] <- 2
pop.pfocal$lw[which(pop.pfocal$ID == "OK-RS")] <- 2
pop.pfocal$lw[which(pop.pfocal$ID == "SK-RG")] <- 2
pop.pfocal$lw[which(pop.pfocal$ID == "BK-FS")] <- 2
pop.pfocal$lw[which(pop.pfocal$ID == "K-RSW")] <- 2
pop.pfocal$lw[which(pop.pfocal$ID == "K-SBF")] <- 2
pop.pfocal$lw[which(pop.pfocal$ID == "SR-PK")] <- 2
pop.pfocal$lw[which(pop.pfocal$ID == "BK-LS")] <- 2
pop.pfocal$lw[which(pop.pfocal$ID == "K-GSW")] <- 2
pop.pfocal$lw[which(pop.pfocal$ID == "WSF-K")] <- 2
pop.pfocal$lw[which(pop.pfocal$ID == "LK-SG")] <- 2
pop.pfocal$lw[which(pop.pfocal$ID == "BK-AS")] <- 2
pop.pfocal$lw[which(pop.pfocal$ID == "WK-LS")] <- 2
pop.pfocal$lw[which(pop.pfocal$ID == "F-BPS")] <- 2

# set line type according to resident vs translocated
pop.pfocal$ltype <- unname(sapply(id,function(x,df){df$Biological_Origin_Status}[which(df$COLOR_ID == x)],df=meta))
pop.pfocal$ltype[which(pop.pfocal$ltype == "T" | pop.pfocal$ltype == "Donor_Population")] <- 1
pop.pfocal$ltype[which(pop.pfocal$ltype == "IE" | pop.pfocal$ltype == "LR")] <- 2
pop.pfocal$ltype <- as.numeric(pop.pfocal$ltype)


## Plot stacked area chart of contributing ancestors with individual ancestor lines - Figure 2A (ignore warnings)

pop.pfocal$lstr <- replace(pop.pfocal$ltype,which(pop.pfocal$ltype == 1), "solid")
pop.pfocal$lstr <- replace(pop.pfocal$lstr,which(pop.pfocal$ltype == "2"), "dashed")
pop.pfocal$lw2 <- replace(pop.pfocal$lw,which(pop.pfocal$lw == 2), 0.75)
pop.pfocal$lw2 <- replace(pop.pfocal$lw2,which(pop.pfocal$lw2 == 1), 0.50)

#png(file='/home/tyler/Dropbox/research/jay/mosaic/figures/T_IE_population_number_ancestors_area_chart_v3.png',width=16, height=7, units='in', res=300) # offset x-axis title
x11(width=16,height=7)

prop.cutoff=0.2

gg.pop <- ggplot(anc.df.sub, aes(x=year, y=N, fill=count)) +

theme_classic() +

geom_area(position="identity") +

coord_cartesian(xlim=c(2003,2022),ylim=c(0,75)) +

scale_fill_manual(values=c(alpha("gray70",0.6),alpha("gray40",0.6))) +

scale_x_continuous(breaks=time.periods2) +

scale_y_continuous(name="Number ancestors", breaks=seq(from=0,to=75,by=5), sec.axis=sec_axis(~./75*prop.cutoff, name="Proportion ancestor contribution to population", 
breaks=seq(from=0,to=prop.cutoff,by=0.02), )) +

theme(legend.position="none", axis.text.x = element_text(size=17,color="black"), axis.ticks.length.x=unit(0.25,"cm"), axis.title.x=element_text(size=20, color="black", hjust=0.8),
axis.text.y = element_text(size=17,color="black"), axis.ticks.length.y=unit(0.25,"cm"),axis.title.y=element_text(size=20,color="black", vjust=1.5),
axis.title.y.right = element_text(size=20, color="black", vjust=1.5)) +

xlab("Year")

for (k in 1:nrow(pop.pfocal)) {
	tmpvec <- NULL
	for (j in 3:22) { tmpvec <- c(tmpvec,c(pop.pfocal[k,j],NA)) }
	gg.pop <- gg.pop + geom_line(aes_string(y=tmpvec*(75/prop.cutoff)), color=pop.pfocal$color[k], linetype=pop.pfocal$lstr[k], lwd=pop.pfocal$lw2[k])
}

gg.pop

#dev.off()

## Plot stacked barplot of expected ancestral genetic contributions - Figure 2B

# stacked barplot where each individual is a box and color by group using gradients and distinct colors

topid <- pop.pfocal$ID[topidx] # these are the individuals that contributed >75% ancestry to the CR population since 2015
topid
# [1] "RLS-K" "WSA-K" "K-SLA" "OK-RS" "SK-RG" "BK-FS" "K-RSW" "K-SBF" "SR-PK"
# [10] "BK-LS" "K-GSW" "WSF-K" "LK-SG" "BK-AS" "WK-LS" "F-BPS

# set groups for barplot coloring

pop.pgroup2 <- pop.pfocal[,1:22]
pop.pgroup2$biotype = unname(sapply(pop.pgroup2$ID, function(x,df){idx=which(df$COLOR_ID == x); btype=df$Biological_Origin_Status[idx];ifelse(btype == "T", "Trans", "Res")},df=meta))

pop.pgroup2$bargrp <- pop.pgroup2$biotype
pop.pgroup2$bargrp[which(pop.pgroup2$ID %in% topid == TRUE)] <- "top"

# sort by descending contribution to 2022 within groups
pop.pgroup2$bargrp <- factor(pop.pgroup2$bargrp,levels=c("top","Trans","Res"),ordered=TRUE)
pop.pgroup2 <- pop.pgroup2[order(pop.pgroup2$bargrp,-pop.pgroup2$cohort.2022),]

# color top individuals

pop.pgroup2$barcol <- pop.pfocal$ID
pop.pgroup2$barcol[which(pop.pgroup2$ID == "RLS-K")] <- "red3"
pop.pgroup2$barcol[which(pop.pgroup2$ID == "WSA-K")] <- "blue1"
pop.pgroup2$barcol[which(pop.pgroup2$ID == "K-SLA")] <- "cyan"
pop.pgroup2$barcol[which(pop.pgroup2$ID == "OK-RS")] <- "steelblue1"
pop.pgroup2$barcol[which(pop.pgroup2$ID == "SK-RG")] <- "darkorange"
pop.pgroup2$barcol[which(pop.pgroup2$ID == "BK-FS")] <- "indianred4"
pop.pgroup2$barcol[which(pop.pgroup2$ID == "K-RSW")] <- "peru"
pop.pgroup2$barcol[which(pop.pgroup2$ID == "K-SBF")] <- "tan"
pop.pgroup2$barcol[which(pop.pgroup2$ID == "SR-PK")] <- "purple"
pop.pgroup2$barcol[which(pop.pgroup2$ID == "BK-LS")] <- "mediumpurple1"
pop.pgroup2$barcol[which(pop.pgroup2$ID == "K-GSW")] <- "plum2"
pop.pgroup2$barcol[which(pop.pgroup2$ID == "WSF-K")] <- "magenta"
pop.pgroup2$barcol[which(pop.pgroup2$ID == "LK-SG")] <- "deeppink3"
pop.pgroup2$barcol[which(pop.pgroup2$ID == "BK-AS")] <- "hotpink"
pop.pgroup2$barcol[which(pop.pgroup2$ID == "WK-LS")] <- "darkmagenta"
pop.pgroup2$barcol[which(pop.pgroup2$ID == "F-BPS")] <- "darkblue"

# gradient color remaining translocated individuals
trans.col.vec = NULL
trans.col="gold2"
trans.idx <- which(pop.pgroup2$bargrp == "Trans")
step = 1/(length(trans.idx)+10)
c = 1;
for (i in trans.idx) {
	pop.pgroup2$barcol[i] <- alpha(trans.col,c)
	trans.col.vec <- c(trans.col.vec,pop.pgroup2$barcol[i])
	c = c-step
}

# gradient color for remaining resident individuals
res.col.vec = NULL
res.col="gray30"
res.idx <- which(pop.pgroup2$bargrp == "Res")
step = 1/(length(res.idx)+5)
c = 1;
for (i in res.idx) {
        pop.pgroup2$barcol[i] <- alpha(res.col,c)
	res.col.vec <- c(res.col.vec,pop.pgroup2$barcol[i])
        c = c-step
}

# convert data.frame into matrix for plotting
#pop.pgroup2.mat <- as.matrix(pop.pgroup2[,2:22])
pop.pgroup2.mat <- as.matrix(pop.pgroup2[,3:22]) # excludes 2002
pop.pgroup2.mat[which(is.na(pop.pgroup2.mat))] <- 0


# gradient color box for legend

trans.col.width = seq(from=0,to=1,by=(1/length(trans.col.vec)))
res.col.width = seq(from=0,to=1,by=(1/length(res.col.vec)))

X11()
#png(file='/home/tyler/Dropbox/research/jay/mosaic/figures/T_IE_pop_contribution_pfocal_barplot_key.png', width=7, height=7, units='in', res=300)
#pdf(file='/home/tyler/Dropbox/research/jay/mosaic/figures/T_IE_pop_contribution_pfocal_barplot_key.pdf', width=7, height=7)
#plot.new()

yb = 0.1
yt = 0.3
plot(1, type="n", xlab="", ylab="", xlim=c(-0.05,1.05), ylim=c(-0.05,1.05))
for (i in 1:(length(trans.col.width)-1)) {
	xs = trans.col.width[i]
	xe = trans.col.width[i+1]
	rect(xleft=xs, xright=xe, ybottom=yb, ytop=yt, border="gray50", lwd=0.3, col=trans.col.vec[i])
}
rect(xleft=trans.col.width[1], xright=trans.col.width[length(trans.col.width)], ybottom=yb, ytop=yt, border="gray20", lwd=1, col=NA)

res.col.width = seq(from=0,to=1,by=(1/length(res.col.vec)))
yb = 0.5
yt = 0.7
for (i in 1:(length(res.col.width)-1)) {
        xs = res.col.width[i]
        xe = res.col.width[i+1]
        rect(xleft=xs, xright=xe, ybottom=yb, ytop=yt, border="gray10", lwd=0.3, col=res.col.vec[i])
}
rect(xleft=res.col.width[1], xright=res.col.width[length(res.col.width)], ybottom=yb, ytop=yt, border="gray20", lwd=1, col=NA)

#dev.off()

# plot stacked barplot

nyears = length(time.periods2)

years.vec <- NULL
for (i in time.periods2) { years.vec <- c(years.vec,rep(i,nrow(pop.pgroup2))) }

contribution.p = NULL
for (i in 1:ncol(pop.pgroup2.mat)) {contribution.p <- c(contribution.p, unname(pop.pgroup2.mat[,i]))}

pat <- replace(pop.pgroup2$biotype, which(pop.pgroup2$biotype == "Res"), "stripe")
pat <- replace(pat, which(pat != "stripe"), "none")

pop.pgroup3 <- data.frame(year=years.vec, ID=rep(pop.pgroup2$ID,nyears), proportion=contribution.p, color=rep(pop.pgroup2$barcol,nyears), pattern=rep(pat,nyears))
pop.pgroup3$year <- as.factor(pop.pgroup3$year) # need to do this for proper x-axis labels

pat.shift = NULL
xshift=0
pstep = 1/length(which(pat=="stripe"))
for (i in pat) {
	if (i == "stripe") {
		xshift = xshift + pstep
		pat.shift = c(pat.shift,xshift)
	} else pat.shift = c(pat.shift,0)
}

# begin plot
#png(file='/home/tyler/Dropbox/research/jay/mosaic/figures/T_IE_pop_contribution_pfocal_barplot_2003_2022.png',width=16, height=7, units='in', res=300)
x11(width=16,height=7)
ggplot(pop.pgroup3, aes(fill=ID, y=proportion, x=year)) +

theme_classic() +

geom_bar_pattern(position="stack", stat="identity", pattern=pop.pgroup3$pattern, pattern_fill = "black", fill=pop.pgroup3$color, linewidth=0.5, color="black",
pattern_spacing = 0.012, pattern_density=0.05, pattern_size=0.45, pattern_yoffset=rep(pat.shift,nyears)) +

theme(legend.position="none", axis.text.x = element_text(size=17, color="black",vjust=4), axis.text.y = element_text(size=17, color="black"), axis.ticks.x=element_blank(),
axis.title.x=element_text(size = 20, color="black", vjust=2), axis.title.y=element_text(size = 20, color="black",vjust=2), axis.line.x=element_blank(), axis.line.y=element_blank(), 
axis.ticks.length.y=unit(0.25, "cm")) +

annotate(x=0, xend=0, y=0, yend=1, colour="black", lwd=0.75, geom="segment") +

xlab("Year") +

ylab("Proportion ancestor contribution to population")

#dev.off()

--- end R code for T and IE temporal contributions to population ---


## Plot CR ancestor expected genetic contributions through time to individuals born into a cohort

--- begin R code for T and IE temporal contributions to cohort ---

# This code generates Figure S1

library(scales) # for alpha colors

meta <- read.table("/home/tyler/Dropbox/research/jay/mosaic/metadata/jayid_map_20230512.txt",head=TRUE,sep="\t")
fdir='/home/tyler/Dropbox/research/jay/mosaic/pedigree/results/lr_temporal/'
ped <- read.table('/home/tyler/Dropbox/research/jay/mosaic/pedigree/cr_ped_20230512.tsv', head=TRUE, na.strings='*')

cohort.n <- NULL # data frame of number of expected genomic copies
cohort.pfocal <- NULL # data frame of contributions normalized by focal ancestors
cohort.pmax <- NULL # data frame of contribution normalized by max ancestral cohort pop contribution

# read in pedstat files for time points 2004-2022
time.periods = 2004:2022
tidx <- 2:(length(time.periods)+1) # these are the contribution columns in matrix
id <- NULL
for (t in time.periods) {
	df <- read.table(paste0(fdir,'T_IE_20230512_to_',t,'_LR_contribution.pedstat1'),head=TRUE)
	if (is.null(id)) id <- df[,1]
	cohort.n <- cbind(cohort.n, df[,2])
	cohort.pfocal <- cbind(cohort.pfocal, df[,3])
	cohort.pmax <- cbind(cohort.pmax, df[,4])
}

# mask values of individuals if they weren't born
ped.sub <- ped[which(ped$ID %in% id),c(1,5)]
ped.sub <- ped.sub[match(id,ped.sub$ID),]
for (i in 1:length(time.periods)) {
	t = time.periods[i]
	idx <- which(ped.sub$COHORT > t)
	if (length(idx) > 0) {
		cohort.n[idx,i] <- NA
		cohort.pfocal[idx,i] <- NA
		cohort.pmax[idx,i] <- NA	
	}
}

cohort.n <- cbind(data.frame(ID=id),as.data.frame(cohort.n)) # add sample names
colnames(cohort.n) <- c("ID",paste0("cohort.",time.periods))

cohort.pfocal <- cbind(data.frame(ID=id),as.data.frame(cohort.pfocal)) # add sample names
colnames(cohort.pfocal) <- c("ID",paste0("cohort.",time.periods))

cohort.pmax <- cbind(data.frame(ID=id),as.data.frame(cohort.pmax)) # add sample names
colnames(cohort.pmax) <- c("ID",paste0("cohort.",time.periods))

# proportion with respect to focal ancestors plot

# get ID of top contributors to 2022 cohort
id.sort <- cohort.pfocal$ID[order(-cohort.pfocal$cohort.2022)] # individuals ordered by contribution in 2022
cohort.pfocal$rank.2022 <- match(cohort.pfocal$ID,id.sort)

id.sort[1:10]
# [1] "RLS-K" "WSA-K" "K-SLA" "OK-RS" "BK-FS" "SK-RG" "SR-PK" "K-RSW" "K-SBF"
#[10] "BK-LS"


# set colors for individuals (lines) of interest: top 16 contributors to 2022 population, which contributed over 75% of ancestry since 2015.
cohort.pfocal$color <- "gray30"
cohort.pfocal$color[which(cohort.pfocal$ID == "RLS-K")] <- "red3"
cohort.pfocal$color[which(cohort.pfocal$ID == "WSA-K")] <- "blue1"
cohort.pfocal$color[which(cohort.pfocal$ID == "K-SLA")] <- "cyan"
cohort.pfocal$color[which(cohort.pfocal$ID == "OK-RS")] <- "steelblue1"
cohort.pfocal$color[which(cohort.pfocal$ID == "SK-RG")] <- "darkorange"
cohort.pfocal$color[which(cohort.pfocal$ID == "BK-FS")] <- "indianred4"
cohort.pfocal$color[which(cohort.pfocal$ID == "K-RSW")] <- "peru"
cohort.pfocal$color[which(cohort.pfocal$ID == "K-SBF")] <- "tan"
cohort.pfocal$color[which(cohort.pfocal$ID == "SR-PK")] <- "purple"
cohort.pfocal$color[which(cohort.pfocal$ID == "BK-LS")] <- "mediumpurple1"
cohort.pfocal$color[which(cohort.pfocal$ID == "K-GSW")] <- "plum2"
cohort.pfocal$color[which(cohort.pfocal$ID == "WSF-K")] <- "magenta"
cohort.pfocal$color[which(cohort.pfocal$ID == "LK-SG")] <- "deeppink3"
cohort.pfocal$color[which(cohort.pfocal$ID == "BK-AS")] <- "hotpink"
cohort.pfocal$color[which(cohort.pfocal$ID == "WK-LS")] <- "darkmagenta"
cohort.pfocal$color[which(cohort.pfocal$ID == "F-BPS")] <- "darkblue"

# set line width
cohort.pfocal$lw <- 1
cohort.pfocal$lw[which(cohort.pfocal$ID == "RLS-K")] <- 2
cohort.pfocal$lw[which(cohort.pfocal$ID == "WSA-K")] <- 2
cohort.pfocal$lw[which(cohort.pfocal$ID == "K-SLA")] <- 2
cohort.pfocal$lw[which(cohort.pfocal$ID == "OK-RS")] <- 2
cohort.pfocal$lw[which(cohort.pfocal$ID == "SK-RG")] <- 2
cohort.pfocal$lw[which(cohort.pfocal$ID == "BK-FS")] <- 2
cohort.pfocal$lw[which(cohort.pfocal$ID == "K-RSW")] <- 2
cohort.pfocal$lw[which(cohort.pfocal$ID == "K-SBF")] <- 2
cohort.pfocal$lw[which(cohort.pfocal$ID == "SR-PK")] <- 2
cohort.pfocal$lw[which(cohort.pfocal$ID == "BK-LS")] <- 2
cohort.pfocal$lw[which(cohort.pfocal$ID == "K-GSW")] <- 2
cohort.pfocal$lw[which(cohort.pfocal$ID == "WSF-K")] <- 2
cohort.pfocal$lw[which(cohort.pfocal$ID == "LK-SG")] <- 2
cohort.pfocal$lw[which(cohort.pfocal$ID == "BK-AS")] <- 2
cohort.pfocal$lw[which(cohort.pfocal$ID == "WK-LS")] <- 2
cohort.pfocal$lw[which(cohort.pfocal$ID == "F-BPS")] <- 2


# set line type according to resident vs translocated
cohort.pfocal$ltype <- unname(sapply(id,function(x,df){df$Biological_Origin_Status}[which(df$COLOR_ID == x)],df=meta))
cohort.pfocal$ltype[which(cohort.pfocal$ltype == "T" | cohort.pfocal$ltype == "Donor_Population")] <- 1
cohort.pfocal$ltype[which(cohort.pfocal$ltype == "IE" | cohort.pfocal$ltype == "LR")] <- 2
cohort.pfocal$ltype <- as.numeric(cohort.pfocal$ltype)

# plot focal ancestor contribution proportions over time

#png(file='/home/tyler/Dropbox/research/jay/mosaic/figures/T_IE_cohort_contribution_pfocal_v3.png',width=16, height=7, units='in', res=300)
x11(width=16,height=7)
par(mgp = c(2.75,1,0))
plot(1, type="n", xlim=c(time.periods[1],time.periods[length(time.periods)]), ylim=c(0,max(cohort.pfocal[,tidx],na.rm=TRUE)+0.0),
xlab="Year", ylab="Proportion ancestor contribution to cohort", main="",xaxt='n', cex.axis=1.3, cex.lab=1.5)
axis(side=1,at=time.periods,labels=time.periods,cex=1.5,cex.axis=1.3)

for (i in 1:nrow(cohort.pfocal)) {
	# draw lines
	lines(x=time.periods, y=cohort.pfocal[i,tidx],col=alpha(cohort.pfocal$color[i],0.6), lty=cohort.pfocal$ltype[i], lwd=cohort.pfocal$lw[i])
}

# plot mean line
#lines(x=time.periods, y=sapply(tidx,function(x,df){mean(df[,x],na.rm=TRUE)},df=cohort.pfocal), lty=6, col="black", lwd=2) # THIS MEAN SHOULD EXCLUDE 0/NA

# add legend
#legend('topright',c("Translocated","Resident","Mean"),lty=c(1,2,6),bty='n',cex=1.3,seg.len=2.9,lwd=1.7)
legend('topright',c("Translocated","Resident"),lty=c(1,2),bty='n',cex=1.3,seg.len=2.9,lwd=1.7)

# dev.off()

--- end R code for T and IE temporal contributions to cohort ---


Collect information about RLS-K relatives.

--- start R code for RLK-S relative assessment ---

rmat <- read.table('/home/tyler/Dropbox/research/jay/mosaic/pedigree/cr_ped_20230512_relatedness_matrix.txt',head=TRUE)
rmat[which(colnames(rmat) == "RLS.K"),which(colnames(rmat) == "K.SLA")]
# [1] 0.125 # r between RLS-K and K-SLA

# find all translocated relatives of RLS-K
trans <- read.csv('/home/tyler/Dropbox/research/jay/mosaic/metadata/Translocated_Jay_Individual_Statistics.tsv',head=TRUE,sep="\t")
rlsk.relatives <- colnames(rmat)[which(rmat[which(colnames(rmat) == "RLS.K"),] > 0)]
trans.id <- gsub("-",".",trans$COLOR_ID)
rlsk.relatives.trans <- rlsk.relatives[rlsk.relatives %in% trans.id]
rlsk.relatives.trans <- rlsk.relatives.trans[-which(rlsk.relatives.trans == "RLS.K")]
rlsk.relatives.trans
#[1] "SK.RG" "SK.RB" "SK.RP" "SRR.K" "K.SAP" "K.SLA" "K.SPR" "K.SAG"

--- end R code for RLS-K relative assessment ---

## Characterize ancestral contributions to the 2022 CR population

--- begin R code for 2022 population contribution stats ---

x2022 <- read.table('/home/tyler/Dropbox/research/jay/mosaic/pedigree/results/pop_temporal/T_IE_20230512_2022_pop_contribution.pedstat1',head=TRUE)

mean(x2022$P_ANC_FOCAL)
#[1] 0.0135135 # average relative ancestral contribution

length(which(x2022$P_ANC_FOCAL > mean(x2022$P_ANC_FOCAL)))
[1] 22 # number of ancestors contributinig more than the average relative contribution 

length(which(x2022$P_ANC_FOCAL > 2*mean(x2022$P_ANC_FOCAL)))
[1] 11 # number of ancestors providing more than twice the average contribution
 
mean(x2022$N_GENOME_COPIES)
#[1] 1.338657 # expected number of genomic copies per ancestor in the 2022 CR population (average number of expected genomic copies) 

x2022$N_GENOME_COPIES[which(x2022$ID == "RLS-K")]/mean(x2022$N_GENOME_COPIES)
#[1] 10.59831 # contribution of RLS-K relative to the average ancestral contribution

x2022$N_GENOME_COPIES[which(x2022$ID == "WSA-K")]/mean(x2022$N_GENOME_COPIES)
#[1] 7.820377 # contribution of WSA-K relative to the average ancestal contribution

length(which(x2022$N_GENOME_COPIES > 5*mean(x2022$N_GENOME_COPIES)))
[1] 4 # number of ancestors providing more than 5x the average ancestral contribution

x2022$N_GENOME_COPIES[which(x2022$ID == "K-SLA")]
[1] 9.16406 # number expected genomic copies provided by K-SLA

x2022$N_GENOME_COPIES[which(x2022$ID == "K-SLA")]/mean(x2022$N_GENOME_COPIES)
#[1] 6.845714 # contribution of SLA-K relative to the average ancestral contribution

x2022$N_GENOME_COPIES[which(x2022$ID == "OK-RS")]/mean(x2022$N_GENOME_COPIES)
#[1] 5.252467 # contribution of OK-RS relative to the average ancestral contribution

--- end R code for 2022 population contribution stats ---


#
#
#


## ---------- SKEW ANALYSIS WITH GENOMIC DATA ---------- ##

## Calculate genetic skew (K) statistic for all sequenced translocated and resident individuals with respect to the contemporary sample with --background_r set to the 95th quantile 
## for relatedness between resident CR and translocated individuals (0.0243058).

--- begin R code for subsetting genetic relatedness matrix ---

rmat <- as.matrix(read.table('/home/tyler/Dropbox/research/jay/mosaic/popgen/relatedness/fsj_mosaic_biallelic_snps_main_autosomes_qc_relatedness_matrix_relateStats_input.txt', head=TRUE))
idmap <- read.csv('/home/tyler/Dropbox/research/jay/mosaic/metadata/jayid_map_20230512.txt',head=TRUE,sep="\t")
core <- read.table('/home/tyler/Dropbox/research/jay/mosaic/pedigree/cr_ped_20230512.tsv',head=TRUE)
core.anc <- read.table('/home/tyler/Dropbox/research/jay/mosaic/pedigree/relateStat_inputs/CR_T_IE_ancestors_20230512.txt',head=FALSE) # T, IE
colnames(rmat) <- toupper(unname(sapply(colnames(rmat),function(x,df){df$COLOR_ID[which(df$LAB_ID == x)]},df=idmap))) # convert relatedness IDs to COLOR_IDs
idx <- which(colnames(rmat) %in% core$ID)
rmat.sub <- rmat[idx,idx]
seq.ids <- colnames(rmat)

# write relatedness matrix containing only Core Region individuals
write.table(rmat.sub,file='/home/tyler/Dropbox/research/jay/mosaic/popgen/relatedness/fsj_mosaic_biallelic_snps_main_autosomes_qc_relatedness_matrix_relateStats_input_CR.txt',col.names=TRUE,row.names=FALSE,quote=FALSE)

# Make list of sequenced T and IE ancestors and contemporary individuals
write.table(data.frame(ID=seq.ids[which(seq.ids %in% core.anc$V1)]),file='/home/tyler/Dropbox/research/jay/mosaic/popgen/relatedness/CR_T_IE_sequenced.txt',col.names=FALSE,row.names=FALSE,quote=FALSE)

--- end R code for subsetting genetic relatedness matrix ---

Calculate skew statistic for CR T and IE individuals

--- start bash code ---

./PopGenomicsTools/relateStats --skewstat 3 --rmat fsj_mosaic_biallelic_snps_main_autosomes_qc_relatedness_matrix_relateStats_input_CR.txt --anc CR_T_IE_sequenced.txt --cohort /home/tyler/Dropbox/research/jay/mosaic/pedigree/relateStat_inputs/CR_sequenced_contemporary_ids_20230512.txt --background_r 0.0243058 --out ./skew/CR_T_IE_to_C_contributions_c0.0243058

--- end bash code ---

## Plot of average rank-weighted skew distribution - Figure 4A

--- begin R code for plotting individual average rank-weighted skew distribution ---

library(scales)

kstat <- read.table('/home/tyler/Dropbox/research/jay/mosaic/popgen/relatedness/skew/CR_T_IE_to_C_contributions_c0.0243058.skewstat3',head=TRUE)
meta <- read.table('/home/tyler/Dropbox/research/jay/mosaic/metadata/M4_sequenced_FSJsamples_metadata.txt',head=TRUE,sep="\t")
idmap <- read.csv('/home/tyler/Dropbox/research/jay/mosaic/metadata/jayid_map_20230512.txt',head=TRUE,sep="\t")
meta$popcol <- popcolor(meta)
meta$COLOR_ID <- unname(sapply(meta$LAB_ID,function(x,df){df$COLOR_ID[which(df$LAB_ID == x)]},df=idmap))
meta$COLOR_ID[which(meta$COLOR_ID == "*")] <- NA

# nonparametric measure of skew
npskew = (mean(kstat$Swtr) - median(kstat$Swtr))/sd(kstat$Swtr)
npskew
#[1] 0.252958

kstat.sort <- kstat[order(-kstat$Swtr),] # sort data.frame by descending skew statistics

# plot genetic skew statistic, K
# png(file='/home/tyler/Dropbox/research/jay/mosaic/figures/k_statistic_distribution_v2.png',width=9, height=7, units='in', res=300) # use italics in axis titles
X11(width=9,height=7)
par(mar=c(5,5.2,4,2)+0.1)
plot(x=1:nrow(kstat.sort), y=kstat.sort$Swtr, type="l", lwd=4, col="grey60", ylab = expression(paste("Average weighted relatedness (", italic("K"), ")")), xlab="", xaxt='n',cex.lab=1.6, cex.axis=1.4) # v2
axis(1, at=1:nrow(kstat.sort), labels=kstat.sort$ID,cex=1.2,las=2)
# add points
pointcols = meta$popcol[sapply(kstat.sort$ID,function(x,df){which(df$COLOR_ID == x)},df=meta, USE.NAMES=FALSE)]
points(x=1:nrow(kstat.sort), y=kstat.sort$Swtr, pch=19, col=alpha(pointcols,0.8), cex=1.7)
# add vertical bars
lh = kstat.sort$Swtr
lines(x=1:nrow(kstat.sort), y=lh, type="h", lwd=13.5, col=alpha(pointcols,0.4))
# add point outlines
points(x=1:nrow(kstat.sort), y=kstat.sort$Swtr, pch=1, col=pointcols, cex=1.7, lwd=1.7)

#dev.off()

--- end R code for plotting individual average rank-weighted skew distribution ---


#
#
#


## ---------- COMPARE PEDIGREE VS GENOMIC-BASED SKEW INFERENCE ---------- ##

## Examine correlation between expected genetic contributions calculated from the pedigree and the K statistic 
## calculated from genomic data.

--- begin R code for comparing skew inference approaches ---

library(scales)
library(boot)

ped1 <- read.table('/home/tyler/Dropbox/research/jay/mosaic/pedigree/results/sequenced_contemporary/T_IE_20230512_to_seq_contemporary.pedstat1',head=TRUE)
gendat <- read.table('/home/tyler/Dropbox/research/jay/mosaic/popgen/relatedness/skew/CR_T_IE_to_C_contributions_c0.0243058.skewstat3',head=TRUE)
genmeta <- read.table('~/Dropbox/research/jay/mosaic/metadata/M4_sequenced_FSJsamples_metadata.txt',head=TRUE)
jayid <- read.csv('/home/tyler/Dropbox/research/jay/mosaic/metadata/jayid_map_20230512.txt',head=TRUE,na.strings = "*",sep="\t")
jayid$COLOR_ID <- toupper(jayid$COLOR_ID)

# translate color band, federal, and lab IDs
ped1$FED_ID <- unname(sapply(ped1$ID,function(x,df){ifelse(length(grep("UNBAND",x))>0,NA,df$FEDERAL_ID[which(df$COLOR_ID == x)])},df=jayid))
gendat$FED_ID = unname(sapply(gendat$ID,function(x,df){df$FEDERAL_ID[which(df$COLOR_ID == x)]},df=jayid))
ped1$LAB_ID = unname(sapply(ped1$ID,function(x,df){df$LAB_ID[which(df$COLOR_ID == x)]},df=jayid))

# assign ranks based on contribution (equal values will have equal rank)
gendat.sort <- gendat[order(-gendat$Swtr),] # sort by Swtr
swtr.unique <- unique(gendat.sort$Swtr)
gendat.sort$swtr.rank = NA
for (i in 1:length(swtr.unique)) {gendat.sort$swtr.rank[which(gendat.sort$Swtr == swtr.unique[i])] = i}

ped1.sort <- ped1[order(-ped1$P_ANC_FOCAL),]
p_focal.unique = unique(ped1.sort$P_ANC_FOCAL)
ped1.sort$ped.rank = NA
for (i in 1:length(p_focal.unique)) {ped1.sort$ped.rank[which(ped1.sort$P_ANC_FOCAL == p_focal.unique[i])] = i}

ped1.sort$gen.rank = unname(sapply(ped1.sort$ID,function(x,df){ifelse(is.na(x),NA,df$swtr.rank[which(df$ID == x)])},df=gendat.sort))
ped1.sort$Swtr = unname(sapply(ped1.sort$ID,function(x,df){ifelse(is.na(x),NA,df$Swtr[which(df$ID == x)])},df=gendat.sort))

# add M4 samples that were not in pedigree analysis - not necessary for core region only (T and IE) analysis so commented out
#m4_labid <- gendat.sort$ID[grep("M4_", gendat.sort$ID)]
#m4_missing <- NULL
#for (id in m4_labid) {
#	colid <- jayid$COLOR_ID[which(jayid$LAB_ID == id)]
#	fedid <- jayid$FEDERAL_ID[which(jayid$LAB_ID == id)]
#	idx = which(gendat.sort$ID == id)
#	if (fedid %in% ped1.sort$FED_ID == FALSE) {
#		m4_missing <- rbind(m4_missing, m4_missing <- data.frame(ID = colid, N_GENOME_COPIES = NA, P_ANC_FOCAL = NA, P_ANC_MAX = NA, FED_ID = fedid, LAB_ID = id,
#		   ped.rank = NA, gen.rank = gendat.sort$swtr.rank[idx], Swtr = gendat.sort$Swtr[idx]))
#	}
#}
#ped1.sort <- rbind(ped1.sort, m4_missing)

# subset of ancestors in pedigree and genetic analysis
share <- ped1.sort[which(!is.na(ped1.sort$ped.rank) & !is.na(ped1.sort$gen.rank)),]

# test for rank correlation between K statistic and the the number of genomic copies for individuals common to both datasets
cor.test(x=share$Swtr, y=share$N_GENOME_COPIES, method="kendall", alternative="two.sided")
#
#	Kendall's rank correlation tau
#
#data:  share$Swtr and share$N_GENOME_COPIES
#z = 3.3456, p-value = 0.000821
#alternative hypothesis: true tau is not equal to 0
#sample estimates:
#      tau 
#0.4194696 
#
#Warning message:
#In cor.test.default(x = share$Swtr, y = share$N_GENOME_COPIES, method = "kendall",  
#  Cannot compute exact p-value with ties

# test for correlation between K statistic and the number of genomic copies for individuals common to both datasets
skew_model <- lm(share$N_GENOME_COPIES ~ share$Swtr)

summary(skew_model)
#
#Call:
#lm(formula = share$N_GENOME_COPIES ~ share$Swtr)
#
#Residuals:
#     Min       1Q   Median       3Q      Max 
#-0.75371 -0.13914 -0.00378  0.06603  0.84904 
#
#Coefficients:
#            Estimate Std. Error t value Pr(>|t|)    
#(Intercept) -0.06603    0.05822  -1.134    0.264    
#share$Swtr  30.30343    3.90832   7.754 2.88e-09 ***
#---
#Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1
#
#Residual standard error: 0.2814 on 37 degrees of freedom
#Multiple R-squared:  0.619,    Adjusted R-squared:  0.6087 
#F-statistic: 60.12 on 1 and 37 DF,  p-value: 2.878e-09

#summary(skew_model)$r.square
[1] 0.6190199

shapiro.test(resid(skew_model)) # errors deviate slightly from normal distribution so will use bootstrap to test for correlation between the two measures of genetic contribution
#
#       Shapiro-Wilk normality test
#
#data:  resid(skew_model)
#W = 0.91163, p-value = 0.004835

set.seed(7016301)

skew_beta.boot <- boot(data.frame(x=share$Swtr, y=share$N_GENOME_COPIES), getBeta1, R=10000, stype="i", sim="ordinary")
skew_beta.ci <- boot.ci(skew_beta.boot, conf=0.95, type=c("perc", "bca"))

skew_beta.ci
#BOOTSTRAP CONFIDENCE INTERVAL CALCULATIONS
#Based on 10000 bootstrap replicates
#
#CALL : 
#boot.ci(boot.out = skew_beta.boot, conf = 0.95, type = c("perc", 
#    "bca"))
#
#Intervals : 
#Level     Percentile            BCa          
#95%   (12.35, 44.30 )   (15.67, 46.44 )  
#Calculations and Intervals on Original Scale

# scatterplot of K vs pedigree-based genetic contribution (Figure S11)

#png(file='/home/tyler/Dropbox/research/jay/mosaic/figures/pedigree_vs_genetic_skew_correlation.png',width=7, height=7, units='in', res=300)
par(mgp=c(2.9,1,0))
plot(x=share$Swtr, y=share$N_GENOME_COPIES, xlab=expression(paste("Average rank-weighted relatedness (", italic(K),")", sep="")), 
ylab="Pedigree expected number genomic copies", pch=21, col=alpha("black",0.8), bg=alpha("black",0.5),cex=1.4, cex.lab=1.4, cex.axis=1.4, lwd=1.2)
abline(a=skew_model$coefficients[1], b=skew_model$coefficients[2], col="grey20")
text(x=0.035,y=1.24,label=bquote(italic(r)^2 == .(round(summary(skew_model)$r.square, digits=2))), cex=1.3)
#dev.off()


# line plot (Figure 4B)

library(scales)

# set point colors according to biological origin (grey indicates no contribution)

rescol = "cyan3"
transcol = "darkorange2"
ped1.sort$biotype_col = unname(sapply(ped1.sort$ID,function(x,df){df$Biological_Origin_Status[which(df$COLOR_ID==x)]},df=jayid))
ped1.sort$biotype_col <- replace(ped1.sort$biotype_col, which(ped1.sort$biotype_col == "IE" | ped1.sort$biotype_col == "LR"),rescol)
ped1.sort$biotype_col <- replace(ped1.sort$biotype_col, which(ped1.sort$biotype_col == "T"),transcol)

ped.cutoff = (ped1.sort$ped.rank[which(ped1.sort$N_GENOME_COPIES == 0)])[1] # pedigree individuals at this rank or above did not contribute
gen.cutoff = ped1.sort$gen.rank[which(ped1.sort$Swtr == 0)][1] # individuals at this rank or above did not make contribution based K-statistic

pedcol.bg <- alpha(ped1.sort$biotype_col,0.65)
#pedcol.bg[which(is.na(ped1.sort$gen.rank))] <- alpha("grey40",0) # makes totally tranparent (i.e. no colored background)
pedcol.bg[which(ped1.sort$ped.rank >= ped.cutoff)] <- alpha("grey40",0)

pedcol <- alpha(ped1.sort$biotype_col,0.65)
pedcol[which(ped1.sort$ped.rank >= ped.cutoff)] <- alpha("grey40",0.65)

gencol.bg <- alpha(ped1.sort$biotype_col,0.65)
gencol.bg[which(ped1.sort$gen.rank >= gen.cutoff)] <- alpha("grey40",0)

gencol <- alpha(ped1.sort$biotype_col,0.65)
gencol[which(ped1.sort$gen.rank >= gen.cutoff)] <- alpha("grey40",0.65)

# set point sizes according to contribution
ped.scale <- ped1.sort$P_ANC_FOCAL/max(ped1.sort$P_ANC_FOCAL)
ped.scale[which(ped.scale == 0)] <- min(ped.scale[which(ped.scale > 0)])

gen.scale <- ped1.sort$Swtr/max(ped1.sort$Swtr,na.rm=TRUE)
gen.scale[which(gen.scale == 0)] <- min(gen.scale[which(gen.scale > 0)])

# use x-axis jitter to show individuals with tied ranks
xa = 0.3
xb = 0.8

# jitter for pedigree ranks
xa.jitter <- rep(xa,nrow(ped1.sort))
urank.ped <- unique(ped1.sort$ped.rank)
urank.ped.naidx <- which(is.na(urank.ped))
if (length(urank.ped.naidx) > 0) urank.ped <- urank.ped[-urank.ped.naidx]
for (i in urank.ped) {
        n = 1                                     
        xshift = 0 
        for (idx in which(ped1.sort$ped.rank == i)) {
                if (n %% 2) {
                        xa.jitter[idx] = xa + xshift
                } else {
                        xa.jitter[idx] = xa - xshift
                        xshift = xshift + 0.005
                }
                n = n+1
        }
}

# jitter for genetic ranks
xb.jitter <- rep(xb,nrow(ped1.sort))
urank.gen <- unique(ped1.sort$gen.rank)
urank.gen.naidx <- which(is.na(urank.gen))
if (length(urank.gen.naidx) > 0) urank.gen <- urank.gen[-urank.gen.naidx]
for (i in urank.gen) {
        n = 1
        xshift = 0
        for (idx in which(ped1.sort$gen.rank == i)) {
                if (n %% 2) {
                        xb.jitter[idx] = xb + xshift
                } else {
                        xb.jitter[idx] = xb - xshift
                        xshift = xshift + 0.005
                }
                n = n+1
        }
}


# make canvas and plot
#png(file='/home/tyler/Dropbox/research/jay/mosaic/figures/ped_vs_genetic_skew_comparison_improved_label.png',width=6, height=7, units='in', res=300)

x11(width=6,height=7)
maxrank = max(ped1.sort$ped.rank, ped1.sort$gen.rank, na.rm=TRUE)
y.marks = c(1,seq(from=5,to=2*round(maxrank/2),by=5))
plot(1,type="n", xlab="", ylab="Rank of the genetic contribution to the 2021 cohort", ylim=c(maxrank, -1), xlim=c(0,1),xaxt='n', yaxt='n', cex.lab=1.3) # blank canvas
axis(side=1,at=c(xa,xb),labels=c("Pedigree","Genetic"),cex.axis=1.3) # x-axis
axis(side=2,at=y.marks,labels=y.marks,cex.axis=1.3) # y-axis

# add points

point.width=1
points(x=xa.jitter,y=ped1.sort$ped.rank, pch=21, col=pedcol, bg=pedcol.bg, lwd=point.width, cex=3.5*ped.scale)
points(x=xb.jitter,y=ped1.sort$gen.rank, pch=21, col=gencol, bg=gencol.bg, lwd=point.width, cex=3.5*gen.scale)
for (i in 1:nrow(share)) {
	lcol = "black"
	lwidth = 1.3
	if (share$ped.rank[i] >= ped.cutoff) {
		# mask lines from pedigree individuals that did not contribute
		lcol = alpha("grey20",0.3)
		lwidth = 1
	}
	lines(x=c(xa,xb),y=c(share$ped.rank[i],share$gen.rank[i]), col=lcol, lwd=lwidth)
}

# add annotations
text(x=xa,y=-1.2,paste0("n=",length(which(!is.na(ped1.sort$ped.rank)))),cex=1.2)
text(x=xb,y=-1.2,paste0("n=",length(which(!is.na(ped1.sort$gen.rank)))),cex=1.2)
legend('bottomleft',c("Resident","Translocated", "No contribution"),pch=21,col=c(rescol,transcol,alpha("grey40",0.65)),pt.bg=c(rescol,transcol,alpha("grey40",0)),bty='n', cex=1, pt.cex=1.3)

#dev.off()

# print top ten contributors based on pedigree
ped1.sort$ID[order(ped1.sort$ped.rank)][1:10]
# [1] "RLS-K" "WSA-K" "OK-RS" "K-SLA" "K-RSW" "SK-RG" "BK-FS" "SR-PK" "F-BPS"
#[10] "BK-LS"


# print top ten contributors based on genetic (K statistic) analysis
ped1.sort$ID[order(ped1.sort$gen.rank)][1:10]
# [1] "WSA-K" "K-RSW" "GK-YS" "SR-PK" "K-SBF" "K-SLA" "SK-WB" "K-SAG" "RK-YS"
#[10] "BK-FS"

--- end R code for comparing skew inference approaches ---


#
#
#


## ---------- CENSUS SIZE ---------- ##

## Examine population size change and the number of resident and translocated
## ancestral lineages contributing to the expected genetic makeup of CR local recruit cohorts over time.

--- begin R code for demographic expansion ---

library(scales)
library(TeachingDemos) # for shadowtext
library(shape) # for arrows

meta <- read.table("/home/tyler/Dropbox/research/jay/mosaic/metadata/jayid_map_20230512.txt",head=TRUE,sep="\t")
popdir='/home/tyler/Dropbox/research/jay/mosaic/pedigree/results/pop_temporal/'
lrdir='/home/tyler/Dropbox/research/jay/mosaic/pedigree/results/lr_temporal/'
ped <- read.table('/home/tyler/Dropbox/research/jay/mosaic/pedigree/cr_ped_20230512.tsv', head=TRUE, na.strings='*')
census <- read.csv('/home/tyler/Dropbox/research/jay/mosaic/metadata/20230512_metadata/Longform_Data_05122023.tsv', head=TRUE, sep="\t")
trans_data <- read.table('/home/tyler/Dropbox/research/jay/mosaic/metadata/Translocated_Jay_Individual_Statistics.tsv',head=TRUE,sep="\t")

pop.n <- NULL # data frame of number of expected genomic copies in population
cohort.n <- NULL # data frame of number of expecteed genomic copies contributed to cohort
cohort.n.adj <- NULL # data frame of number of expected genomic copies contributed to cohort minus self-contribution (due to some ancestors being local recruits, LRs)

# read in pedstat files for time points 2002-2022
time.periods = 2002:2022
tidx <- 2:(length(time.periods)+1) # these are the contribution columns in matrix
id <- NULL
n.anc = 74
for (t in time.periods) {
	fname.pop = paste0(popdir,'T_IE_20230512_',t,'_pop_contribution.pedstat1')
	if (file.exists(fname.pop)) {
		df <- read.table(fname.pop,head=TRUE)
		if (is.null(id)) id <- df[,1]
		pop.n <- cbind(pop.n, df[,2])
	} else pop.n <- cbind(pop.n,rep(NA,n.anc))

	fname.lr = paste0(lrdir,'T_IE_20230512_to_',t,'_LR_contribution.pedstat1')
	if (file.exists(fname.lr)) {
		df <- read.table(fname.lr,head=TRUE)
		if (is.null(id)) id <- df[,1]
		cohort.n <- cbind(cohort.n, df[,2])
		# mask self contribution
		vals <- df[,2]
		for (i in 1:length(vals)) {
			ind.id = df[i,1]
			pedidx = which(ped$ID == ind.id)
			if (length(pedidx) > 0) {
				if (ped$COHORT[pedidx] == t) vals[i] = vals[i]-1 # substract one genomic copy			
			}
		}
		cohort.n.adj = cbind(cohort.n.adj, vals)
	} else {
		cohort.n <- cbind(cohort.n,rep(NA,n.anc))
		cohort.n.adj <- cbind(cohort.n.adj,rep(NA,n.anc))
	}
}

# mask values of individuals if they weren't born
ped.sub <- ped[which(ped$ID %in% id),c(1,5)]
ped.sub <- ped.sub[match(id,ped.sub$ID),]
for (i in 1:length(time.periods)) {
	t = time.periods[i]
	idx <- which(ped.sub$COHORT > t)
	if (length(idx) > 0) {
		pop.n[idx,i] <- NA
		cohort.n[idx,i] <- NA
		cohort.n.adj[idx,i] <- NA
	}
}

# add annotations
pop.n <- cbind(data.frame(ID=id),as.data.frame(pop.n)) # add sample names
colnames(pop.n) <- c("ID",paste0("cohort.",time.periods))

cohort.n <- cbind(data.frame(ID=id),as.data.frame(cohort.n)) # add sample names
colnames(cohort.n) <- c("ID",paste0("cohort.",time.periods))

cohort.n.adj <- cbind(data.frame(ID=id),as.data.frame(cohort.n.adj)) # add sample names
colnames(cohort.n.adj) <- c("ID",paste0("cohort.",time.periods))

# find Resident and translocated indices
meta.sub <- meta[meta$COLOR_ID %in% cohort.n$ID,]
meta.sub <- meta.sub[match(cohort.n$ID,meta.sub$COLOR_ID),]

tidx <- which(meta.sub$Biological_Origin_Status == "T")
ridx <- which(meta.sub$Biological_Origin_Status == "IE" | meta.sub$Biological_Origin_Status == "LR")

## Track number of genetically contributing ancestral lineages to the CR population and cohorts over time.

# count number of ancestral lineages contributing to cohorts over time

n.contributors <- NULL
for (j in 4:ncol(cohort.n)) {
	anc.n <- length(which(!is.na(cohort.n[,j]) & cohort.n[,j] > 0))
	trans.n <- length(which(!is.na(cohort.n[tidx,j]) & cohort.n[tidx,j] > 0))
	res.n <- length(which(!is.na(cohort.n[ridx,j]) & cohort.n[ridx,j] > 0))
	n.contributors <- rbind(n.contributors, data.frame(YEAR=time.periods[j-1], N_CONTRIBUTORS = anc.n, N_RES = res.n, N_TRANS = trans.n))
}

#write.table(n.contributors,file='/home/tyler/Dropbox/research/jay/mosaic/pedigree/results/number_contributing_lineages_to_cohorts_cr_ped_20230512.tsv',col.names=TRUE,row.names=FALSE,sep="\t",quote=FALSE)

n.contributors # This is the number of ancestral lineages represented among CR cohorts born each year
#   YEAR N_CONTRIBUTORS N_RES N_TRANS
#1  2004             15    14       1
#2  2005              2     1       1
#3  2006              2     1       1
#4  2007              4     2       2
#5  2008              9     4       5
#6  2009              9     3       6
#7  2010             16     4      12
#8  2011             22     3      19
#9  2012             18     3      15
#10 2013             23     4      19
#11 2014              9     3       6
#12 2015             11     3       8
#13 2016             24     3      21
#14 2017             23     3      20
#15 2018             21     3      18
#16 2019             22     3      19
#17 2020             23     3      20
#18 2021             25     3      22
#19 2022             24     3      21

n.contributors.adj <- NULL
for (j in 4:ncol(cohort.n.adj)) {
	anc.n <- length(which(!is.na(cohort.n.adj[,j]) & cohort.n.adj[,j] > 0))
	trans.n <- length(which(!is.na(cohort.n.adj[tidx,j]) & cohort.n.adj[tidx,j] > 0))
	res.n <- length(which(!is.na(cohort.n.adj[ridx,j]) & cohort.n.adj[ridx,j] > 0))
	n.contributors.adj <- rbind(n.contributors.adj, data.frame(YEAR=time.periods[j-1], N_CONTRIBUTORS = anc.n, N_RES = res.n, N_TRANS = trans.n))
}

n.contributors.adj # This is the number of ancestral lineages represented among CR cohorts born each year excluding self-counting LRs considered to be contemporary CR ancestors
#   YEAR N_CONTRIBUTORS N_RES N_TRANS
#1  2004             10     9       1
#2  2005              2     1       1
#3  2006              2     1       1
#4  2007              4     2       2
#5  2008              8     3       5
#6  2009              9     3       6
#7  2010             16     4      12
#8  2011             22     3      19
#9  2012             18     3      15
#10 2013             23     4      19
#11 2014              9     3       6
#12 2015             11     3       8
#13 2016             24     3      21
#14 2017             23     3      20
#15 2018             21     3      18
#16 2019             22     3      19
#17 2020             23     3      20
#18 2021             25     3      22
#19 2022             24     3      21 


# count ancestral lineages present in the population

n.pop.lineages <- NULL
for (j in 2:ncol(pop.n)) {
	anc.n <- length(which(!is.na(pop.n[,j]) & pop.n[,j] > 0))
	trans.n <- length(which(!is.na(pop.n[tidx,j]) & pop.n[tidx,j] > 0))
	res.n <- length(which(!is.na(pop.n[ridx,j]) & pop.n[ridx,j] > 0))
	n.pop.lineages <- rbind(n.pop.lineages, data.frame(YEAR=time.periods[j-1], N_CONTRIBUTORS = anc.n, N_RES = res.n, N_TRANS = trans.n))
}

n.pop.lineages
#   YEAR N_CONTRIBUTORS N_RES N_TRANS
#1  2002              4     4       0
#2  2003             20    13       7
#3  2004             29    21       8
#4  2005             20    11       9
#5  2006             11     6       5
#6  2007             14     6       8
#7  2008             27     7      20
#8  2009             28     4      24
#9  2010             35     4      31
#10 2011             32     4      28
#11 2012             32     4      28
#12 2013             30     4      26
#13 2014             30     4      26
#14 2015             29     4      25
#15 2016             29     4      25
#16 2017             26     3      23
#17 2018             25     3      22
#18 2019             25     3      22
#19 2020             25     3      22
#20 2021             25     3      22
#21 2022             25     3      22


# make data.frame of number of translocated birds from 2003-2010 by donor site

trans.df <- NULL
for (t in sort(unique(trans_data$Year_Translocated))) {
	n = length(which(trans_data$Year_Translocated == t))
	site1.n <- length(which(trans_data$Year_Translocated == t & trans_data$Donor_Patch == "SITE 1"))
	site12.n <- length(which(trans_data$Year_Translocated == t & trans_data$Donor_Patch == "SITE 12"))
	site13.n <- length(which(trans_data$Year_Translocated == t & trans_data$Donor_Patch == "SITE 13"))
	site18.n <- length(which(trans_data$Year_Translocated == t & trans_data$Donor_Patch == "SITE 18"))
	tex.n <- length(which(trans_data$Year_Translocated == t & trans_data$Donor_Patch == "TEXACO"))
	trans.df <- rbind(trans.df, data.frame(YEAR=t, N_MOVED=n, SITE1_N = site1.n, SITE12_N = site12.n, SITE13_N = site13.n, SITE18_N = site18.n, TEXACO_N = tex.n))
}

trans.df
#  YEAR N_MOVED SITE1_N SITE12_N SITE13_N SITE18_N TEXACO_N
#1 2003       7       1        1        4        1        0
#2 2004       6       2        2        2        0        0
#3 2005       4       2        2        0        0        0
#4 2007       3       0        0        0        3        0
#5 2008      15       1        0       14        0        0
#6 2009       6       0        0        6        0        0
#7 2010      10       0        0        0        0       10

## Population census size through time.

# format census data

census.sub <- census[which(census$PROPERTY == "MW" | census$PROPERTY == "COKER" | census$PROPERTY == "DUETTE PRESERVE"),] # restrict census to Mosaic Wellfield, Duette Preserve, and the Coker Tract
census.sub <- census.sub[which(census.sub$Present == 1),] # remove individuals not seen
census.sub$COLOR_ID <- toupper(census.sub$COLOR_ID)

popsize <- NULL
for (t in sort(unique(census.sub$CENSUS_YEAR))) {
	n = length(unique(census.sub$COLOR_ID[which(census.sub$CENSUS_YEAR == t)]))
	popsize <- rbind(popsize, data.frame(YEAR=t, CENSUS_N = n))
}

popsize # census size
#   YEAR CENSUS_N
#1  2002        4
#2  2003       20
#3  2004       33
#4  2005       20
#5  2006       14
#6  2007       18
#7  2008       32
#8  2009       41
#9  2010       56
#10 2011       82
#11 2012       89
#12 2013       79
#13 2014       70
#14 2015       69
#15 2016       75
#16 2017      103
#17 2018      129
#18 2019      143
#19 2020      137
#20 2021      144
#21 2022      134


## Plot population size change over time (Figure 1C)

# limit data to years 2003+ for plotting
time.periods2 <- time.periods[2:length(time.periods)]
popsize.sub <- popsize[which(popsize$YEAR > 2002),]

#png(file='/home/tyler/Dropbox/research/jay/mosaic/figures/temporal_census_size_adjusted_2003_2022.png', width=16, height=7, units='in', res=300) # does not count self-contribution
x11(width=16,height=7)
par(mgp = c(2.75,1,0))
plot(1, type="n", xlim=c(time.periods2[1]-0.5,time.periods2[length(time.periods2)]), ylim=c(0,max(popsize.sub$CENSUS_N)+5),xlab="Year", ylab="Number individuals", 
main="",xaxt='n', cex.axis=1.3, cex.lab=1.5, xaxt='n')
axis(side=1,at=time.periods2,labels=time.periods2,cex=1.5,cex.axis=1.3)
axis(side=2,at=seq(from=0,to=150,by=25),labels=seq(from=0,to=150,by=25),cex=1.5,cex.axis=1.3)

lines(x=popsize.sub$YEAR, y=popsize.sub$CENSUS_N, lwd=2)
points(x=popsize.sub$YEAR, y=popsize.sub$CENSUS_N, pch=21, bg=alpha("black",0.5), col="black", cex=1.7, lwd=2)

# add arrows to denote translocations
for (t in trans.df$YEAR) {
	idx = which(popsize.sub$YEAR == t)
	y = popsize.sub$CENSUS_N[idx]
	n = trans.df$N_MOVED[which(trans.df$YEAR == t)]
	Arrows(x0=t, x1=t, y0=y+35, y1=y+10, col="black", lwd=2, arr.type="triangle", arr.width=0.25)
	text(x=t, y=y+42, labels=n, cex=1.5)
}

rect(xleft=2002.6, ybottom=38, xright=2003.6, ytop=50, col="white", border=NA)
text(x=2002.8, y=47, labels="Number", cex=1.3)
text(x=2002.8, y=41, labels="translocated", cex=1.3)

# add number of adjusted Resident ancestors contributing to cohorts (discounts self-contribution)
res.offset= -0.75
lines(x=n.contributors.adj$YEAR, y=n.contributors.adj$N_RES, col=alpha("palevioletred3",0.6), lwd=2, lty=5)
text(x=n.contributors.adj$YEAR, y=n.contributors.adj$N_RES+res.offset, labels=n.contributors.adj$N_RES, col="palevioletred3", cex=1.5, font=2) # use font=2 for bold

# add number adjusted Translocated ancestors contributing to cohorts (discounts self contribution)
trans.offset = 0.75
lines(x=n.contributors.adj$YEAR, y=n.contributors.adj$N_TRANS, col=alpha("royalblue",0.6), lwd=2, lty=5)
text(x=n.contributors.adj$YEAR, y=n.contributors.adj$N_TRANS+trans.offset, labels=n.contributors.adj$N_TRANS, col="royalblue",cex=1.5, font=2) # use font=2 for bold

# add legend

legend(x=2002,y=157, legend="Population size", lty=1, lwd=2, col="black", bty='n', cex=1.3)
points(x=2002.56, y=149, pch=21, bg=alpha("black",0.5), col="black", cex=1.7, lwd=2)
legend(x=2006,y=157, legend="Resident contributors", lty=5, lwd=2, col="palevioletred3", bty='n', cex=1.3)
legend(x=2010.95,y=157, legend="Translocated contributors", lty=5, lwd=2, col="royalblue", bty='n', cex=1.3)

#dev.off()

--- end R code for demographic expansion ----


#
#
#


## ---------- BREEDING PAIR ANALYSIS ---------- ##

Classify the frequency of different breeding pair types

--- start R code ---

# read in data
# Note that the cr_ancestors_20240602.tsv and cr_ped_20240602.tsv files are deposited to dryad. The CUMULATIVE_NESTING_DATA_FINAL_05122023.tsv data 
# are in the nest_metadata_20240602.tsv dryad file and also contained in the 'nest' tab of the M4_FSJ_monitoring.xlsx file on dryad.
nest <- read.csv('/home/tyler/Dropbox/research/jay/mosaic/metadata/20230512_metadata/CUMULATIVE_NESTING_DATA_FINAL_05122023.tsv', head=TRUE, sep="\t")
anc <- read.table('/home/tyler/Dropbox/research/jay/mosaic/simulations/pedigree_sims/inputs/cr_ancestors_20240602.tsv',head=FALSE)
ped <- read.table('/home/tyler/Dropbox/research/jay/mosaic/simulations/pedigree_sims/inputs/cr_ped_20240602.tsv',head=TRUE)

# get unique breeding pairs from 2003 (start of translocations) on
nest = nest[which(nest$YEAR > 2002),]
upairs <- unique(paste(nest$Breeding_Male,nest$Breeding_Female))
pairdf = data.frame(male=sapply(upairs,function(x){strsplit(x, " ")[[1]][1]},USE.NAMES=FALSE), female=sapply(upairs,function(x){strsplit(x, " ")[[1]][2]},USE.NAMES=FALSE))

# assign population
res = anc$V1[which(anc$V2 == "RESIDENT")]
ped$POPULATION[which(ped$ID %in% res == TRUE)] = "RESIDENT"
pairdf$male_population = sapply(pairdf$male,function(x,df){idx = which(df$ID == x); ifelse(length(idx) > 0, df$POPULATION[idx], NA)}, df=ped, USE.NAMES=FALSE)
pairdf$female_population = sapply(pairdf$female,function(x,df){idx = which(df$ID == x); ifelse(length(idx) > 0, df$POPULATION[idx], NA)}, df=ped, USE.NAMES=FALSE)

# extract subset of pairs involving only banded ancestors (in the pedigree)
pairdf.anc = pairdf[which(pairdf$male %in% anc$V1 == TRUE & !is.na(pairdf$male_population) & pairdf$female %in% anc$V1 == TRUE & !is.na(pairdf$female_population)),]

# add the total number of fledged offspring by pair
nest$Number_Fledged[which(nest$Number_Fledged == "FAILED" | nest$Number_Fledged == "ABANDONED")] = 0
nest$Number_Fledged[which(nest$Number_Fledged == "" | nest$Number_Fledged == "N/A" | nest$Number_Fledged == "UNKNOWN")] = NA
nest$Number_Fledged <- as.numeric(nest$Number_Fledged)

pairdf.anc$total_fledged = 0
for (i in 1:nrow(pairdf.anc)) {
        nfledge = nest$Number_Fledged[which(nest$Breeding_Male == pairdf.anc$male[i] & nest$Breeding_Female == pairdf.anc$female[i])]
        idx = which(!is.na(nfledge))
        if (length(idx) < 1) { pairdf.anc$total_fledged[i] = NA } else pairdf.anc$total_fledged[i] = sum(nfledge[idx])
}

# sort dataframe in descending order of the number of fledged offspring
pairdf.anc <- pairdf.anc[order(-pairdf.anc$total_fledged),]

# export table of each ancestral pairs fledging success (Table S1).
#write.table(pairdf.anc, file='/home/tyler/Dropbox/research/jay/mosaic/pedigree/results/ancestor_pair_fledging.txt', col.names=TRUE, row.names=FALSE, sep="\t", quote=FALSE)

# Tabulate fleding success by pairing type

pairdf.anc$pair_type = NA
for (i in 1:nrow(pairdf.anc)) {
        if (pairdf.anc$male_population[i] == "RESIDENT" && pairdf.anc$female_population[i] == "RESIDENT") {
                pairdf.anc$pair_type[i] = "RESIDENT"
        } else if ((pairdf.anc$male_population[i] == "RESIDENT" && pairdf.anc$female_population[i] != "RESIDENT") || 
                (pairdf.anc$male_population[i] != "RESIDENT" && pairdf.anc$female_population[i] == "RESIDENT")) {
                pairdf.anc$pair_type[i] = "RESIDENT_x_TRANSLOCATED"
        } else if (pairdf.anc$male_population[i] != "RESIDENT" && pairdf.anc$female_population[i] != "RESIDENT" && pairdf.anc$male_population[i] == pairdf.anc$female_population[i]) {
                pairdf.anc$pair_type[i] = "TRANSLOCATED_SAME"
        } else {
                pairdf.anc$pair_type[i] = "TRANSLOCATED_MIXED"
        }
}

pairtype.df = data.frame(pair_type = unique(pairdf.anc$pair_type), n_pairs = NA, total_fledged = NA)
for (i in 1:nrow(pairtype.df)) {
        idx = which(pairdf.anc$pair_type == pairtype.df$pair_type[i])
        pairtype.df$n_pairs[i] = length(idx)
        fledge = pairdf.anc$total_fledged[idx]
        if (length(which(is.na(fledge))) == length(fledge)) { pairtype.df$total_fledged[i] = NA } else { pairtype.df$total_fledged[i] = sum(fledge,na.rm=TRUE) }
}

# order by number of pairs
pairtype.df = pairtype.df[order(-pairtype.df$n_pairs),]

#write.table(pairtype.df, file='/home/tyler/Dropbox/research/jay/mosaic/pedigree/results/ancestor_pair_type_fledging.txt', col.names=TRUE, row.names=FALSE, sep="\t", quote=FALSE)

--- end R code ---


#
#
#


## ---------- SIMULATION REPRODUCTIVE SKEW ANALYSIS ---------- ##

Examine expected genetic contributions in simulations parameterized by the Mosaic Core Region pedigree but with uniformly random pairing (for breeding) and reproduction.

# Simulations and relateStats analysis of CR population

Note that for 'pedSimStats_v1.pl' (https://github.com/tplinderoth/research_studies/blob/main/Mosaic_FSJ/scripts/pedSimStats_v1.pl) was technically used to estimate 
pedigree statistics from the simulations. An updated version of this script, pedSimStats.pl (https://github.com/tplinderoth/research_studies/blob/main/Mosaic_FSJ/scripts/pedSimStats.pl), 
should produce identical results. The updates made to this script were to incorporate pedigree inbreeding calculations, but all original functionality of 'v1' should be maintained.

$ sbatch sim_pedigree_analysis_array.sh
implements:

--- start bash code ---

SEED_F="/mnt/research/Fitz_Lab/projects/mosaic/simulations/pedigree_sims/inputs/seeds/seeds_${SLURM_ARRAY_TASK_ID}.txt"
PED_F='/mnt/research/Fitz_Lab/projects/mosaic/simulations/pedigree_sims/inputs/cr_ped_20240602.tsv'
JAY_META_F='/mnt/research/Fitz_Lab/projects/mosaic/simulations/pedigree_sims/inputs/jayid_metadata_20240602.tsv'
NEST_META_F='/mnt/research/Fitz_Lab/projects/mosaic/simulations/pedigree_sims/inputs/nest_metadata_20240602.tsv'
ANC_F='/mnt/research/Fitz_Lab/projects/mosaic/simulations/pedigree_sims/inputs/cr_ancestors_20240602.tsv'
FOCAL_F='/mnt/research/Fitz_Lab/projects/mosaic/simulations/pedigree_sims/inputs/res_trans_focal_IDs.txt'
SIMPED='/mnt/research/Fitz_Lab/projects/mosaic/simulations/pedigree_sims/scripts/simPed.R'
RELSTATS='/mnt/research/Fitz_Lab/software/PopGenomicsTools/relateStats'
SIM_WRAPPER='/mnt/research/Fitz_Lab/projects/mosaic/simulations/pedigree_sims/scripts/pedSimStats_v1.pl'
OUTPREFIX="/mnt/research/Fitz_Lab/projects/mosaic/simulations/pedigree_sims/results/cr_sim_analysis_${SLURM_ARRAY_TASK_ID}"

CMD="$SIM_WRAPPER \
--ped_file $PED_F \
--indmeta $JAY_META_F \
--nestmeta $NEST_META_F \
--ancfile $ANC_F \
--out $OUTPREFIX \
--simexec $SIMPED \
--statsexec $RELSTATS \
--focal_ind $FOCAL_F \
--seed_file $SEED_F \
--rp 0 \
--maxoffspring 5 \
--mature 2 \
--p_male 0.5 \
2>/dev/null"

printf "\n%s\n\n" "$CMD"

eval $CMD

--- end bash code ---

Concatenate population analysis output from parallel jobs

--- begin bash code ---

for yr in {2002..2022}
do
	cmd="(cat cr_sim_analysis_1_${yr}.tsv"
	for i in {2..10}; do cmd+=" && tail -n+2 cr_sim_analysis_${i}_${yr}.tsv"; done
	cmd+=") > cr_sim_analysis_${yr}.tsv"
	eval $cmd
	wait	
done

--- end bash code ---

# Simulations and relateStats analysis of cohorts

$ sbatch sim_pedigree_cohort_analysis_array.sh
implements:

--- begin bash code ---

SEED_F="/mnt/research/Fitz_Lab/projects/mosaic/simulations/pedigree_sims/inputs/seeds/seeds_${SLURM_ARRAY_TASK_ID}.txt"
PED_F='/mnt/research/Fitz_Lab/projects/mosaic/simulations/pedigree_sims/inputs/cr_ped_20240602.tsv'
JAY_META_F='/mnt/research/Fitz_Lab/projects/mosaic/simulations/pedigree_sims/inputs/jayid_metadata_20240602.tsv'
NEST_META_F='/mnt/research/Fitz_Lab/projects/mosaic/simulations/pedigree_sims/inputs/nest_metadata_20240602.tsv'
ANC_F='/mnt/research/Fitz_Lab/projects/mosaic/simulations/pedigree_sims/inputs/cr_ancestors_20240602.tsv'
FOCAL_F='/mnt/research/Fitz_Lab/projects/mosaic/simulations/pedigree_sims/inputs/res_trans_focal_IDs.txt'
SIMPED='/mnt/research/Fitz_Lab/projects/mosaic/simulations/pedigree_sims/scripts/simPed.R'
RELSTATS='/mnt/research/Fitz_Lab/software/PopGenomicsTools/relateStats'
SIM_WRAPPER='/mnt/research/Fitz_Lab/projects/mosaic/simulations/pedigree_sims/scripts/pedSimStats_v1.pl'
OUTPREFIX="/mnt/research/Fitz_Lab/projects/mosaic/simulations/pedigree_sims/results/cr_sim_cohort_analysis_${SLURM_ARRAY_TASK_ID}"

CMD="$SIM_WRAPPER \
--ped_file $PED_F \
--indmeta $JAY_META_F \
--nestmeta $NEST_META_F \
--ancfile $ANC_F \
--out $OUTPREFIX \
--simexec $SIMPED \
--statsexec $RELSTATS \
--focal_ind $FOCAL_F \
--seed_file $SEED_F \
--rp 0 \
--maxoffspring 5 \
--mature 2 \
--p_male 0.5 \
--cohort \
2>/dev/null"

printf "\n%s\n\n" "$CMD"

eval $CMD

--- end bash code ---

Concatenate cohort analysis output from parallel jobs

--- begin bash code ---

for yr in {2002..2022}
do
	cmd="(cat cr_sim_cohort_analysis_1_${yr}.tsv"
	for i in {2..10}; do cmd+=" && tail -n+2 cr_sim_cohort_analysis_${i}_${yr}.tsv"; done
	cmd+=") > cr_sim_cohort_analysis_${yr}.tsv"
	eval $cmd
	wait
done

--- end bash code ---


# Make plots and calculate statitsics for the expected genetic contributions from simulations

--- begin R code ---

# load libraries
library(ggplot2)
library(scales) # alpha()
library(shape) # Arrows()

# parse data
ped = read.table('/home/tyler/Dropbox/research/jay/mosaic/pedigree/cr_ped_20230512.tsv',head=TRUE)
anc = read.table('/home/tyler/Dropbox/research/jay/mosaic/simulations/pedigree_sims/inputs/cr_ancestors_20240602.tsv',head=FALSE)
cohort_contribute = read.table('/home/tyler/Dropbox/research/jay/mosaic/pedigree/results/number_contributing_lineages_to_cohorts_cr_ped_20230512.tsv',head=TRUE)
sim_prefix='/home/tyler/Dropbox/research/jay/mosaic/simulations/pedigree_sims/results/cr_sim_analysis'
sim_cohort_prefix='/home/tyler/Dropbox/research/jay/mosaic/simulations/pedigree_sims/results/cr_sim_cohort_analysis'
obsdir='/home/tyler/Dropbox/research/jay/mosaic/pedigree/results/pop_temporal'
pedres = list(year=2002:2022, data=list())

for (i in 1:length(pedres$year)) {
	yr = pedres$year[i]
	pedres$sim[[i]] <- read.table(paste0(sim_prefix,"_",yr,".tsv"), head=TRUE)
	cohort_sim <- read.table(paste0(sim_cohort_prefix,"_",yr,".tsv"), head=TRUE)
	if (identical(pedres$sim[[i]]$SEED, cohort_sim$SEED) == TRUE) {
		pedres$sim[[i]]$N_RESIDENT_CONTRIBUTORS_COHORT = cohort_sim$N_RESIDENT_CONTRIBUTORS
		pedres$sim[[i]]$N_TRANSLOCATED_CONTRIBUTORS_COHORT = cohort_sim$N_TRANSLOCATED_CONTRIBUTORS
	} else stop("seeds in population and cohort simulations differ\n")
	pedres$obs[[i]] <- read.table(paste0(obsdir,"/T_IE_20230512_",yr,"_pop_contribution.pedstat1"), head=TRUE)
	pedres$obs[[i]]$ORIGIN = unname(sapply(pedres$obs[[i]]$ID, function(x,df){df$V2[which(df$V1 == x)]}, df=anc))
}

top16 = head(pedres$obs[[length(pedres$year)]][order(-pedres$obs[[length(pedres$year)]]$P_ANC_FOCAL),], n=16)$ID
top16.mod = gsub("-",".",top16)

# make data.frame of simulation stat quantiles
ci.df = NULL
for (i in 1:length(pedres$year)) {
	# max contributions CI
	max.q = unname(quantile(pedres$sim[[i]]$MAX_CONTRIBUTION, c(0, 0.025, 0.05, 0.95, 0.975, 1)))
	# number resident contributors CI
	res.q = unname(quantile(pedres$sim[[i]]$N_RESIDENT_CONTRIBUTORS_COHORT, c(0, 0.025, 0.05, 0.95, 0.975, 1), na.rm=TRUE))
	# number translocated individuals CI
	trans.q = unname(quantile(pedres$sim[[i]]$N_TRANSLOCATED_CONTRIBUTORS_COHORT, c(0, 0.025, 0.05,0.95, 0.975, 1), na.rm=TRUE))
	# RLS-K quantiles
	rlsk.q = unname(quantile(pedres$sim[[i]]$RLS.K, c(0, 0.025, 0.05, 0.95, 0.975, 1), na.rm=TRUE))
	# WSA-K quantiles
	wsak.q = unname(quantile(pedres$sim[[i]]$WSA.K, c(0, 0.025, 0.05,0.95, 0.975, 1), na.rm=TRUE))
	# top 16 contributors to 2022 qauntiles (in observed data)
	idx = which(colnames(pedres$sim[[i]]) %in% top16.mod == TRUE)
	top16_sim_p = sapply(1:nrow(pedres$sim[[i]]), function(x,j,df){sum(df[x,j])},j=idx,df=pedres$sim[[i]])
	top16.q = unname(quantile(top16_sim_p, c(0, 0.025, 0.05, 0.95, 0.975, 1), na.rm=TRUE))
	
	# observed values
	rlsk.obs = pedres$obs[[i]]$P_ANC_FOCAL[which(pedres$obs[[i]]$ID == "RLS-K")]
	wsak.obs = pedres$obs[[i]]$P_ANC_FOCAL[which(pedres$obs[[i]]$ID == "WSA-K")]
	top16_obs_p = sum(pedres$obs[[i]]$P_ANC_FOCAL[which(pedres$obs[[i]]$ID %in% top16 == TRUE)])
	idx = which(cohort_contribute$YEAR == pedres$year[i])
	n_res_contributors_cohort = NA
	n_trans_contributors_cohort = NA
	if (length(idx) > 0) {
		n_res_contributors_cohort = cohort_contribute$N_RES[idx]
		n_trans_contributors_cohort = cohort_contribute$N_TRANS[idx]
	}
	#n_res_contributors = length(which(pedres$obs[[i]]$ORIGIN == "RESIDENT" & pedres$obs[[i]]$P_ANC_FOCAL > 0))
	#n_trans_contributors = length(which(pedres$obs[[i]]$ORIGIN == "TRANSLOCATED" & pedres$obs[[i]]$P_ANC_FOCAL > 0))

	# add to dataframe
	ci.df = rbind(ci.df,data.frame(year=pedres$year[i], max_min = max.q[1], max_2.5 = max.q[2], max_5 = max.q[3], max_95 = max.q[4], max_97.5 = max.q[5], max_max = max.q[6],
	res_min = res.q[1], res_2.5 = res.q[2], res_5 = res.q[3], res_95 = res.q[4], res_97.5 = res.q[5], res_max = res.q[6],
	trans_min = trans.q[1], trans_2.5 = trans.q[2], trans_5 = trans.q[3], trans_95 = trans.q[4], trans_97.5 = trans.q[5], trans_max = trans.q[6],
	rlsk_min = rlsk.q[1], rlsk_2.5 = rlsk.q[2], rlsk_5 = rlsk.q[3], rlsk_95 = rlsk.q[4], rlsk_97.5 = rlsk.q[5], rlsk_max = rlsk.q[6],
	wsak_min = wsak.q[1], wsak_2.5 = wsak.q[2], wsak_5 = wsak.q[3], wsak_95 = wsak.q[4], wsak_97.5 = wsak.q[5], wsak_max = wsak.q[6],
	top16_min = top16.q[1], top16_2.5 = top16.q[2], top16_5 = top16.q[3], top16_95 = top16.q[4], top16_97.5 = top16.q[5], top16_max = top16.q[6],
	rlsk_obs = rlsk.obs, wsak_obs = wsak.obs, top16_obs = top16_obs_p,
	res_obs = n_res_contributors_cohort, trans_obs = n_trans_contributors_cohort))
}

# mask the years that RLS-K and and WSA-K were not in the Core Region
# RLK-K translocated in 2003. Mask years before this for nice plotting.
ci.df$rlsk_obs[1:which(ci.df$year == 2002)] = NA
ci.df$rlsk_min[1:which(ci.df$year == 2002)] = NA
ci.df$rlsk_5[1:which(ci.df$year == 2002)] = NA
ci.df$rlsk_95[1:which(ci.df$year == 2002)] = NA
ci.df$rlsk_max[1:which(ci.df$year == 2002)] = NA
# WSA-K translocated in 2008. Mask years before this for nice plotting. 
ci.df$wsak_obs[1:which(ci.df$year == 2007)] = NA
ci.df$wsak_min[1:which(ci.df$year == 2007)] = NA
ci.df$wsak_5[1:which(ci.df$year == 2007)] = NA
ci.df$wsak_95[1:which(ci.df$year == 2007)] = NA
ci.df$wsak_max[1:which(ci.df$year == 2007)] = NA

# plot simulation max contribution and lower 0.95 quantile with observed RLS-K and WSA-K contributions over time (Figure S5A)

first_lr_year = 2004 # this is the first year that local recruits were born into the CR

ci.df.reprosub = ci.df[which(ci.df$year == first_lr_year):nrow(ci.df),]

maxplot <- ggplot(ci.df.reprosub, aes(x=year, y=rlsk_obs)) + 
theme_classic() +
geom_ribbon(aes(ymin = max_min, ymax = max_max), fill="gray87") +
geom_ribbon(aes(ymin = max_min, ymax = max_95), fill="gray65") + 
geom_line(colour="red3", linewidth=1.5) +
geom_line(aes(x=year, y=wsak_obs), colour="blue1", linewidth=1.5) + 
scale_x_continuous(breaks=first_lr_year:2022) +
scale_y_continuous(name="Maximum proportion of ancestor contribution", 
breaks=seq(from=0,to=max(c(ci.df.reprosub$max_max, ci.df.reprosub$rlsk_obs, ci.df.reprosub$wsak_obs)+0.01,na.rm=TRUE), by=0.02)) +

theme(legend.position="none", axis.text.x = element_text(size=17,color="black"), axis.ticks.length.x=unit(0.25,"cm"), axis.title.x=element_text(size=20, color="black"),
axis.text.y = element_text(size=17,color="black"), axis.ticks.length.y=unit(0.25,"cm"),axis.title.y=element_text(size=20,color="black", vjust=1.5),
axis.title.y.right = element_text(size=20, color="black", vjust=1.5))

# uncomment to add line annotations
#annotate(geom="text", x = 2004.7, y = 0.028, label = "RLS-K", color="red3", size=5.5) +
#annotate(geom="text", x = 2008.4, y = 0.05, label = "WSA-K", color="blue1", size=5.5) +

x11(width=16,height=7)
#png(file='/home/tyler/Dropbox/research/jay/mosaic/figures/simulation/simulation_max_ancestor_contribution_.png',width=16, height=7, units='in', res=300)
maxplot
#dev.off()

max(ci.df.reprosub$max_max) # maximum simulated contribution in a single year by a single individual
#[1] 0.257174

# plot simulated RLS-K and WSA-K max contributions and 0.95 quantiles, along with observed contribution lines over time (Figure S4)

ci.df.rlsksub = ci.df[which(ci.df$year == 2003):nrow(ci.df),]

top_pair_plot <- ggplot(ci.df.rlsksub, aes(x=year, y=rlsk_obs)) +
theme_classic() +
geom_ribbon(aes(ymin = rlsk_min, ymax = rlsk_95), fill="lightcoral", alpha=0.5) +
geom_ribbon(aes(ymin = wsak_min, ymax = wsak_95), fill="lightblue3", alpha=0.6) +
geom_line(aes(x=year, y=rlsk_max), colour="lightcoral", alpha=0.5, linewidth=1.3, linetype="dashed") +
geom_line(aes(x=year, y=wsak_max), colour="lightblue3", alpha=0.6, linewidth=1.3, linetype="dashed") +
geom_line(colour="red3", linewidth=1.5) +
geom_line(aes(x=year, y=wsak_obs), colour="blue1", linewidth=1.5) +
scale_x_continuous(breaks=ci.df.rlsksub$year[1]:2022) +
scale_y_continuous(name="Proportion of ancestor contribution to population", 
breaks=seq(from=0,to=max(c(ci.df.rlsksub$rlsk_max, ci.df.rlsksub$rlsk_obs)+0.01,na.rm=TRUE), by=0.02)) +

theme(legend.position="none", axis.text.x = element_text(size=17,color="black"), axis.ticks.length.x=unit(0.25,"cm"), axis.title.x=element_text(size=20, color="black"),
axis.text.y = element_text(size=17,color="black"), axis.ticks.length.y=unit(0.25,"cm"),axis.title.y=element_text(size=20,color="black", vjust=1.5),
axis.title.y.right = element_text(size=20, color="black", vjust=1.5))

x11(width=16,height=7)
#png(file='/home/tyler/Dropbox/research/jay/mosaic/figures/simulation/simulation_rlsk_wsak_contribution.png',width=16, height=7, units='in', res=300)
top_pair_plot
#dev.off()

# plot simulated maximum and 0.95 quantile for the observed top 16 genetic contributors along with their observed contribution line over time (Figure S2)

top16_first_year = min(ped$COHORT[which(ped$ID %in% top16 == TRUE)])

ci.df.top16sub = ci.df[which(ci.df$year == top16_first_year):nrow(ci.df),]

top16_plot <- ggplot(ci.df.top16sub, aes(x=year, y=top16_obs)) +
theme_classic() +
geom_ribbon(aes(ymin = top16_min, ymax = top16_max), fill="gray87") +
geom_ribbon(aes(ymin = top16_min, ymax = top16_95), fill="gray65") +
geom_line(colour="black", linewidth=1.5) +
scale_x_continuous(breaks=top16_first_year:2022) +
scale_y_continuous(name="Proportion ancestor contribution by top contributors", breaks=seq(from=0,to=max(c(ci.df.top16sub$top16_max, ci.df.top16sub$top16_obs)+0.01,na.rm=TRUE), by=0.10)) +

theme(legend.position="none", axis.text.x = element_text(size=17,color="black"), axis.ticks.length.x=unit(0.25,"cm"), axis.title.x=element_text(size=20, color="black"),
axis.text.y = element_text(size=17,color="black"), axis.ticks.length.y=unit(0.25,"cm"),axis.title.y=element_text(size=20,color="black", vjust=1.5),
axis.title.y.right = element_text(size=20, color="black", vjust=1.5))

x11(width=16,height=7)
#png(file='/home/tyler/Dropbox/research/jay/mosaic/figures/simulation/simulation_top16_ancestors_contribution.png',width=16, height=7, units='in', res=300)
top16_plot
#dev.off()

# mean simulated contributions of observed top 16 contributors

top16_stats = NULL
for (i in 1:length(pedres$year)) {
	idx = which(colnames(pedres$sim[[i]]) %in% top16.mod == TRUE)
	top16_sum_p = sapply(1:nrow(pedres$sim[[i]]), function(x,j,df){sum(df[x,j])},j=idx,df=pedres$sim[[i]])
	top16_stats = rbind(top16_stats, data.frame(YEAR=pedres$year[i], MEAN=mean(top16_sum_p), SD=sd(top16_sum_p), MEDIAN=median(top16_sum_p)))
}


mean(top16_stats$MEAN[which(top16_stats$YEAR >=2015)])  # average expected contribution from 2015-2022
#[1] 0.5248555

max(ci.df.top16sub$top16_max) # maximum simulated contribution
#[1] 0.8041158
ci.df.top16sub$year[which(ci.df.top16sub$top16_max == max(ci.df.top16sub$top16_max))] # year of max contribution
#[1] 2019

length(which(ci.df.top16sub$top16_obs > ci.df.top16sub$top16_max)) # number of years that the observed contributions exceeded the max simulated contribution
#[1] 10
ci.df.top16sub$year[which(ci.df.top16sub$top16_obs > ci.df.top16sub$top16_max)] # years that the observed contributions exceeded max simulated contribution
#[1] 2010 2011 2012 2015 2016 2018 2019 2020 2021 2022


# plot simulated number of contributing resident and translocated lineages 95 interpercentile along with observed lines over time (Figure S3B)

contributors_plot <- ggplot(ci.df.reprosub, aes(x=year, y=trans_obs)) +
theme_classic() +
geom_ribbon(aes(ymin = trans_97.5, ymax = trans_max), fill="violetred", alpha=0.2) +
geom_ribbon(aes(ymin = trans_2.5, ymax = trans_97.5), fill="violetred", alpha=0.5) +
geom_ribbon(aes(ymin = trans_min, ymax = trans_2.5), fill="violetred", alpha=0.2) +
geom_ribbon(aes(ymin = res_97.5, ymax = res_max), fill="slateblue", alpha=0.2) +
geom_ribbon(aes(ymin = res_2.5, ymax = res_97.5), fill="slateblue", alpha=0.5) +
geom_ribbon(aes(ymin = res_min, ymax = res_2.5), fill="slateblue", alpha=0.2) +
geom_line(aes(x=year, y=trans_min), colour="violetred", alpha=0.1, linewidth=1, linetype="solid") +
geom_line(aes(x=year, y=trans_max), colour="violetred", alpha=0.1, linewidth=1, linetype="solid") +
geom_line(aes(x=year, y=res_min), colour="slateblue", alpha=0.1, linewidth=1, linetype="solid") +
geom_line(aes(x=year, y=res_max), colour="slateblue", alpha=0.1, linewidth=1, linetype="solid") +
geom_line(colour="violetred", linewidth=1.5) +
geom_line(aes(x=year, y=res_obs), colour="slateblue", linewidth=1.5) +
scale_x_continuous(breaks=ci.df.reprosub$year[1]:2022) +
scale_y_continuous(name="Number ancestor contributors to cohort", 
breaks=seq(from=0,to=max(c(ci.df.reprosub$trans_max, ci.df.reprosub$res_max, ci.df.reprosub$trans_obs, ci.df.reprosub$res_max),na.rm=TRUE), by=2)) +

theme(legend.position="none", axis.text.x = element_text(size=17,color="black"), axis.ticks.length.x=unit(0.25,"cm"), axis.title.x=element_text(size=20, color="black"),
axis.text.y = element_text(size=17,color="black"), axis.ticks.length.y=unit(0.25,"cm"),axis.title.y=element_text(size=20,color="black", vjust=1.5),
axis.title.y.right = element_text(size=20, color="black", vjust=1.5))

x11(width=16,height=7)
#png(file='/home/tyler/Dropbox/research/jay/mosaic/figures/simulation/simulation_number_ancestor_contributors_cohort.png',width=16, height=7, units='in', res=300)
contributors_plot
#dev.off()

# Maximum average contribution function

calcMaxAvg <- function(pedres=NULL, ped = NULL, start_year) {
	# make names vector of years ancestors enter the CR
	sim_anc_id = colnames(pedres$sim[[1]])[5:(ncol(pedres$sim[[1]])-2)]
	ped$ID_MOD = gsub("-",".",gsub("^-","X.",ped$ID))
	anc_cohort = sapply(sim_anc_id, function(x,df){df$COHORT[which(df$ID_MOD == x)[1]]}, df=ped)

	# calculate max average proportion contribution by an individual in the ancestral group
	max_avg = rep(NA,nrow(pedres$sim[[1]]))
	ind_avg = rep(NA, length(5:(ncol(pedres$sim[[1]])-2)))
	ind_val = rep(NA, length(pedres$year))
	for (sim_n in 1:nrow(pedres$sim[[1]])) {
	        print(sim_n)
	        ind_avg[1:length(ind_avg)] = NA
	        ind_iter = 1;
	        for (ind_idx in 5:(ncol(pedres$sim[[1]])-2)) {
	                id = colnames(pedres$sim[[yr_idx]])[ind_idx]
	                ind_val[1:length(ind_val)] = NA
	                year_iter = 1;
	                for (yr_idx in which(pedres$year == start_year):length(pedres$year)) {
	                        ind_val[year_iter] = ifelse(pedres$year[yr_idx] < anc_cohort[id], NA, pedres$sim[[yr_idx]][sim_n, ind_idx]) # max values if individual was not in population yet
	                        year_iter = year_iter+1
	                }
	                #print(ind_val);
	                ind_avg[ind_iter] = mean(ind_val, na.rm=TRUE)
	                ind_iter = ind_iter+1
	        }
	        #print(ind_avg)
	        max_avg[sim_n] = max(ind_avg, na.rm=TRUE)
	}

	return(max_avg)
}


# Histogram of maximum average contribution of any given individual considering all years (2002-2022). Only the years from when an individual 
# entered the pedigree and on were considered in the averaging since before that their contribution is 'NA' and NAs were ignored in the mean calculation. This is Figure S5B.
max_avg = calcMaxAvg(pedres = pedres, ped = ped, start_year = 2002)

#write.table(data.frame(SEED=pedres$sim[[1]]$SEED, MAX_AVERAGE_P_FOCAL_ANC = max_avg), file='/home/tyler/Dropbox/research/jay/mosaic/simulations/pedigree_sims/results/cr_sim_analysis_max_average_p_focal_anc.txt', col.names=TRUE, row.names=FALSE, quote=FALSE, sep="\t")

rlsk_max_avg = mean(sapply(which(pedres$year %in% 2003:2022 == TRUE),function(x,dat){dat$obs[[x]]$P_ANC_FOCAL[which(dat$obs[[x]]$ID == "RLS-K")]}, dat=pedres),na.rm=TRUE)
rlsk_max_avg.p = length(which(max_avg >= rlsk_max_avg))/length(max_avg)
wsak_max_avg = mean(sapply(which(pedres$year %in% 2008:2022 == TRUE),function(x,dat){dat$obs[[x]]$P_ANC_FOCAL[which(dat$obs[[x]]$ID == "WSA-K")]}, dat=pedres),na.rm=TRUE)
wsak_max_avg.p = length(which(max_avg >= wsak_max_avg))/length(max_avg)
xmax = 0.18 # max(max_avg) = 0.1668423
xmin = 0.02 # min(max_avg) = 0.0448871
#png(file='/home/tyler/Dropbox/research/jay/mosaic/figures/simulation/simulation_max_avg_pfocalanc_allyears_histogram.png', width=7, height=7, units='in', res=300)
hist(max_avg, xlab="Maximum average proportion of ancestor contribution", ylab="Density", main="", freq=FALSE, breaks=40, xlim=c(xmin,xmax),xaxt="n", cex.axis=1.3, cex.lab=1.3)
axis(side=1, at=seq(from=xmin, to=xmax, by=0.02), cex.axis=1.3)
max.avg.dense <- density(max_avg, bw=0.003)
lines(max.avg.dense, col=alpha("blue",0.5), lwd=1.5)
lines(x=c(rlsk_max_avg,rlsk_max_avg), y=c(0,8), col="red3", lwd=2)
text(x=rlsk_max_avg-0.005, y=9, label=substitute(paste("RLS-K ", italic(p), " = ", x, sep=""), list(x=rlsk_max_avg.p)), cex=1.3, adj=0)
lines(x=c(wsak_max_avg,wsak_max_avg), y=c(0,15), col="red3", lwd=2)
text(x=wsak_max_avg-0.005, y=16, label=substitute(paste("WSA-K ", italic(p), " = ", x, sep=""), list(x=wsak_max_avg.p)), cex=1.3, adj=0)
#dev.off()

max(max_avg) # maximum average contribution of a single ancestral lineage to the population
#[1] 0.1668423


# Histogram of maximum average population contribution by a single individual in 2022 with observed RLS-K contribution

idx.2022 = which(pedres$year == 2022)
max.2022 = pedres$sim[[idx.2022]]$MAX_CONTRIBUTION
xmin = 0.02 # min is 0.0534019
xmax = 0.26 # max is 0.242063
rlsk.2022 = pedres$obs[[idx.2022]]$P_ANC_FOCAL[which(pedres$obs[[idx.2022]]$ID == "RLS-K")]
rlsk.2022.p = rlsk.2022.p = length(which(max.2022 >= rlsk.2022))/length(max.2022)
#png(file='/home/tyler/Dropbox/research/jay/mosaic/figures/simulation/simulation_max_2022_contribution_histogram.png', width=7, height=7, units='in', res=300)
hist(max.2022, xlab="Maximum proportion of 2022 ancestor contribution", ylab="Density", main="", freq=FALSE, breaks=40, xlim=c(xmin,xmax),xaxt="n", cex.axis=1.3, cex.lab=1.3)
axis(side=1, at=seq(from=xmin, to=xmax, by=0.04), cex.axis=1.3)
max.dense <- density(max.2022, bw=0.005)
lines(max.dense, col=alpha("blue",0.5), lwd=1.5)
lines(x=c(rlsk.2022,rlsk.2022), y=c(0,8), col="red3", lwd=2)
text(x=rlsk.2022-0.01, y=8.5, label=substitute(paste("RLS-K ", italic(p), " = ", x, sep=""), list(x=rlsk.2022.p)), cex=1.3, adj=0)
#dev.off()

# Histogram of maximum number of contributors to 2022 cohort (Figure S3A)

n_sim_contribute_cohort = rep(NA,nrow(pedres$sim[[1]]))
cohort_idx = which(pedres$year == 2022)
for (i in 1:length(n_sim_contribute_cohort)) {
	n_sim_contribute_cohort[i] = pedres$sim[[cohort_idx]]$N_RESIDENT_CONTRIBUTORS_COHORT[i] + pedres$sim[[cohort_idx]]$N_TRANSLOCATED_CONTRIBUTORS_COHORT[i] 
}

cohort_obs_idx = which(ci.df$year == 2022)
obs_cohort_contribute = ci.df$res_obs[cohort_obs_idx] + ci.df$trans_obs[cohort_obs_idx]
n_sim_contribute_cohort.table = table(n_sim_contribute_cohort)
barcol = rep('grey',length(n_sim_contribute_cohort.table))
#barcol[which(names(n_sim_contribute_cohort.table) == as.character(obs_cohort_contribute))] = "red3"
barcol[which(as.numeric(names(n_sim_contribute_cohort.table)) <= obs_cohort_contribute)] = "red3"
cohort_contribute.p = length(which(n_sim_contribute_cohort <= obs_cohort_contribute))/length(n_sim_contribute_cohort)
cohort_contribute_obs.p = length(which(n_sim_contribute_cohort == obs_cohort_contribute))/length(n_sim_contribute_cohort)
arr.x = which(names(n_sim_contribute_cohort.table) == as.character(obs_cohort_contribute)) + 1
#png(file='/home/tyler/Dropbox/research/jay/mosaic/figures/simulation/simulation_n_ancestor_contributors_2022.png', width=7, height=7, units='in', res=300)
#png(file='/home/tyler/Dropbox/research/jay/mosaic/figures/simulation/simulation_n_ancestor_contributors_2022_v2.png', width=7, height=7, units='in', res=300)
png(file='/home/tyler/Dropbox/research/jay/mosaic/figures/simulation/simulation_n_ancestor_contributors_2022_v2_plain.png', width=7, height=7, units='in', res=300)
barplot(n_sim_contribute_cohort.table, xlab="Number genetically contributing ancestors to 2022 cohort", ylab = "Frequency", cex.names=1.3, cex.axis=1.3, cex.lab=1.3, col=barcol)
#Arrows(x0 = arr.x, x1 = arr.x, y0 = 800, y1=500, arr.type = "simple", lwd=2, col="red3")
#Arrows(x0 = arr.x, x1 = arr.x, y0 = 800, y1=500, arr.type = "simple", lwd=2, col="black")
#text(x=arr.x-1.5, y=840, label=substitute(paste(italic(p), " = ", x, sep=""), list(x=cohort_contribute_obs.p)), cex=1.3)
#text(x=arr.x-1.5, y=840, label=substitute(paste(italic(p), " = ", x, sep=""), list(x=cohort_contribute.p)), cex=1.3)
#dev.off()

length(which(n_sim_contribute_cohort < obs_cohort_contribute))/length(n_sim_contribute_cohort) # probability of fewer than observed contributors to 2022 cohort
#[1] 0.0544

cohort_contribute_obs.p # probability of the observed number of contributors
#[1] 0.046

cohort_contribute.p # probility of less than or equal to the observed number of contributors
#[1] 0.1004

--- end R code ---
